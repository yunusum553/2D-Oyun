/*! For license information please see index_debug.js.LICENSE.txt */
require("source-map-support").install(), (() => {
  "use strict";
  var e = {
    128: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LoggingMessage = void 0, function (e) {
        e.EmptySourceCode = "Empty source code. Obfuscation canceled...", e.ObfuscationCompleted = "Obfuscation completed. Total time: %s sec.", e.ObfuscationStarted = "Obfuscation started...", e.RandomGeneratorSeed = "Random generator seed: %s...", e.CodeTransformationStage = "Code transformation stage: %s...", e.NodeTransformationStage = "AST transformation stage: %s...", e.Version = "Version: %s"
      }(r || (t.LoggingMessage = r = {}))
    }, 605: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallsTransformThresholdRule = void 0, t.StringArrayCallsTransformThresholdRule = e => (0 === e.stringArrayCallsTransformThreshold && (e = {
        ...e,
        stringArrayCallsTransform: !1,
        stringArrayCallsTransformThreshold: 0
      }), e)
    }, 677: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BlockStatementControlFlowFlatteningNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(52849), m = r(39032), g = r(76393), h = r(31142),
        y = r(50164), S = r(8053), N = r(93571), b = r(27391), _ = r(33056);
      let v = class extends S.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t, r) {
          this.blockStatementBody = e, this.shuffledKeys = t, this.originalKeysIndexesInShuffledArray = r
        }

        getNodeStructure() {
          const e = this.randomGenerator.getRandomString(6), t = this.randomGenerator.getRandomString(6),
            r = N.NodeFactory.blockStatementNode([N.NodeFactory.variableDeclarationNode([N.NodeFactory.variableDeclaratorNode(N.NodeFactory.identifierNode(e), N.NodeFactory.callExpressionNode(N.NodeFactory.memberExpressionNode(N.NodeFactory.literalNode(this.originalKeysIndexesInShuffledArray.join(f.StringSeparator.VerticalLine)), N.NodeFactory.identifierNode("split")), [N.NodeFactory.literalNode(f.StringSeparator.VerticalLine)]))], "const"), N.NodeFactory.variableDeclarationNode([N.NodeFactory.variableDeclaratorNode(N.NodeFactory.identifierNode(t), N.NodeFactory.literalNode(0))], "let"), N.NodeFactory.whileStatementNode(N.NodeFactory.literalNode(!0), N.NodeFactory.blockStatementNode([N.NodeFactory.switchStatementNode(N.NodeFactory.memberExpressionNode(N.NodeFactory.identifierNode(e), N.NodeFactory.updateExpressionNode("++", N.NodeFactory.identifierNode(t)), !0), this.shuffledKeys.map((e, t) => {
              const r = this.blockStatementBody[e], o = [r];
              return b.NodeGuards.isReturnStatementNode(r) || o.push(N.NodeFactory.continueStatement()), N.NodeFactory.switchCaseNode(N.NodeFactory.literalNode(String(t)), o)
            })), N.NodeFactory.breakStatement()]))]);
          return _.NodeUtils.parentizeAst(r), [r]
        }
      };
      t.BlockStatementControlFlowFlatteningNode = v, s([(0, y.initializable)(), c("design:type", Array)], v.prototype, "blockStatementBody", void 0), s([(0, y.initializable)(), c("design:type", Array)], v.prototype, "originalKeysIndexesInShuffledArray", void 0), s([(0, y.initializable)(), c("design:type", Array)], v.prototype, "shuffledKeys", void 0), t.BlockStatementControlFlowFlatteningNode = v = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== g.IOptions && g.IOptions) ? a : Object])], v)
    }, 900: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SeedRule = void 0, t.SeedRule = e => e.seed ? {
        ...e,
        seed: e.seed
      } : { ...e, seed: Math.floor(1e9 * Math.random() + 0) }
    }, 928: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCustomNode = void 0, function (e) {
        e.StringArrayCallNode = "StringArrayCallNode", e.StringArrayScopeCallsWrapperFunctionNode = "StringArrayScopeCallsWrapperFunctionNode", e.StringArrayScopeCallsWrapperVariableNode = "StringArrayScopeCallsWrapperVariableNode"
      }(r || (t.StringArrayCustomNode = r = {}))
    }, 1322: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p, u = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, f = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, m = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayScopeCallsWrapperFunctionNode = void 0;
      const g = r(45337), h = r(31391), y = r(18741), S = r(46293), N = r(26906), b = r(39032), _ = r(76393),
        v = r(31142), I = r(70475), O = r(28523), C = r(50164), E = r(43382), T = r(93571), R = r(33056);
      let M = class extends E.AbstractStringArrayCallNode {
        constructor(e, t, r, o, n, i, a) {
          super(e, t, r, o, n, i, a)
        }

        initialize(e, t) {
          this.stringArrayScopeCallsWrapperData = e, this.upperStringArrayCallsWrapperData = t
        }

        getNodeStructure() {
          var e, t, r, o, n, i, a, s;
          const c = T.NodeFactory.identifierNode(this.randomGenerator.getRandomString(6)),
            l = T.NodeFactory.identifierNode(this.randomGenerator.getRandomString(6)),
            d = this.getUpperStringArrayCallNode(c, this.getStringArrayIndexNode(this.stringArrayScopeCallsWrapperData.index - this.upperStringArrayCallsWrapperData.index)),
            p = this.arrayUtils.fillWithRange(this.stringArrayScopeCallsWrapperData.parameterIndexesData ? this.options.stringArrayWrappersParametersMaxCount : E.AbstractStringArrayCallNode.stringArrayRootCallsWrapperParametersCount, () => this.getFakeParameterNode());
          p.splice(null !== (t = null === (e = this.stringArrayScopeCallsWrapperData.parameterIndexesData) || void 0 === e ? void 0 : e.valueIndexParameterIndex) && void 0 !== t ? t : 0, 1, c), p.splice(null !== (o = null === (r = this.stringArrayScopeCallsWrapperData.parameterIndexesData) || void 0 === r ? void 0 : r.decodeKeyParameterIndex) && void 0 !== o ? o : 1, 1, l);
          const u = this.arrayUtils.fillWithRange(this.upperStringArrayCallsWrapperData.parameterIndexesData ? this.options.stringArrayWrappersParametersMaxCount : E.AbstractStringArrayCallNode.stringArrayRootCallsWrapperParametersCount, e => this.getUpperStringArrayCallNode(p[e], this.getFakeUpperStringArrayIndexNode()));
          u.splice(null !== (i = null === (n = this.upperStringArrayCallsWrapperData.parameterIndexesData) || void 0 === n ? void 0 : n.valueIndexParameterIndex) && void 0 !== i ? i : 0, 1, d), u.splice(null !== (s = null === (a = this.upperStringArrayCallsWrapperData.parameterIndexesData) || void 0 === a ? void 0 : a.decodeKeyParameterIndex) && void 0 !== s ? s : 1, 1, l);
          const f = T.NodeFactory.functionDeclarationNode(this.stringArrayScopeCallsWrapperData.name, p, T.NodeFactory.blockStatementNode([T.NodeFactory.returnStatementNode(T.NodeFactory.callExpressionNode(T.NodeFactory.identifierNode(this.upperStringArrayCallsWrapperData.name), u))])),
            m = f;
          R.NodeUtils.parentizeAst(m);
          for (const e of p) e.name = this.identifierNamesGenerator.generateForLexicalScope(f);
          return [m]
        }

        getUpperStringArrayCallNode(e, t) {
          return T.NodeFactory.binaryExpressionNode("-", e, t)
        }

        getFakeParameterNode() {
          return T.NodeFactory.identifierNode(this.randomGenerator.getRandomString(6))
        }

        getFakeUpperStringArrayIndexNode() {
          return this.getStringArrayIndexNode(this.randomGenerator.getRandomInteger(0, 500))
        }
      };
      t.StringArrayScopeCallsWrapperFunctionNode = M, u([(0, C.initializable)(), f("design:type", "function" == typeof (d = void 0 !== I.IStringArrayScopeCallsWrapperData && I.IStringArrayScopeCallsWrapperData) ? d : Object)], M.prototype, "upperStringArrayCallsWrapperData", void 0), u([(0, C.initializable)(), f("design:type", "function" == typeof (p = void 0 !== I.IStringArrayScopeCallsWrapperData && I.IStringArrayScopeCallsWrapperData) ? p : Object)], M.prototype, "stringArrayScopeCallsWrapperData", void 0), t.StringArrayScopeCallsWrapperFunctionNode = M = u([(0, g.injectable)(), m(0, (0, g.inject)(h.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), m(1, (0, g.inject)(h.ServiceIdentifiers.Factory__IStringArrayIndexNode)), m(2, (0, g.inject)(h.ServiceIdentifiers.ICustomCodeHelperFormatter)), m(3, (0, g.inject)(h.ServiceIdentifiers.IStringArrayStorage)), m(4, (0, g.inject)(h.ServiceIdentifiers.IArrayUtils)), m(5, (0, g.inject)(h.ServiceIdentifiers.IRandomGenerator)), m(6, (0, g.inject)(h.ServiceIdentifiers.IOptions)), f("design:paramtypes", ["function" == typeof (o = void 0 !== y.TIdentifierNamesGeneratorFactory && y.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== S.TStringArrayIndexNodeFactory && S.TStringArrayIndexNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== b.ICustomCodeHelperFormatter && b.ICustomCodeHelperFormatter) ? i : Object, "function" == typeof (a = void 0 !== O.IStringArrayStorage && O.IStringArrayStorage) ? a : Object, "function" == typeof (s = void 0 !== N.IArrayUtils && N.IArrayUtils) ? s : Object, "function" == typeof (c = void 0 !== v.IRandomGenerator && v.IRandomGenerator) ? c : Object, "function" == typeof (l = void 0 !== _.IOptions && _.IOptions) ? l : Object])], M)
    }, 1561: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 1851: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ParentificationTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(13245), m = r(33056);
      let g = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Preparing ? { enter: (e, t) => this.transformNode(e, t) } : null
        }

        transformNode(e, t) {
          return m.NodeUtils.parentizeNode(e, t)
        }
      };
      t.ParentificationTransformer = g, t.ParentificationTransformer = g = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], g)
    }, 1896: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMDeclarationCompiler = void 0;
      const s = r(45337), c = r(20924), l = r(94487), d = r(31391), p = r(27391), u = r(59805);
      let f = class {
        compileVariableDeclaration(e, t) {
          var r, o, n, i, a, s, c, l, d;
          const f = this.vmCompilerUtils.createInstructionBuilder(t);
          for (const m of e.declarations) if (p.NodeGuards.isIdentifierNode(m.id)) {
            const l = m.id.name, d = "let" === e.kind || "const" === e.kind;
            let p, g, h = !1;
            const y = !d && t.parameters.has(l);
            if (d ? (p = (0, u.getScopedVariableName)(l, t.blockScopeDepth), g = this.vmCompilerUtils.getNextLocalIndex(t)) : y ? (g = t.parameters.get(l), p = l, h = !0) : (p = l, t.localVariables.has(p) ? (g = t.localVariables.get(p), h = !0) : (g = t.localVariables.size, t.localVariables.set(p, g))), m.init) null === (r = t.dispatch) || void 0 === r || r.expression(m.init); else {
              if (h) continue;
              f.pushUndefined()
            }
            d && (t.variableScopes.set(p, {
              depth: t.blockScopeDepth,
              index: g
            }), t.localVariables.set(p, g), null === (o = t.activeBlockScopes) || void 0 === o || o.add(p));
            let S = !1;
            if ((null === (n = t.perIterationLoopVars) || void 0 === n ? void 0 : n.has(l)) && t.blockScopeDepth > 1) {
              for (let e = t.blockScopeDepth - 1; e >= 0; e--) {
                const r = (0, u.getScopedVariableName)(l, e);
                if (t.variableScopes.has(r) || t.localVariables.has(r) || 0 === e && t.localVariables.has(l)) {
                  S = !0;
                  break
                }
              }
              !S && t.envVars.has(l) && t.parameters.has(l) && (S = !0)
            }
            const N = null !== (a = null === (i = t.perIterationLoopVars) || void 0 === i ? void 0 : i.has(l)) && void 0 !== a && a && !S;
            N && d && (t.perIterationVarScopedKeys || (t.perIterationVarScopedKeys = new Set), t.perIterationVarScopedKeys.add(p));
            let b = !1;
            if (1 === t.blockScopeDepth && 1 === t.envDepth) {
              const e = (0, u.getScopedVariableName)(l, 0);
              (t.variableScopes.has(e) || t.variableScopes.has(l)) && t.envVars.has(l) && (b = !0)
            }
            const _ = d && (t.blockScopeDepth > 1 || b) && !N ? p : l;
            if ((l !== t.functionName || d) && (t.envVars.has(_) || !S && t.envVars.has(l) || N && null !== (c = null === (s = t.perIterationLoopVars) || void 0 === s ? void 0 : s.has(l)) && void 0 !== c && c)) {
              const r = t.constantPool.add(_), o = "const" === e.kind;
              t.envDepth > 0 && d ? o ? f.storeToCurrentEnvConst(r) : f.storeToCurrentEnv(r) : o ? f.storeToEnvConst(r) : d ? f.storeToCurrentEnv(r) : f.storeToEnv(r)
            } else if (y) f.storeArg(g); else {
              const r = this.vmCompilerUtils.getActualLocalIndex(g, t);
              f.storeLocal(r), "const" === e.kind && t.constLocalVariables.add(r)
            }
            d && this.scopeManager.exitLocalTDZ(t, l)
          } else if (p.NodeGuards.isArrayPatternNode(m.id) || p.NodeGuards.isObjectPatternNode(m.id)) {
            m.init ? null === (l = t.dispatch) || void 0 === l || l.expression(m.init) : f.pushUndefined();
            const r = t._declarationKind;
            t._declarationKind = e.kind, null === (d = t.dispatch) || void 0 === d || d.destructuring(m.id, !1), t._declarationKind = r, "let" !== e.kind && "const" !== e.kind || this.vmCompilerUtils.extractIdentifiersFromPattern(m.id).forEach(e => {
              this.scopeManager.exitLocalTDZ(t, e)
            })
          }
        }

        compileFunctionDeclaration(e, t) {
          var r, o;
          if (!e.id) return;
          const n = e.id.name;
          if (0 === t.blockScopeDepth && t.hoistedFunctionDeclarations.has(n)) return;
          const i = t.blockScopeDepth > 0, a = i ? (0, u.getScopedVariableName)(n, t.blockScopeDepth) : n;
          let s;
          t.localVariables.has(a) ? s = t.localVariables.get(a) : (s = t.localVariables.size, t.localVariables.set(a, s), i && (t.variableScopes.set(a, {
            depth: t.blockScopeDepth,
            index: s
          }), null === (r = t.activeBlockScopes) || void 0 === r || r.add(a))), null === (o = t.dispatch) || void 0 === o || o.functionExpression(e);
          const c = t.envVars.has(n), l = this.vmCompilerUtils.createInstructionBuilder(t);
          if (c) {
            const e = this.vmCompilerUtils.getActualLocalIndex(s, t);
            l.dup(), l.storeLocal(e);
            const r = t.constantPool.add(n);
            l.storeToCurrentEnv(r)
          } else {
            const e = this.vmCompilerUtils.getActualLocalIndex(s, t);
            l.storeLocal(e)
          }
        }
      };
      t.VMDeclarationCompiler = f, i([(0, s.inject)(d.ServiceIdentifiers.IVMCompilerUtils), a("design:type", "function" == typeof (o = void 0 !== c.IVMCompilerUtils && c.IVMCompilerUtils) ? o : Object)], f.prototype, "vmCompilerUtils", void 0), i([(0, s.inject)(d.ServiceIdentifiers.IVMScopeManager), a("design:type", "function" == typeof (n = void 0 !== l.IVMScopeManager && l.IVMScopeManager) ? n : Object)], f.prototype, "scopeManager", void 0), t.VMDeclarationCompiler = f = i([(0, s.injectable)()], f)
    }, 2396: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeTransformersRunner = void 0;
      const c = r(45337), l = r(31391), d = r(28031), p = r(44966);
      let u = class {
        constructor(e, t) {
          this.codeTransformerFactory = e, this.codeTransformerNamesGroupsBuilder = t
        }

        transform(e, t, r) {
          if (!t.length) return e;
          const o = this.buildNormalizedCodeTransformers(t, r), n = this.codeTransformerNamesGroupsBuilder.build(o);
          for (const t of n) for (const n of t) e = o[n].transformCode(e, r);
          return e
        }

        buildNormalizedCodeTransformers(e, t) {
          return e.reduce((e, t) => {
            const r = this.codeTransformerFactory(t);
            return { ...e, [t]: r }
          }, {})
        }
      };
      t.CodeTransformersRunner = u, t.CodeTransformersRunner = u = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.Factory__ICodeTransformer)), s(1, (0, c.inject)(l.ServiceIdentifiers.ICodeTransformerNamesGroupsBuilder)), a("design:paramtypes", ["function" == typeof (o = void 0 !== d.TCodeTransformerFactory && d.TCodeTransformerFactory) ? o : Object, "function" == typeof (n = void 0 !== p.ITransformerNamesGroupsBuilder && p.ITransformerNamesGroupsBuilder) ? n : Object])], u)
    }, 2566: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p, u = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, f = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, m = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayScopeCallsWrapperVariableNode = void 0;
      const g = r(45337), h = r(31391), y = r(18741), S = r(46293), N = r(26906), b = r(39032), _ = r(76393),
        v = r(31142), I = r(70475), O = r(28523), C = r(50164), E = r(43382), T = r(93571), R = r(33056);
      let M = class extends E.AbstractStringArrayCallNode {
        constructor(e, t, r, o, n, i, a) {
          super(e, t, r, o, n, i, a)
        }

        initialize(e, t) {
          this.stringArrayScopeCallsWrapperData = e, this.stringArrayCallsWrapperData = t
        }

        getNodeStructure() {
          const e = T.NodeFactory.variableDeclarationNode([T.NodeFactory.variableDeclaratorNode(T.NodeFactory.identifierNode(this.stringArrayScopeCallsWrapperData.name), T.NodeFactory.identifierNode(this.stringArrayCallsWrapperData.name))], "const");
          return R.NodeUtils.parentizeAst(e), [e]
        }
      };
      t.StringArrayScopeCallsWrapperVariableNode = M, u([(0, C.initializable)(), f("design:type", "function" == typeof (d = void 0 !== I.IStringArrayScopeCallsWrapperData && I.IStringArrayScopeCallsWrapperData) ? d : Object)], M.prototype, "stringArrayCallsWrapperData", void 0), u([(0, C.initializable)(), f("design:type", "function" == typeof (p = void 0 !== I.IStringArrayScopeCallsWrapperData && I.IStringArrayScopeCallsWrapperData) ? p : Object)], M.prototype, "stringArrayScopeCallsWrapperData", void 0), t.StringArrayScopeCallsWrapperVariableNode = M = u([(0, g.injectable)(), m(0, (0, g.inject)(h.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), m(1, (0, g.inject)(h.ServiceIdentifiers.Factory__IStringArrayIndexNode)), m(2, (0, g.inject)(h.ServiceIdentifiers.ICustomCodeHelperFormatter)), m(3, (0, g.inject)(h.ServiceIdentifiers.IStringArrayStorage)), m(4, (0, g.inject)(h.ServiceIdentifiers.IArrayUtils)), m(5, (0, g.inject)(h.ServiceIdentifiers.IRandomGenerator)), m(6, (0, g.inject)(h.ServiceIdentifiers.IOptions)), f("design:paramtypes", ["function" == typeof (o = void 0 !== y.TIdentifierNamesGeneratorFactory && y.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== S.TStringArrayIndexNodeFactory && S.TStringArrayIndexNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== b.ICustomCodeHelperFormatter && b.ICustomCodeHelperFormatter) ? i : Object, "function" == typeof (a = void 0 !== O.IStringArrayStorage && O.IStringArrayStorage) ? a : Object, "function" == typeof (s = void 0 !== N.IArrayUtils && N.IArrayUtils) ? s : Object, "function" == typeof (c = void 0 !== v.IRandomGenerator && v.IRandomGenerator) ? c : Object, "function" == typeof (l = void 0 !== _.IOptions && _.IOptions) ? l : Object])], M)
    }, 2784: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 2878: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMLoopCompiler = void 0;
      const d = r(45337), p = r(20924), u = r(94487), f = r(2784), m = r(46725), g = r(31391), h = r(27391),
        y = r(59805);
      let S = class {
        constructor(e, t, r, o) {
          this.vmCompilerUtils = e, this.scopeManager = t, this.destructuringCompiler = r, this.variableCollector = o
        }

        compileWhileStatement(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t), i = t.instructions.length;
          null === (r = t.dispatch) || void 0 === r || r.expression(e.test);
          const a = n.jumpIfFalse(), s = a.getIndex();
          t.breakTargets.push(s), this.scopeManager.pushBreakEnvDepth(t), t.continueTargets.push(i), this.scopeManager.pushContinueEnvDepth(t), t.currentLabel && (t.labelContinueTargets.set(t.currentLabel, i), t.currentLabel = null), null === (o = t.dispatch) || void 0 === o || o.statement(e.body), n.jump().patchTo(i);
          const c = t.instructions.length;
          a.patchTo(c), this.vmCompilerUtils.patchLoopBreakStatements(s, c, t), t.breakTargets.pop(), this.scopeManager.popBreakEnvDepth(t), t.continueTargets.pop(), this.scopeManager.popContinueEnvDepth(t)
        }

        compileDoWhileStatement(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t), i = t.instructions.length,
            a = t.instructions.length;
          t.breakTargets.push(a), this.scopeManager.pushBreakEnvDepth(t);
          const s = -(a + 1);
          t.continueTargets.push(s), this.scopeManager.pushContinueEnvDepth(t), t.currentLabel && (t.labelContinueTargets.set(t.currentLabel, s), t.currentLabel = null), null === (r = t.dispatch) || void 0 === r || r.statement(e.body);
          const c = t.instructions.length;
          null === (o = t.dispatch) || void 0 === o || o.expression(e.test), n.jumpIfTrue().patchTo(i);
          const l = t.instructions.length;
          this.vmCompilerUtils.patchLoopBreakStatements(a, l, t), this.vmCompilerUtils.patchJumpTargets(i, l - 1, s, c, t), t.breakTargets.pop(), this.scopeManager.popBreakEnvDepth(t), t.continueTargets.pop(), this.scopeManager.popContinueEnvDepth(t)
        }

        compileForStatement(e, t) {
          var r, o, n, i, a, s, c;
          const l = this.vmCompilerUtils.createInstructionBuilder(t), d = [];
          let p = !1, u = !1, f = !1;
          if (e.init && h.NodeGuards.isVariableDeclarationNode(e.init) && ("let" === e.init.kind || "const" === e.init.kind)) {
            u = !0;
            for (const o of e.init.declarations) if (h.NodeGuards.isIdentifierNode(o.id)) {
              const n = o.id.name;
              this.vmCompilerUtils.containsFunction(e.body) && (p = !0, d.push(n), (null !== (r = t.parentContext && this.vmCompilerUtils.isDeclaredInParentScope(n, t.parentContext)) && void 0 !== r ? r : t.envVars.has(n)) ? (t.envVars.add(n), f = !0) : t.envVars.add(n), t.perIterationLoopVars || (t.perIterationLoopVars = new Set), t.perIterationLoopVars.add(n))
            }
          }
          let m = null;
          if (u && (m = this.scopeManager.enterBlock(t)), f && (l.getEnv(), l.createEnv(), t.envDepth++), e.init) if (h.NodeGuards.isVariableDeclarationNode(e.init)) {
            if (u && m && ("let" === e.init.kind || "const" === e.init.kind)) for (const r of e.init.declarations) if (h.NodeGuards.isIdentifierNode(r.id)) {
              const e = r.id.name, n = (0, y.getScopedVariableName)(e, t.blockScopeDepth);
              this.scopeManager.trackBlockVariable(m, n), null === (o = t.activeBlockScopes) || void 0 === o || o.add(n)
            }
            null === (n = t.dispatch) || void 0 === n || n.statement(e.init)
          } else null === (i = t.dispatch) || void 0 === i || i.expression(e.init), l.pop();
          const g = t.instructions.length;
          let S = null;
          if (e.test) {
            null === (a = t.dispatch) || void 0 === a || a.expression(e.test);
            const r = l.jumpIfFalse(), o = r.getIndex();
            r.patchTo(0), t.breakTargets.push(o), this.scopeManager.pushBreakEnvDepth(t), S = o
          } else S = g, t.breakTargets.push(S), this.scopeManager.pushBreakEnvDepth(t);
          if (p) {
            l.getEnv(), l.createEnv(), t.envDepth++;
            for (const e of d) l.loadFromEnvByName(e), l.storeToCurrentEnvByName(e)
          }
          const N = t.instructions.length;
          t.continueTargets.push(N), this.scopeManager.pushContinueEnvDepth(t), t.currentLabel && (t.labelContinueTargets.set(t.currentLabel, N), t.currentLabel = null), null === (s = t.dispatch) || void 0 === s || s.statement(e.body), p && (l.restoreParentEnv(), t.envDepth--);
          const b = t.instructions.length;
          e.update && (null === (c = t.dispatch) || void 0 === c || c.expression(e.update), l.pop()), l.jump().patchTo(g);
          const _ = t.instructions.length;
          this.patchForLoopTargets(S, N, b, _, t), t.continueTargets.pop(), this.scopeManager.popContinueEnvDepth(t), f && (l.restoreParentEnv(), t.envDepth--), m && this.scopeManager.exitBlockWithHandle(t, m)
        }

        compileForOfStatement(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          null === (r = t.dispatch) || void 0 === r || r.expression(e.right), n.getIterator();
          const { actualIndex: i } = this.vmCompilerUtils.createTempLocal(`__forof_iterator_${t.localVariables.size}`, t);
          n.storeLocal(i), n.pop();
          const a = this.analyzeIterableLoopVariable(e, t), s = t.instructions.length;
          n.loadLocal(i), n.iteratorNext(), n.dup(), n.iteratorDone();
          const c = n.jumpIfTrue(), l = c.getIndex(), d = t.instructions.length;
          this.pushLoopTargets(l, d, t), a.needsNewEnv && this.enterIterationEnv(n, t), n.getProp("value"), this.storeSimpleLoopVariable(a, n, t) || (a.loopDestructuringPattern ? this.handleDestructuringLoopVariable(a, t) : n.pop());
          const p = this.setupLoopVarEnvTracking(a, t);
          null === (o = t.dispatch) || void 0 === o || o.statement(e.body), this.cleanupLoopVarEnvTracking(a, p, t), a.needsNewEnv && this.exitIterationEnv(n, t);
          const u = t.instructions.length;
          n.jump().patchTo(s);
          const f = t.instructions.length;
          n.pop();
          const m = t.instructions.length;
          c.patchTo(f), this.vmCompilerUtils.patchJumpTargets(d, f - 1, d, u, t), this.vmCompilerUtils.patchJumpTargets(d, f - 1, l, m, t), this.popLoopTargets(t)
        }

        compileForInStatement(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          null === (r = t.dispatch) || void 0 === r || r.expression(e.right), n.emitStaticMethodCall("Object", "keys", 1);
          const { actualIndex: i } = this.vmCompilerUtils.createTempLocal(`__forin_keys_${t.localVariables.size}`, t);
          n.storeLocal(i), n.pop();
          const { actualIndex: a } = this.vmCompilerUtils.createTempLocal(`__forin_counter_${t.localVariables.size}`, t);
          n.loadConst(0), n.storeLocal(a), n.pop();
          const s = this.analyzeIterableLoopVariable(e, t), c = t.instructions.length;
          n.loadLocal(a), n.loadLocal(i), n.getProp("length"), n.lessThan();
          const l = n.jumpIfFalse(), d = l.getIndex(), p = t.instructions.length;
          this.pushLoopTargets(d, p, t), s.needsNewEnv && this.enterIterationEnv(n, t), n.loadLocal(i), n.loadLocal(a), n.getComputed(), this.storeSimpleLoopVariable(s, n, t) || (s.loopDestructuringPattern ? this.handleDestructuringLoopVariable(s, t) : n.pop());
          const u = this.setupLoopVarEnvTracking(s, t);
          null === (o = t.dispatch) || void 0 === o || o.statement(e.body), this.cleanupLoopVarEnvTracking(s, u, t), s.needsNewEnv && this.exitIterationEnv(n, t);
          const f = t.instructions.length;
          this.emitCounterIncrement(a, n), n.jump().patchTo(c);
          const m = t.instructions.length;
          l.patchToHere(), this.vmCompilerUtils.patchJumpTargets(p, m - 1, p, f, t), this.popLoopTargets(t)
        }

        patchForLoopTargets(e, t, r, o, n) {
          if (null !== e && n.breakTargets.length > 0) {
            const e = n.breakTargets.pop();
            this.scopeManager.popBreakEnvDepth(n), void 0 !== e && (n.instructions[e].target = o, this.vmCompilerUtils.patchJumpTargets(e, o - 1, e, o, n))
          }
          this.vmCompilerUtils.patchJumpTargets(t, o - 1, t, r, n)
        }

        pushLoopTargets(e, t, r) {
          r.breakTargets.push(e), this.scopeManager.pushBreakEnvDepth(r), r.continueTargets.push(t), this.scopeManager.pushContinueEnvDepth(r), r.currentLabel && (r.labelContinueTargets.set(r.currentLabel, t), r.currentLabel = null)
        }

        popLoopTargets(e) {
          e.breakTargets.pop(), this.scopeManager.popBreakEnvDepth(e), e.continueTargets.pop(), this.scopeManager.popContinueEnvDepth(e)
        }

        enterIterationEnv(e, t) {
          e.getEnv(), e.createEnv(), t.envDepth++
        }

        exitIterationEnv(e, t) {
          e.restoreParentEnv(), t.envDepth--
        }

        emitCounterIncrement(e, t) {
          t.loadLocal(e), t.loadConst(1), t.add(), t.storeLocal(e), t.pop()
        }

        analyzeIterableLoopVariable(e, t) {
          let r = null, o = null, n = null, i = !1, a = !1, s = "var";
          if (h.NodeGuards.isVariableDeclarationNode(e.left)) {
            i = "let" === e.left.kind || "const" === e.left.kind, s = e.left.kind;
            const c = e.left.declarations[0];
            if (c) if (h.NodeGuards.isIdentifierNode(c.id)) r = c.id.name, this.scopeManager.checkShadowing(t, r, {
              variableKind: "loop",
              hasBlockScopedDecl: i
            }).shadows ? a = !0 : t.localVariables.has(r) ? o = t.localVariables.get(r) : (o = t.localVariables.size, t.localVariables.set(r, o)); else if ((h.NodeGuards.isArrayPatternNode(c.id) || h.NodeGuards.isObjectPatternNode(c.id)) && (n = c.id, i)) {
              const e = new Set;
              this.variableCollector.collectFromPattern(c.id, e);
              for (const r of e) if (this.scopeManager.checkShadowing(t, r, {
                variableKind: "loop",
                hasBlockScopedDecl: !0
              }).shadows) {
                a = !0;
                break
              }
            }
          }
          return {
            loopVarName: r,
            loopVarLocalIndex: o,
            loopDestructuringPattern: n,
            hasBlockScopedLoopVar: i,
            needsNewEnv: a,
            declarationKind: s
          }
        }

        storeSimpleLoopVariable(e, t, r) {
          if (!e.loopVarName) return !1;
          if (e.needsNewEnv) {
            const o = r.constantPool.add(e.loopVarName);
            return "const" === e.declarationKind ? t.storeToCurrentEnvConst(o) : t.storeToCurrentEnv(o), !0
          }
          if (null !== e.loopVarLocalIndex) {
            const o = this.vmCompilerUtils.getActualLocalIndex(e.loopVarLocalIndex, r);
            return t.storeLocal(o), t.pop(), !0
          }
          return !1
        }

        handleDestructuringLoopVariable(e, t) {
          if (e.loopDestructuringPattern) if (e.needsNewEnv && e.hasBlockScopedLoopVar) {
            const r = new Set;
            this.variableCollector.collectFromPattern(e.loopDestructuringPattern, r);
            const o = Array.from(r), n = [];
            for (const e of o) t.envVars.has(e) || (t.envVars.add(e), n.push(e));
            t.perIterationLoopVars || (t.perIterationLoopVars = new Set);
            for (const e of o) t.perIterationLoopVars.add(e);
            const i = [];
            if (t.activeBlockScopes) for (const e of o) for (let r = t.blockScopeDepth; r >= 0; r--) {
              const o = (0, y.getScopedVariableName)(e, r);
              t.activeBlockScopes.has(o) && (t.activeBlockScopes.delete(o), i.push(o))
            }
            void 0 !== t._removedFromActiveBlockScopes && (t._previousRemovedFromActiveBlockScopes = t._removedFromActiveBlockScopes), t._removedFromActiveBlockScopes = i;
            const a = t._declarationKind;
            t._declarationKind = e.declarationKind;
            const s = new Set(t.localVariables.keys());
            this.destructuringCompiler.compileDestructuringPattern(e.loopDestructuringPattern, t, !0), t._declarationKind = a;
            const c = [];
            for (const e of t.localVariables.keys()) !s.has(e) && o.includes(e) && c.push(e);
            for (const e of c) t.localVariables.delete(e);
            void 0 !== t._loopDestructuredVarsToCleanup && (t._previousLoopDestructuredVarsToCleanup = t._loopDestructuredVarsToCleanup), t._loopDestructuredVarsToCleanup = n
          } else {
            const r = t._declarationKind;
            t._declarationKind = e.declarationKind, this.destructuringCompiler.compileDestructuringPattern(e.loopDestructuringPattern, t, !0), t._declarationKind = r
          }
        }

        setupLoopVarEnvTracking(e, t) {
          const r = e.loopVarName && t.envVars.has(e.loopVarName), o = !(!e.needsNewEnv || !e.loopVarName || r);
          if (o && e.loopVarName && (t.envVars.add(e.loopVarName), t.perIterationLoopVars || (t.perIterationLoopVars = new Set), t.perIterationLoopVars.add(e.loopVarName)), e.needsNewEnv && e.loopVarName && e.hasBlockScopedLoopVar && t.activeBlockScopes) {
            const r = [];
            for (let o = t.blockScopeDepth; o >= 0; o--) {
              const n = (0, y.getScopedVariableName)(e.loopVarName, o);
              t.activeBlockScopes.has(n) && (t.activeBlockScopes.delete(n), r.push(n))
            }
            r.length > 0 && (void 0 !== t._removedFromActiveBlockScopes && (t._previousRemovedFromActiveBlockScopes = t._removedFromActiveBlockScopes), t._removedFromActiveBlockScopes = r)
          }
          return o
        }

        cleanupLoopVarEnvTracking(e, t, r) {
          var o, n;
          t && e.loopVarName && (r.envVars.delete(e.loopVarName), null === (o = r.perIterationLoopVars) || void 0 === o || o.delete(e.loopVarName));
          const i = r._loopDestructuredVarsToCleanup, a = r._previousLoopDestructuredVarsToCleanup;
          if (i) {
            for (const e of i) r.envVars.delete(e), null === (n = r.perIterationLoopVars) || void 0 === n || n.delete(e);
            void 0 !== a ? (r._loopDestructuredVarsToCleanup = a, delete r._previousLoopDestructuredVarsToCleanup) : delete r._loopDestructuredVarsToCleanup
          }
          const s = r._removedFromActiveBlockScopes, c = r._previousRemovedFromActiveBlockScopes;
          if (s && r.activeBlockScopes) {
            for (const e of s) r.activeBlockScopes.add(e);
            void 0 !== c ? (r._removedFromActiveBlockScopes = c, delete r._previousRemovedFromActiveBlockScopes) : delete r._removedFromActiveBlockScopes
          }
        }
      };
      t.VMLoopCompiler = S, t.VMLoopCompiler = S = s([(0, d.injectable)(), l(0, (0, d.inject)(g.ServiceIdentifiers.IVMCompilerUtils)), l(1, (0, d.inject)(g.ServiceIdentifiers.IVMScopeManager)), l(2, (0, d.inject)(g.ServiceIdentifiers.IVMDestructuringBytecodeCompiler)), l(3, (0, d.inject)(g.ServiceIdentifiers.IVMVariableCollector)), c("design:paramtypes", ["function" == typeof (o = void 0 !== p.IVMCompilerUtils && p.IVMCompilerUtils) ? o : Object, "function" == typeof (n = void 0 !== u.IVMScopeManager && u.IVMScopeManager) ? n : Object, "function" == typeof (i = void 0 !== f.IVMDestructuringBytecodeCompiler && f.IVMDestructuringBytecodeCompiler) ? i : Object, "function" == typeof (a = void 0 !== m.IVMVariableCollector && m.IVMVariableCollector) ? a : Object])], S)
    }, 2993: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ExpressionWithOperatorControlFlowStorageCallNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(50164),
        y = r(8053), S = r(93571), N = r(33056);
      let b = class extends y.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t, r, o) {
          this.controlFlowStorageName = e, this.controlFlowStorageKey = t, this.leftValue = r, this.rightValue = o
        }

        getNodeStructure() {
          const e = S.NodeFactory.expressionStatementNode(S.NodeFactory.callExpressionNode(S.NodeFactory.memberExpressionNode(S.NodeFactory.identifierNode(this.controlFlowStorageName), S.NodeFactory.identifierNode(this.controlFlowStorageKey)), [this.leftValue, this.rightValue]));
          return N.NodeUtils.parentizeAst(e), [e]
        }
      };
      t.ExpressionWithOperatorControlFlowStorageCallNode = b, s([(0, h.initializable)(), c("design:type", String)], b.prototype, "controlFlowStorageKey", void 0), s([(0, h.initializable)(), c("design:type", String)], b.prototype, "controlFlowStorageName", void 0), t.ExpressionWithOperatorControlFlowStorageCallNode = b = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], b)
    }, 3147: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CallsGraphAnalyzer = void 0;
      const u = r(45337), f = r(31391), m = l(r(31659)), g = r(15914), h = r(21593), y = r(27391), S = r(43243);
      let N = n = class {
        constructor(e) {
          this.calleeDataExtractorFactory = e
        }

        static getLimitIndex(e) {
          const t = e - 1, r = n.limitThresholdActivationLength - 1;
          let o = t;
          return t > r && (o = Math.round(r + t * n.limitThreshold), o > t && (o = t)), o
        }

        analyze(e) {
          return this.analyzeRecursive(e.body)
        }

        analyzeRecursive(e) {
          const t = n.getLimitIndex(e.length), r = [], o = e.length;
          for (let n = 0; n < o && !(n > t); n++) {
            const t = e[n];
            m.traverse(t, {
              enter: o => {
                if (y.NodeGuards.isCallExpressionNode(o)) return t.parentNode !== S.NodeStatementUtils.getParentNodeWithStatements(o) ? m.VisitorOption.Skip : void this.analyzeCallExpressionNode(r, e, o)
              }
            })
          }
          return r
        }

        analyzeCallExpressionNode(e, t, r) {
          n.calleeDataExtractorsList.forEach(o => {
            const n = this.calleeDataExtractorFactory(o).extract(t, r.callee);
            n && e.push({ ...n, callsGraph: this.analyzeRecursive(n.callee.body) })
          })
        }
      };
      t.CallsGraphAnalyzer = N, N.calleeDataExtractorsList = [h.CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor, h.CalleeDataExtractor.FunctionExpressionCalleeDataExtractor, h.CalleeDataExtractor.ObjectExpressionCalleeDataExtractor], N.limitThresholdActivationLength = 25, N.limitThreshold = .002, t.CallsGraphAnalyzer = N = n = c([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__ICalleeDataExtractor)), d("design:paramtypes", ["function" == typeof (i = void 0 !== g.TCalleeDataExtractorFactory && g.TCalleeDataExtractorFactory) ? i : Object])], N)
    }, 3437: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 3464: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      }, d = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.RenamePropertiesReplacer = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(76393), g = r(59290), h = d(r(7192)), y = r(27391),
        S = r(93571);
      let N = o = class {
        constructor(e, t, r) {
          this.excludedPropertyNames = new Set, this.propertyNamesMap = new Map, this.identifierNamesGenerator = e(r), this.propertyIdentifierNamesCacheStorage = t, this.options = r
        }

        excludePropertyName(e) {
          this.excludedPropertyNames.add(e)
        }

        replace(e) {
          return y.NodeGuards.isIdentifierNode(e) ? S.NodeFactory.identifierNode(this.replacePropertyName(e.name)) : y.NodeGuards.isLiteralNode(e) && "string" == typeof e.value ? S.NodeFactory.literalNode(this.replacePropertyName(e.value)) : e
        }

        replacePropertyName(e) {
          var t, r;
          if (this.isReservedName(e)) return this.identifierNamesGenerator.preserveName(e), e;
          let o = this.options.identifierNamesCache && null !== (t = this.propertyIdentifierNamesCacheStorage.get(e)) && void 0 !== t ? t : null;
          return o = null !== (r = null != o ? o : this.propertyNamesMap.get(e)) && void 0 !== r ? r : null, null !== o || (o = this.identifierNamesGenerator.generateNext(), this.propertyNamesMap.set(e, o), this.options.identifierNamesCache && this.propertyIdentifierNamesCacheStorage.set(e, o)), o
        }

        isReservedName(e) {
          return this.isExcludedName(e) || this.isReservedOptionName(e) || this.isReservedDomPropertyName(e)
        }

        isExcludedName(e) {
          return this.excludedPropertyNames.has(e)
        }

        isReservedOptionName(e) {
          return !!this.options.reservedNames.length && this.options.reservedNames.some(t => null !== new RegExp(t, "g").exec(e))
        }

        isReservedDomPropertyName(e) {
          return o.reservedDomPropertiesList.has(e)
        }
      };
      t.RenamePropertiesReplacer = N, N.reservedDomPropertiesList = new Set(h.default), t.RenamePropertiesReplacer = N = o = s([(0, p.injectable)(), l(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, p.inject)(u.ServiceIdentifiers.IPropertyIdentifierNamesCacheStorage)), l(2, (0, p.inject)(u.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (n = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== g.IPropertyIdentifierNamesCacheStorage && g.IPropertyIdentifierNamesCacheStorage) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 3734: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      }, c = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.RandomGenerator = void 0;
      const l = r(45337), d = r(31391), p = c(r(60976)), u = r(71024), f = r(76393), m = r(55668), g = r(55194),
        h = r(6088);
      let y = class {
        constructor(e, t) {
          this.sourceCode = e, this.options = t, this.randomGenerator = new u.Chance(this.getRawSeed())
        }

        getMathRandom() {
          return this.getRandomInteger(0, 99999) / 1e5
        }

        getRandomGenerator() {
          return this.randomGenerator
        }

        getRandomInteger(e, t) {
          return this.getRandomGenerator().integer({ min: e, max: t })
        }

        getRandomIntegerExcluding(e, t, r) {
          const o = [];
          for (let n = e; n <= t; n++) r.includes(n) || o.push(n);
          return this.randomGenerator.pickone(o)
        }

        getRandomString(e, t) {
          return Math.random().toString(e).substr(2, e)
        }

        getInputSeed() {
          return this.options.seed.toString()
        }

        getRawSeed() {
          const e = this.getInputSeed();
          return `${e}`.split("|").length > 1 ? e : `${e}|${(0, p.default)(this.sourceCode.getSourceCode())}`
        }
      };
      t.RandomGenerator = y, y.randomGeneratorPool = `${g.alphabetString}${h.alphabetStringUppercase}`, t.RandomGenerator = y = i([(0, l.injectable)(), s(0, (0, l.inject)(d.ServiceIdentifiers.ISourceCode)), s(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== m.ISourceCode && m.ISourceCode) ? o : Object, "function" == typeof (n = void 0 !== f.IOptions && f.IOptions) ? n : Object])], y)
    }, 3749: e => {
      e.exports = require("acorn")
    }, 3977: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMInstructionBuilder = void 0;
      const a = r(45337), s = r(25115), c = r(87575), l = r(83779);
      let d = class {
        constructor(e) {
          this.context = e
        }

        pushUndefined() {
          return this.emit({ op: s.VMOpCode.PUSH_UNDEFINED }), this
        }

        pushNull() {
          return this.emit({ op: s.VMOpCode.PUSH_NULL }), this
        }

        pushTrue() {
          return this.emit({ op: s.VMOpCode.PUSH_CONST, arg: this.context.constantPool.add(!0) }), this
        }

        pushFalse() {
          return this.emit({ op: s.VMOpCode.PUSH_CONST, arg: this.context.constantPool.add(!1) }), this
        }

        dup() {
          return this.emit({ op: s.VMOpCode.DUP }), this
        }

        pop() {
          return this.emit({ op: s.VMOpCode.POP }), this
        }

        swap() {
          return this.emit({ op: s.VMOpCode.SWAP }), this
        }

        loadConst(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.PUSH_CONST, arg: t }), this
        }

        loadConstByIndex(e) {
          return this.validateIndex(e, "constant"), this.emit({ op: s.VMOpCode.PUSH_CONST, arg: e }), this
        }

        loadArg(e) {
          return this.validateIndex(e, "parameter"), this.emit({ op: s.VMOpCode.LOAD_ARG, arg: e }), this
        }

        loadLocal(e) {
          return this.validateIndex(e, "local variable"), this.emit({ op: s.VMOpCode.LOAD_LOCAL, arg: e }), this
        }

        storeLocal(e) {
          return this.validateIndex(e, "local variable"), this.emit({ op: s.VMOpCode.STORE_LOCAL, arg: e }), this
        }

        loadFromEnv(e) {
          return this.validateIndex(e, "environment name"), this.emit({ op: s.VMOpCode.LOAD_FROM_ENV, arg: e }), this
        }

        loadFromEnvByName(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.LOAD_FROM_ENV, arg: t }), this
        }

        storeToEnv(e) {
          return this.validateIndex(e, "environment name"), this.emit({ op: s.VMOpCode.STORE_TO_ENV, arg: e }), this
        }

        storeToEnvByName(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.STORE_TO_ENV, arg: t }), this
        }

        storeToCurrentEnv(e) {
          return this.validateIndex(e, "environment name"), this.emit({
            op: s.VMOpCode.STORE_TO_CURRENT_ENV,
            arg: e
          }), this
        }

        storeToCurrentEnvByName(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.STORE_TO_CURRENT_ENV, arg: t }), this
        }

        loadGlobal(e) {
          return this.validateIndex(e, "global name"), this.emit({ op: s.VMOpCode.GET_GLOBAL, arg: e }), this
        }

        loadGlobalByName(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.GET_GLOBAL, arg: t }), this
        }

        storeGlobal(e) {
          return this.validateIndex(e, "global name"), this.emit({ op: s.VMOpCode.SET_GLOBAL, arg: e }), this
        }

        storeGlobalByName(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.SET_GLOBAL, arg: t }), this
        }

        storeArg(e) {
          return this.validateIndex(e, "parameter"), this.emit({ op: s.VMOpCode.STORE_ARG, arg: e }), this
        }

        storeToEnvConst(e) {
          return this.validateIndex(e, "environment name"), this.emit({
            op: s.VMOpCode.STORE_TO_ENV_CONST,
            arg: e
          }), this
        }

        storeToCurrentEnvConst(e) {
          return this.validateIndex(e, "environment name"), this.emit({
            op: s.VMOpCode.STORE_TO_CURRENT_ENV_CONST,
            arg: e
          }), this
        }

        getEnv() {
          return this.emit({ op: s.VMOpCode.GET_ENV, arg: 0 }), this
        }

        createEnv() {
          return this.emit({ op: s.VMOpCode.CREATE_ENV, arg: 0 }), this
        }

        restoreParentEnv() {
          return this.emit({ op: s.VMOpCode.RESTORE_PARENT_ENV, arg: 0 }), this
        }

        declareTDZ(e) {
          return this.emit({ op: s.VMOpCode.DECLARE_TDZ, arg: this.context.constantPool.add(e) }), this
        }

        add() {
          return this.emit({ op: s.VMOpCode.ADD }), this
        }

        subtract() {
          return this.emit({ op: s.VMOpCode.SUB }), this
        }

        multiply() {
          return this.emit({ op: s.VMOpCode.MUL }), this
        }

        divide() {
          return this.emit({ op: s.VMOpCode.DIV }), this
        }

        remainder() {
          return this.emit({ op: s.VMOpCode.MOD }), this
        }

        exponentiation() {
          return this.emit({ op: s.VMOpCode.EXPONENT }), this
        }

        negate() {
          return this.emit({ op: s.VMOpCode.NEG }), this
        }

        increment() {
          return this.emit({ op: s.VMOpCode.INC }), this
        }

        decrement() {
          return this.emit({ op: s.VMOpCode.DEC }), this
        }

        equal() {
          return this.emit({ op: s.VMOpCode.EQ }), this
        }

        strictEqual() {
          return this.emit({ op: s.VMOpCode.STRICT_EQ }), this
        }

        notEqual() {
          return this.emit({ op: s.VMOpCode.NEQ }), this
        }

        strictNotEqual() {
          return this.emit({ op: s.VMOpCode.STRICT_NEQ }), this
        }

        lessThan() {
          return this.emit({ op: s.VMOpCode.LT }), this
        }

        lessEqual() {
          return this.emit({ op: s.VMOpCode.LTE }), this
        }

        greaterThan() {
          return this.emit({ op: s.VMOpCode.GT }), this
        }

        greaterEqual() {
          return this.emit({ op: s.VMOpCode.GTE }), this
        }

        logicalNot() {
          return this.emit({ op: s.VMOpCode.LOGICAL_NOT }), this
        }

        bitwiseAnd() {
          return this.emit({ op: s.VMOpCode.BIT_AND }), this
        }

        bitwiseOr() {
          return this.emit({ op: s.VMOpCode.BIT_OR }), this
        }

        bitwiseXor() {
          return this.emit({ op: s.VMOpCode.BIT_XOR }), this
        }

        bitwiseNot() {
          return this.emit({ op: s.VMOpCode.BIT_NOT }), this
        }

        leftShift() {
          return this.emit({ op: s.VMOpCode.SHL }), this
        }

        rightShift() {
          return this.emit({ op: s.VMOpCode.SHR }), this
        }

        unsignedRightShift() {
          return this.emit({ op: s.VMOpCode.USHR }), this
        }

        return() {
          return this.emit({ op: s.VMOpCode.RETURN }), this
        }

        throw() {
          return this.emit({ op: s.VMOpCode.THROW }), this
        }

        break() {
          const e = this.currentInstructionIndex();
          return this.emit({ op: s.VMOpCode.BREAK, target: 0 }), new l.VMJumpBuilder(this.context, e)
        }

        continue() {
          const e = this.currentInstructionIndex();
          return this.emit({ op: s.VMOpCode.CONTINUE, target: 0 }), new l.VMJumpBuilder(this.context, e)
        }

        tryStart(e, t, r) {
          return this.emit({ op: s.VMOpCode.TRY_START, catchIndex: e, finallyIndex: t, endIndex: r }), this
        }

        tryEnd() {
          return this.emit({ op: s.VMOpCode.TRY_END }), this
        }

        catchStart(e) {
          return this.emit({ op: s.VMOpCode.CATCH_START, arg: e }), this
        }

        finallyStart() {
          return this.emit({ op: s.VMOpCode.FINALLY_START }), this
        }

        finallyEnd() {
          return this.emit({ op: s.VMOpCode.FINALLY_END }), this
        }

        jump() {
          const e = this.currentInstructionIndex();
          return this.emit({ op: s.VMOpCode.JUMP, target: 0 }), new l.VMJumpBuilder(this.context, e)
        }

        jumpIfFalse() {
          const e = this.currentInstructionIndex();
          return this.emit({ op: s.VMOpCode.JUMP_IF_FALSE, target: 0 }), new l.VMJumpBuilder(this.context, e)
        }

        jumpIfTrue() {
          const e = this.currentInstructionIndex();
          return this.emit({ op: s.VMOpCode.JUMP_IF_TRUE, target: 0 }), new l.VMJumpBuilder(this.context, e)
        }

        newObject() {
          return this.emit({ op: s.VMOpCode.NEW_OBJECT }), this
        }

        objectSpread() {
          return this.emit({ op: s.VMOpCode.OBJECT_SPREAD }), this
        }

        newArray() {
          return this.emit({ op: s.VMOpCode.NEW_ARRAY }), this
        }

        arrayPush() {
          return this.emit({ op: s.VMOpCode.ARRAY_PUSH }), this
        }

        arraySpreadPush() {
          return this.emit({ op: s.VMOpCode.ARRAY_SPREAD_PUSH }), this
        }

        getProperty() {
          return this.emit({ op: s.VMOpCode.GET_PROP }), this
        }

        getPropertyByName(e) {
          return this.validateIndex(e, "property"), this.emit({ op: s.VMOpCode.GET_PROP, arg: e }), this
        }

        getProp(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.GET_PROP, arg: t }), this
        }

        setProperty(e) {
          return this.validateIndex(e, "property"), this.emit({ op: s.VMOpCode.SET_PROP, arg: e }), this
        }

        setProp(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.SET_PROP, arg: t }), this
        }

        deleteProperty() {
          return this.emit({ op: s.VMOpCode.DELETE_PROP }), this
        }

        getComputed() {
          return this.emit({ op: s.VMOpCode.GET_COMPUTED }), this
        }

        getComputedOptional() {
          return this.emit({ op: s.VMOpCode.GET_COMPUTED_OPTIONAL }), this
        }

        setComputed() {
          return this.emit({ op: s.VMOpCode.SET_COMPUTED }), this
        }

        defineGetter(e) {
          return this.validateIndex(e, "property name"), this.emit({ op: s.VMOpCode.DEFINE_GETTER, arg: e }), this
        }

        defineSetter(e) {
          return this.validateIndex(e, "property name"), this.emit({ op: s.VMOpCode.DEFINE_SETTER, arg: e }), this
        }

        call(e) {
          return this.emit({ op: s.VMOpCode.CALL, arg: e }), this
        }

        callNew(e) {
          return this.emit({ op: s.VMOpCode.NEW, arg: e }), this
        }

        createFunction(e) {
          const t = this.context.constantPool.add(e);
          return this.emit({ op: s.VMOpCode.NEW_FUNC, arg: t }), this
        }

        callMethod(e) {
          return this.emit({ op: s.VMOpCode.CALL_METHOD, arg: e }), this
        }

        newFunc() {
          return this.emit({ op: s.VMOpCode.NEW_FUNC }), this
        }

        arguments() {
          return this.emit({ op: s.VMOpCode.ARGUMENTS }), this
        }

        typeof() {
          return this.emit({ op: s.VMOpCode.TYPEOF }), this
        }

        typeofGlobal(e) {
          return this.validateIndex(e, "global name"), this.emit({ op: s.VMOpCode.TYPEOF_GLOBAL, arg: e }), this
        }

        instanceof() {
          return this.emit({ op: s.VMOpCode.INSTANCEOF }), this
        }

        in() {
          return this.emit({ op: s.VMOpCode.IN }), this
        }

        this() {
          return this.emit({ op: s.VMOpCode.THIS }), this
        }

        newTarget() {
          return this.emit({ op: s.VMOpCode.NEW_TARGET }), this
        }

        spread() {
          return this.emit({ op: s.VMOpCode.SPREAD }), this
        }

        await() {
          return this.emit({ op: s.VMOpCode.AWAIT }), this
        }

        yield() {
          return this.emit({ op: s.VMOpCode.YIELD }), this
        }

        yieldStar() {
          return this.emit({ op: s.VMOpCode.YIELD_STAR }), this
        }

        getIterator() {
          return this.emit({ op: s.VMOpCode.GET_ITERATOR }), this
        }

        iteratorNext() {
          return this.emit({ op: s.VMOpCode.ITERATOR_NEXT }), this
        }

        iteratorDone() {
          return this.emit({ op: s.VMOpCode.ITERATOR_DONE }), this
        }

        newRegex(e, t) {
          const r = `${e}|||${t}`, o = this.context.constantPool.add(r);
          return this.emit({ op: s.VMOpCode.NEW_REGEX, arg: o }), this
        }

        createSymbol(e) {
          return this.emit({ op: s.VMOpCode.SYMBOL, arg: null != e ? e : -1 }), this
        }

        symbolFor(e) {
          return this.emit({ op: s.VMOpCode.SYMBOL_FOR, arg: e }), this
        }

        symbolKeyFor() {
          return this.emit({ op: s.VMOpCode.SYMBOL_KEY_FOR, arg: 0 }), this
        }

        throwError(e, t) {
          const r = this.context.constantPool.add(e);
          return this.loadGlobal(r), this.loadConst(t), this.loadConst(1), this.callNew(1), this.throw(), this
        }

        emitUndefinedCheck() {
          return this.dup(), this.pushUndefined(), this.strictEqual(), this.jumpIfFalse()
        }

        emitStaticMethodCall(e, t, r) {
          const o = this.context.constantPool.add(e), n = this.context.constantPool.add(t);
          return this.loadGlobal(o), this.dup(), this.getPropertyByName(n), this.loadConst(r), this.callMethod(r), this
        }

        currentInstructionIndex() {
          return this.context.instructions.length
        }

        emitRaw(e) {
          return this.emit(e), this
        }

        emit(e) {
          this.context.instructions.push(e)
        }

        validateIndex(e, t) {
          if (!Number.isInteger(e) || e < 0) throw new Error(`Invalid ${t} index: ${e}`)
        }
      };
      t.VMInstructionBuilder = d, t.VMInstructionBuilder = d = n([(0, a.injectable)(), i("design:paramtypes", ["function" == typeof (o = void 0 !== c.ICompilationContext && c.ICompilationContext) ? o : Object])], d)
    }, 4057: function (e, t, r) {
      var o = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IsAllowedForObfuscationTargets = function (e, t) {
        return (r, o) => {
          (0, n.registerDecorator)({
            propertyName: o,
            constraints: [e],
            name: "IsAllowedForObfuscationTargets",
            options: t,
            target: r.constructor,
            validator: {
              validate(t, r) {
                const n = r.object, a = s.DEFAULT_PRESET[o];
                return (0, i.default)(t, a) || e.includes(n.target)
              },
              defaultMessage: t => `This option allowed only for obfuscation targets: ${e.join(`${a.StringSeparator.Comma} `)}`
            }
          })
        }
      };
      const n = r(97403), i = o(r(77078)), a = r(52849), s = r(45887)
    }, 4320: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getEnvironmentOpcodeTemplates = function () {
        return "\n                        // Environment Operations\n                        case opMap[210]: { // CREATE_ENV\n                            // Create a new child environment\n                            // Stack top should have parent environment\n                            let parentEnv = stack.pop();\n                            let newEnv = {\n                                vars: {},\n                                constVars: {},  // Track const variables for immutability\n                                tdzVars: {},    // BUG FIX #544: Track variables in Temporal Dead Zone\n                                parent: parentEnv\n                            };\n                            // Make this the current environment\n                            env = newEnv;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[211]: { // LOAD_FROM_ENV\n                            // Load variable from environment chain\n                            let varName = constants[arg];\n                            let currentEnv = env;\n                            let value;\n                            let found = false;\n\n                            // BUG FIX #544, #370: Check TDZ and vars together at each level\n                            // Walk the chain checking both tdzVars and vars at each environment.\n                            // If we find the variable in tdzVars BEFORE we find it in vars, throw TDZ error.\n                            // If we find it in vars first (or same level), the variable is initialized.\n                            // This correctly handles shadowed variables where inner let shadows outer TDZ.\n                            while (currentEnv) {\n                                // Check if variable is in TDZ at this level\n                                if (currentEnv.tdzVars && varName in currentEnv.tdzVars) {\n                                    throw new ReferenceError(\"Cannot access '\" + varName + \"' before initialization\");\n                                }\n                                // Check if variable exists at this level\n                                if (varName in currentEnv.vars) {\n                                    value = currentEnv.vars[varName];\n                                    found = true;\n                                    break;\n                                }\n                                currentEnv = currentEnv.parent;\n                            }\n\n\n                            if (!found) {\n                                // Variable not in environment chain, fall back to global scope\n                                // Check in order:\n                                // 1. VM globals (__vmGlobals__)\n                                // 2. Node.js module-scoped variables (module, exports, require, __filename, __dirname)\n                                // 3. Actual global object (for browser/Node.js built-ins)\n                                if (varName in {vmGlobalsName}) {\n                                    value = {vmGlobalsName}[varName];\n                                } else if ({vmModuleVarsName} && varName in {vmModuleVarsName}) {\n                                    value = {vmModuleVarsName}[varName];\n                                } else {\n                                    value = (typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : global))[varName];\n                                }\n                            }\n                            stack.push(value);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[212]: { // STORE_TO_ENV\n                            // Store variable in environment chain (or create in current env if not found)\n                            let varName = constants[arg];\n                            let value = stack.pop(); // Pop the value\n\n                            let currentEnv = env;\n                            let found = false;\n\n                            // Search up the environment chain\n                            // Use 'in' operator instead of hasOwnProperty for better performance\n                            while (currentEnv) {\n                                if (varName in currentEnv.vars) {\n                                    // Check if this is a const variable\n                                    if (currentEnv.constVars && varName in currentEnv.constVars) {\n                                        throw new TypeError('Assignment to constant variable.');\n                                    }\n                                    // BUG FIX #564: Remove from TDZ when initialized\n                                    if (currentEnv.tdzVars && varName in currentEnv.tdzVars) {\n                                        delete currentEnv.tdzVars[varName];\n                                    }\n                                    currentEnv.vars[varName] = value;\n                                    found = true;\n                                    break;\n                                }\n                                currentEnv = currentEnv.parent;\n                            }\n\n                            // If not found in chain, create in current environment\n                            if (!found) {\n                                // BUG FIX #564: Remove from TDZ when initialized\n                                if (env.tdzVars && varName in env.tdzVars) {\n                                    delete env.tdzVars[varName];\n                                }\n                                env.vars[varName] = value;\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[213]: { // GET_ENV\n                            // Push current environment onto stack\n                            stack.push(env);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[214]: { // RESTORE_PARENT_ENV\n                            // Restore parent environment\n                            if (env && env.parent) {\n                                env = env.parent;\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[215]: { // STORE_TO_CURRENT_ENV\n                            // Store variable in CURRENT environment only (no parent chain search)\n                            // Used for per-iteration loop bindings to shadow parent variables\n                            let storeName = constants[arg];\n                            let storeValue = stack.pop();\n\n                            // BUG FIX #564, #370: Remove from TDZ when initialized\n                            // Clear both the scoped name (e.g., 'x$$2') and the base name ('x')\n                            // This handles shadowed variables where DECLARE_TDZ uses the raw name\n                            // but STORE uses the scoped name\n                            if (env.tdzVars) {\n                                if (storeName in env.tdzVars) {\n                                    delete env.tdzVars[storeName];\n                                }\n                                // Also clear the base name if this is a scoped name\n                                let baseName = storeName.split('$$')[0];\n                                if (baseName !== storeName && baseName in env.tdzVars) {\n                                    delete env.tdzVars[baseName];\n                                }\n                            }\n                            env.vars[storeName] = storeValue;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[216]: { // STORE_TO_ENV_CONST\n                            // Store const variable in environment chain (mark as immutable)\n                            // This opcode is used for DECLARING const variables in the environment\n                            let constName = constants[arg];\n                            let constValue = stack.pop();\n                            let constEnv = env;\n                            let constFound = false;\n\n                            // Search up the environment chain\n                            // Use 'in' operator instead of hasOwnProperty for better performance\n                            while (constEnv) {\n                                if (constName in constEnv.vars) {\n                                    // Found variable in environment chain\n                                    // Check if it's already const - if so in parent, we're shadowing (allowed)\n                                    if (constEnv.constVars && constName in constEnv.constVars) {\n                                        // It's const in parent or current - don't update parent const (shadowing)\n                                        // Create new variable in current environment instead\n                                        break;\n                                    }\n                                    // Variable exists but not const - update it and mark as const\n                                    constEnv.vars[constName] = constValue;\n                                    // Mark as const\n                                    if (!constEnv.constVars) {\n                                        constEnv.constVars = {};\n                                    }\n                                    constEnv.constVars[constName] = true;\n                                    constFound = true;\n                                    break;\n                                }\n                                constEnv = constEnv.parent;\n                            }\n\n                            // If not found in chain (or found const in parent), create in current environment and mark as const\n                            if (!constFound) {\n                                // BUG FIX #544: Remove from TDZ when initialized\n                                if (env.tdzVars && constName in env.tdzVars) {\n                                    delete env.tdzVars[constName];\n                                }\n                                env.vars[constName] = constValue;\n                                if (!env.constVars) {\n                                    env.constVars = {};\n                                }\n                                env.constVars[constName] = true;\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[217]: { // STORE_TO_CURRENT_ENV_CONST\n                            // Store const variable in CURRENT environment only (no parent chain search)\n                            // Used for per-iteration loop bindings with const\n                            let currentConstName = constants[arg];\n                            let currentConstValue = stack.pop();\n\n                            // Check if already exists as const in current environment\n                            if (env.constVars && env.constVars[currentConstName]) {\n                                throw new TypeError('Assignment to constant variable.');\n                            }\n\n                            // BUG FIX #544, #370: Remove from TDZ when initialized\n                            // Clear both the scoped name (e.g., 'x$$2') and the base name ('x')\n                            if (env.tdzVars) {\n                                if (currentConstName in env.tdzVars) {\n                                    delete env.tdzVars[currentConstName];\n                                }\n                                let currentConstBaseName = currentConstName.split('$$')[0];\n                                if (currentConstBaseName !== currentConstName && currentConstBaseName in env.tdzVars) {\n                                    delete env.tdzVars[currentConstBaseName];\n                                }\n                            }\n\n                            // Store in current environment and mark as const\n                            env.vars[currentConstName] = currentConstValue;\n                            if (!env.constVars) {\n                                env.constVars = {};\n                            }\n                            env.constVars[currentConstName] = true;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[218]: { // DECLARE_TDZ\n                            // BUG FIX #544: Declare variable in Temporal Dead Zone\n                            // This is emitted before const/let declarations to mark them as in TDZ\n                            let tdzVarName = constants[arg];\n                            if (!env.tdzVars) {\n                                env.tdzVars = {};\n                            }\n                            env.tdzVars[tdzVarName] = true;\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 4592: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeMetadata = void 0;

      class r {
        static set(e, t) {
          var r;
          e.metadata = Object.assign(null !== (r = e.metadata) && void 0 !== r ? r : {}, t)
        }

        static get(e, t) {
          return void 0 !== e.metadata ? e.metadata[t] : void 0
        }

        static isEvalHostNode(e) {
          return !0 === r.get(e, "evalHostNode")
        }

        static isForceTransformNode(e) {
          return !0 === r.get(e, "forceTransformNode")
        }

        static isIgnoredNode(e) {
          return !0 === r.get(e, "ignoredNode")
        }

        static isPropertyKeyToRenameNode(e) {
          return !0 === r.get(e, "propertyKeyToRenameNode")
        }

        static isStringArrayCallLiteralNode(e) {
          return !0 === r.get(e, "stringArrayCallLiteralNode")
        }
      }

      t.NodeMetadata = r
    }, 4730: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 5297: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 5605: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BooleanLiteralTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(13245), m = r(27391),
        g = r(33056), h = r(93571);
      let y = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && m.NodeGuards.isLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if ("boolean" != typeof e.value) return e;
          const r = e.value ? this.getTrueUnaryExpressionNode() : this.getFalseUnaryExpressionNode();
          return g.NodeUtils.parentizeNode(r, t), r
        }

        getTrueUnaryExpressionNode() {
          return h.NodeFactory.unaryExpressionNode("!", this.getFalseUnaryExpressionNode())
        }

        getFalseUnaryExpressionNode() {
          return h.NodeFactory.unaryExpressionNode("!", h.NodeFactory.arrayExpressionNode())
        }
      };
      t.BooleanLiteralTransformer = y, t.BooleanLiteralTransformer = y = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], y)
    }, 6014: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionCodeHelperGroup = void 0;
      const p = r(45337), u = r(31391), f = r(58544), m = r(18741), g = r(76393), h = r(31142), y = r(50164),
        S = r(51875), N = r(75716), b = r(26455), _ = r(47250), v = r(27391), I = r(75096);
      let O = class extends b.AbstractCustomCodeHelperGroup {
        constructor(e, t, r, o) {
          super(t, r, o), this.customCodeHelperFactory = e
        }

        appendOnPreparingStage(e, t) {
          var r;
          if (!this.options.debugProtection) return;
          const o = this.getRandomCallsGraphIndex(t.length),
            n = t.length ? _.NodeAppender.getOptimalBlockScope(t, o) : e,
            i = t.length ? _.NodeAppender.getOptimalBlockScope(t, o, 1) : e,
            a = null !== (r = I.NodeLexicalScopeUtils.getLexicalScope(n)) && void 0 !== r ? r : null,
            s = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext(),
            c = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext();
          this.appendCustomNodeIfExist(S.CustomCodeHelper.DebugProtectionFunctionCall, e => {
            e.initialize(s, c), _.NodeAppender.prepend(n, e.getNode())
          }), this.appendCustomNodeIfExist(S.CustomCodeHelper.CallsControllerFunction, e => {
            e.initialize(N.NodeTransformationStage.Preparing, c), _.NodeAppender.prepend(i, e.getNode())
          }), this.appendCustomNodeIfExist(S.CustomCodeHelper.DebugProtectionFunction, t => {
            t.initialize(s), _.NodeAppender.append(e, t.getNode())
          }), this.appendCustomNodeIfExist(S.CustomCodeHelper.DebugProtectionFunctionInterval, t => {
            const r = v.NodeGuards.isSwitchCaseNode(e) ? e.consequent.length : e.body.length,
              o = this.randomGenerator.getRandomInteger(0, r);
            t.initialize(s, this.options.debugProtectionInterval), _.NodeAppender.insertAtIndex(e, t.getNode(), o)
          })
        }

        initialize() {
          if (this.customCodeHelpers = new Map, !this.options.debugProtection) return;
          const e = this.customCodeHelperFactory(S.CustomCodeHelper.DebugProtectionFunction),
            t = this.customCodeHelperFactory(S.CustomCodeHelper.DebugProtectionFunctionCall),
            r = this.customCodeHelperFactory(S.CustomCodeHelper.DebugProtectionFunctionInterval),
            o = this.customCodeHelperFactory(S.CustomCodeHelper.CallsControllerFunction);
          this.customCodeHelpers.set(S.CustomCodeHelper.DebugProtectionFunction, e), this.customCodeHelpers.set(S.CustomCodeHelper.DebugProtectionFunctionCall, t), this.options.debugProtectionInterval && this.customCodeHelpers.set(S.CustomCodeHelper.DebugProtectionFunctionInterval, r), this.customCodeHelpers.set(S.CustomCodeHelper.CallsControllerFunction, o)
        }
      };
      t.DebugProtectionCodeHelperGroup = O, c([(0, y.initializable)(), l("design:type", "function" == typeof (s = "undefined" != typeof Map && Map) ? s : Object)], O.prototype, "customCodeHelpers", void 0), t.DebugProtectionCodeHelperGroup = O = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__ICustomCodeHelper)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TCustomCodeHelperFactory && f.TCustomCodeHelperFactory) ? o : Object, "function" == typeof (n = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== g.IOptions && g.IOptions) ? a : Object])], O)
    }, 6057: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.finalizingTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(63312), s = r(31514);
      t.finalizingTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(a.DirectivePlacementTransformer).whenTargetNamed(i.NodeTransformer.DirectivePlacementTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(s.EscapeSequenceTransformer).whenTargetNamed(i.NodeTransformer.EscapeSequenceTransformer)
      })
    }, 6062: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayIndexNode = void 0, function (e) {
        e.StringArrayHexadecimalNumberIndexNode = "StringArrayHexadecimalNumberIndexNode", e.StringArrayHexadecimalNumericStringIndexNode = "StringArrayHexadecimalNumericStringIndexNode"
      }(r || (t.StringArrayIndexNode = r = {}))
    }, 6088: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.alphabetStringUppercase = void 0;
      const o = r(55194);
      t.alphabetStringUppercase = o.alphabetString.toUpperCase()
    }, 6335: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NO_ADDITIONAL_NODES_PRESET = void 0;
      const o = r(76436), n = r(98151), i = r(68289), a = r(64858), s = r(57088), c = r(20965), l = r(48344),
        d = r(51110), p = r(84133);
      t.NO_ADDITIONAL_NODES_PRESET = Object.freeze({
        compact: !0,
        controlFlowFlattening: !1,
        controlFlowFlatteningThreshold: 0,
        deadCodeInjection: !1,
        deadCodeInjectionThreshold: 0,
        debugProtection: !1,
        debugProtectionInterval: 0,
        disableConsoleOutput: !1,
        domainLock: [],
        domainLockRedirectUrl: "about:blank",
        exclude: [],
        forceTransformStrings: [],
        identifierNamesCache: null,
        identifierNamesGenerator: o.IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,
        identifiersPrefix: "",
        identifiersDictionary: [],
        ignoreImports: !1,
        inputFileName: "",
        log: !1,
        numbersToExpressions: !1,
        renameGlobals: !1,
        renameProperties: !1,
        renamePropertiesMode: i.RenamePropertiesMode.Safe,
        reservedNames: [],
        reservedStrings: [],
        stringArrayRotate: !1,
        seed: 0,
        selfDefending: !1,
        stringArrayShuffle: !1,
        simplify: !1,
        sourceMap: !1,
        sourceMapBaseUrl: "",
        sourceMapFileName: "",
        sourceMapMode: a.SourceMapMode.Separate,
        sourceMapSourcesMode: s.SourceMapSourcesMode.SourcesContent,
        splitStrings: !1,
        splitStringsChunkLength: 0,
        stringArray: !1,
        stringArrayCallsTransform: !1,
        stringArrayCallsTransformThreshold: 0,
        stringArrayEncoding: [c.StringArrayEncoding.None],
        stringArrayIndexesType: [d.StringArrayIndexesType.HexadecimalNumber],
        stringArrayIndexShift: !1,
        stringArrayWrappersChainedCalls: !1,
        stringArrayWrappersCount: 0,
        stringArrayWrappersParametersMaxCount: 2,
        stringArrayWrappersType: l.StringArrayWrappersType.Variable,
        stringArrayThreshold: 0,
        target: n.ObfuscationTarget.Browser,
        transformObjectKeys: !1,
        unicodeEscapeSequence: !1,
        vmObfuscation: !1,
        vmObfuscationThreshold: 0,
        vmTargetFunctions: [],
        vmExcludeFunctions: [],
        vmOpcodeShuffle: !1,
        vmBytecodeEncoding: !1,
        vmBytecodeArrayEncoding: !1,
        vmJumpsEncoding: !1,
        vmDecoyOpcodes: !1,
        vmDeadCodeInjection: !1,
        vmSplitDispatcher: !1,
        vmMacroOps: !1,
        vmDebugProtection: !1,
        vmRuntimeOpcodeDerivation: !1,
        vmStatefulOpcodes: !1,
        vmStackEncoding: !1,
        vmRandomizeKeys: !1,
        vmIndirectDispatch: !1,
        vmBytecodeFormat: p.VMBytecodeFormat.Json
      })
    }, 6518: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CallExpressionControlFlowReplacer = void 0;
      const p = r(45337), u = r(31391), f = r(46300), m = r(18741), g = r(76393), h = r(31142), y = r(62059),
        S = r(47074), N = r(27391);
      let b = o = class extends S.AbstractControlFlowReplacer {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        replace(e, t, r) {
          const n = e.callee;
          if (!N.NodeGuards.isIdentifierNode(n)) return e;
          const i = N.NodeGuards.isChainExpressionNode(t), a = e.arguments.length,
            s = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.CallExpressionFunctionNode), c = e.arguments;
          s.initialize(c, i);
          const l = this.insertCustomNodeToControlFlowStorage(s, r, a, o.usingExistingIdentifierChance);
          return this.getControlFlowStorageCallNode(r.getStorageId(), l, n, c)
        }

        getControlFlowStorageCallNode(e, t, r, o) {
          const n = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);
          n.initialize(e, t, r, o);
          const i = n.getNode()[0];
          if (!i || !N.NodeGuards.isExpressionStatementNode(i)) throw new Error("`controlFlowStorageCallCustomNode.getNode()[0]` should returns array with `ExpressionStatement` node");
          return i.expression
        }
      };
      t.CallExpressionControlFlowReplacer = b, b.usingExistingIdentifierChance = .5, t.CallExpressionControlFlowReplacer = b = o = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IControlFlowCustomNode)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (n = void 0 !== f.TControlFlowCustomNodeFactory && f.TControlFlowCustomNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? i : Object, "function" == typeof (a = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== g.IOptions && g.IOptions) ? s : Object])], b)
    }, 6587: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionVariableDeclarationHostNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(8053),
        y = r(93571), S = r(27391);
      let N = class extends h.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t) {
          this.lexicalScopeNode = e, this.properties = t
        }

        getNodeStructure() {
          const e = S.NodeGuards.isProgramNode(this.lexicalScopeNode) ? this.identifierNamesGenerator.generateForGlobalScope() : this.identifierNamesGenerator.generateForLexicalScope(this.lexicalScopeNode);
          return [y.NodeFactory.variableDeclarationNode([y.NodeFactory.variableDeclaratorNode(y.NodeFactory.identifierNode(e), y.NodeFactory.objectExpressionNode(this.properties))], "const")]
        }
      };
      t.ObjectExpressionVariableDeclarationHostNode = N, t.ObjectExpressionVariableDeclarationHostNode = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 6822: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ReservedStringObfuscatingGuard = void 0;
      const s = r(45337), c = r(76393), l = r(62467), d = r(31391), p = r(27391);
      let u = class {
        constructor(e) {
          this.options = e
        }

        check(e) {
          return this.options.reservedStrings.length && p.NodeGuards.isLiteralNode(e) && "string" == typeof e.value && this.isReservedString(e.value) ? l.ObfuscatingGuardResult.Ignore : l.ObfuscatingGuardResult.Transform
        }

        isReservedString(e) {
          return this.options.reservedStrings.some(t => null !== new RegExp(t, "g").exec(e))
        }
      };
      t.ReservedStringObfuscatingGuard = u, t.ReservedStringObfuscatingGuard = u = n([(0, s.injectable)(), a(0, (0, s.inject)(d.ServiceIdentifiers.IOptions)), i("design:paramtypes", ["function" == typeof (o = void 0 !== c.IOptions && c.IOptions) ? o : Object])], u)
    }, 6946: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 7154: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ExpressionStatementsMergeTransformer = void 0;
      const u = r(45337), f = r(31391), m = l(r(31659)), g = r(76393), h = r(31142), y = r(75716), S = r(13245),
        N = r(93571), b = r(27391), _ = r(43243), v = r(33056);
      let I = class extends S.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === y.NodeTransformationStage.Simplifying ? {
            leave: (e, t) => {
              if (t && b.NodeGuards.isExpressionStatementNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (!b.NodeGuards.isNodeWithStatements(t)) return e;
          if (!e.parentNode) return e;
          const r = _.NodeStatementUtils.getPreviousSiblingStatement(e);
          return r && b.NodeGuards.isExpressionStatementNode(r) ? (b.NodeGuards.isSequenceExpressionNode(r.expression) ? (r.expression.expressions.push(e.expression), v.NodeUtils.parentizeNode(e.expression, r.expression)) : (r.expression = N.NodeFactory.sequenceExpressionNode([r.expression, e.expression]), v.NodeUtils.parentizeAst(r.expression), v.NodeUtils.parentizeNode(r.expression, r)), m.VisitorOption.Remove) : e
        }
      };
      t.ExpressionStatementsMergeTransformer = I, t.ExpressionStatementsMergeTransformer = I = c([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (n = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== g.IOptions && g.IOptions) ? i : Object])], I)
    }, 7192: e => {
      e.exports = JSON.parse('["$&","$\'","$*","$+","$1","$2","$3","$4","$5","$6","$7","$8","$9","$_","$`","$input","-moz-animation","-moz-animation-delay","-moz-animation-direction","-moz-animation-duration","-moz-animation-fill-mode","-moz-animation-iteration-count","-moz-animation-name","-moz-animation-play-state","-moz-animation-timing-function","-moz-appearance","-moz-backface-visibility","-moz-border-end","-moz-border-end-color","-moz-border-end-style","-moz-border-end-width","-moz-border-image","-moz-border-start","-moz-border-start-color","-moz-border-start-style","-moz-border-start-width","-moz-box-align","-moz-box-direction","-moz-box-flex","-moz-box-ordinal-group","-moz-box-orient","-moz-box-pack","-moz-box-sizing","-moz-float-edge","-moz-font-feature-settings","-moz-font-language-override","-moz-force-broken-image-icon","-moz-hyphens","-moz-image-region","-moz-margin-end","-moz-margin-start","-moz-orient","-moz-osx-font-smoothing","-moz-outline-radius","-moz-outline-radius-bottomleft","-moz-outline-radius-bottomright","-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-padding-end","-moz-padding-start","-moz-perspective","-moz-perspective-origin","-moz-tab-size","-moz-text-size-adjust","-moz-transform","-moz-transform-origin","-moz-transform-style","-moz-transition","-moz-transition-delay","-moz-transition-duration","-moz-transition-property","-moz-transition-timing-function","-moz-user-focus","-moz-user-input","-moz-user-modify","-moz-user-select","-moz-window-dragging","-webkit-align-content","-webkit-align-items","-webkit-align-self","-webkit-animation","-webkit-animation-delay","-webkit-animation-direction","-webkit-animation-duration","-webkit-animation-fill-mode","-webkit-animation-iteration-count","-webkit-animation-name","-webkit-animation-play-state","-webkit-animation-timing-function","-webkit-appearance","-webkit-backface-visibility","-webkit-background-clip","-webkit-background-origin","-webkit-background-size","-webkit-border-bottom-left-radius","-webkit-border-bottom-right-radius","-webkit-border-image","-webkit-border-radius","-webkit-border-top-left-radius","-webkit-border-top-right-radius","-webkit-box-align","-webkit-box-direction","-webkit-box-flex","-webkit-box-ordinal-group","-webkit-box-orient","-webkit-box-pack","-webkit-box-shadow","-webkit-box-sizing","-webkit-filter","-webkit-flex","-webkit-flex-basis","-webkit-flex-direction","-webkit-flex-flow","-webkit-flex-grow","-webkit-flex-shrink","-webkit-flex-wrap","-webkit-justify-content","-webkit-line-clamp","-webkit-mask","-webkit-mask-clip","-webkit-mask-composite","-webkit-mask-image","-webkit-mask-origin","-webkit-mask-position","-webkit-mask-position-x","-webkit-mask-position-y","-webkit-mask-repeat","-webkit-mask-size","-webkit-order","-webkit-perspective","-webkit-perspective-origin","-webkit-text-fill-color","-webkit-text-size-adjust","-webkit-text-stroke","-webkit-text-stroke-color","-webkit-text-stroke-width","-webkit-transform","-webkit-transform-origin","-webkit-transform-style","-webkit-transition","-webkit-transition-delay","-webkit-transition-duration","-webkit-transition-property","-webkit-transition-timing-function","-webkit-user-select","0","1","10","11","12","13","14","15","16","17","18","19","2","20","3","4","5","6","7","8","9","@@iterator","ABORT_ERR","ACTIVE","ACTIVE_ATTRIBUTES","ACTIVE_TEXTURE","ACTIVE_UNIFORMS","ACTIVE_UNIFORM_BLOCKS","ADDITION","ALIASED_LINE_WIDTH_RANGE","ALIASED_POINT_SIZE_RANGE","ALLOW_KEYBOARD_INPUT","ALLPASS","ALPHA","ALPHA_BITS","ALREADY_SIGNALED","ALT_MASK","ALWAYS","ANY_SAMPLES_PASSED","ANY_SAMPLES_PASSED_CONSERVATIVE","ANY_TYPE","ANY_UNORDERED_NODE_TYPE","ARRAY_BUFFER","ARRAY_BUFFER_BINDING","ATTACHED_SHADERS","ATTRIBUTE_NODE","AT_TARGET","AbortController","AbortSignal","AbsoluteOrientationSensor","AbstractRange","Accelerometer","AddSearchProvider","AggregateError","AnalyserNode","Animation","AnimationEffect","AnimationEvent","AnimationPlaybackEvent","AnimationTimeline","AnonXMLHttpRequest","Any","ApplicationCache","ApplicationCacheErrorEvent","Array","ArrayBuffer","ArrayType","Atomics","Attr","Audio","AudioBuffer","AudioBufferSourceNode","AudioContext","AudioDestinationNode","AudioListener","AudioNode","AudioParam","AudioParamMap","AudioProcessingEvent","AudioScheduledSourceNode","AudioStreamTrack","AudioWorklet","AudioWorkletNode","AuthenticatorAssertionResponse","AuthenticatorAttestationResponse","AuthenticatorResponse","AutocompleteErrorEvent","BACK","BAD_BOUNDARYPOINTS_ERR","BAD_REQUEST","BANDPASS","BLEND","BLEND_COLOR","BLEND_DST_ALPHA","BLEND_DST_RGB","BLEND_EQUATION","BLEND_EQUATION_ALPHA","BLEND_EQUATION_RGB","BLEND_SRC_ALPHA","BLEND_SRC_RGB","BLUE_BITS","BLUR","BOOL","BOOLEAN_TYPE","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","BOTH","BROWSER_DEFAULT_WEBGL","BUBBLING_PHASE","BUFFER_SIZE","BUFFER_USAGE","BYTE","BYTES_PER_ELEMENT","BackgroundFetchManager","BackgroundFetchRecord","BackgroundFetchRegistration","BarProp","BarcodeDetector","BaseAudioContext","BaseHref","BatteryManager","BeforeInstallPromptEvent","BeforeLoadEvent","BeforeUnloadEvent","BigInt","BigInt64Array","BigUint64Array","BiquadFilterNode","Blob","BlobEvent","Bluetooth","BluetoothCharacteristicProperties","BluetoothDevice","BluetoothRemoteGATTCharacteristic","BluetoothRemoteGATTDescriptor","BluetoothRemoteGATTServer","BluetoothRemoteGATTService","BluetoothUUID","Boolean","BroadcastChannel","ByteLengthQueuingStrategy","CAPTURING_PHASE","CCW","CDATASection","CDATA_SECTION_NODE","CHANGE","CHARSET_RULE","CHECKING","CLAMP_TO_EDGE","CLICK","CLOSED","CLOSING","COLOR","COLOR_ATTACHMENT0","COLOR_ATTACHMENT1","COLOR_ATTACHMENT10","COLOR_ATTACHMENT11","COLOR_ATTACHMENT12","COLOR_ATTACHMENT13","COLOR_ATTACHMENT14","COLOR_ATTACHMENT15","COLOR_ATTACHMENT2","COLOR_ATTACHMENT3","COLOR_ATTACHMENT4","COLOR_ATTACHMENT5","COLOR_ATTACHMENT6","COLOR_ATTACHMENT7","COLOR_ATTACHMENT8","COLOR_ATTACHMENT9","COLOR_BUFFER_BIT","COLOR_CLEAR_VALUE","COLOR_WRITEMASK","COMMENT_NODE","COMPARE_REF_TO_TEXTURE","COMPILE_STATUS","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_TEXTURE_FORMATS","CONDITION_SATISFIED","CONFIGURATION_UNSUPPORTED","CONNECTING","CONSTANT_ALPHA","CONSTANT_COLOR","CONSTRAINT_ERR","CONTEXT_LOST_WEBGL","CONTROL_MASK","COPY_READ_BUFFER","COPY_READ_BUFFER_BINDING","COPY_WRITE_BUFFER","COPY_WRITE_BUFFER_BINDING","COUNTER_STYLE_RULE","CSS","CSS2Properties","CSSAnimation","CSSCharsetRule","CSSConditionRule","CSSCounterStyleRule","CSSFontFaceRule","CSSFontFeatureValuesRule","CSSGroupingRule","CSSImageValue","CSSImportRule","CSSKeyframeRule","CSSKeyframesRule","CSSKeywordValue","CSSMathInvert","CSSMathMax","CSSMathMin","CSSMathNegate","CSSMathProduct","CSSMathSum","CSSMathValue","CSSMatrixComponent","CSSMediaRule","CSSMozDocumentRule","CSSNameSpaceRule","CSSNamespaceRule","CSSNumericArray","CSSNumericValue","CSSPageRule","CSSPerspective","CSSPositionValue","CSSPrimitiveValue","CSSRotate","CSSRule","CSSRuleList","CSSScale","CSSSkew","CSSSkewX","CSSSkewY","CSSStyleDeclaration","CSSStyleRule","CSSStyleSheet","CSSStyleValue","CSSSupportsRule","CSSTransformComponent","CSSTransformValue","CSSTransition","CSSTranslate","CSSUnitValue","CSSUnknownRule","CSSUnparsedValue","CSSValue","CSSValueList","CSSVariableReferenceValue","CSSVariablesDeclaration","CSSVariablesRule","CSSViewportRule","CSS_ATTR","CSS_CM","CSS_COUNTER","CSS_CUSTOM","CSS_DEG","CSS_DIMENSION","CSS_EMS","CSS_EXS","CSS_FILTER_BLUR","CSS_FILTER_BRIGHTNESS","CSS_FILTER_CONTRAST","CSS_FILTER_CUSTOM","CSS_FILTER_DROP_SHADOW","CSS_FILTER_GRAYSCALE","CSS_FILTER_HUE_ROTATE","CSS_FILTER_INVERT","CSS_FILTER_OPACITY","CSS_FILTER_REFERENCE","CSS_FILTER_SATURATE","CSS_FILTER_SEPIA","CSS_GRAD","CSS_HZ","CSS_IDENT","CSS_IN","CSS_INHERIT","CSS_KHZ","CSS_MATRIX","CSS_MATRIX3D","CSS_MM","CSS_MS","CSS_NUMBER","CSS_PC","CSS_PERCENTAGE","CSS_PERSPECTIVE","CSS_PRIMITIVE_VALUE","CSS_PT","CSS_PX","CSS_RAD","CSS_RECT","CSS_RGBCOLOR","CSS_ROTATE","CSS_ROTATE3D","CSS_ROTATEX","CSS_ROTATEY","CSS_ROTATEZ","CSS_S","CSS_SCALE","CSS_SCALE3D","CSS_SCALEX","CSS_SCALEY","CSS_SCALEZ","CSS_SKEW","CSS_SKEWX","CSS_SKEWY","CSS_STRING","CSS_TRANSLATE","CSS_TRANSLATE3D","CSS_TRANSLATEX","CSS_TRANSLATEY","CSS_TRANSLATEZ","CSS_UNKNOWN","CSS_URI","CSS_VALUE_LIST","CSS_VH","CSS_VMAX","CSS_VMIN","CSS_VW","CULL_FACE","CULL_FACE_MODE","CURRENT_PROGRAM","CURRENT_QUERY","CURRENT_VERTEX_ATTRIB","CUSTOM","CW","Cache","CacheStorage","CanvasCaptureMediaStream","CanvasCaptureMediaStreamTrack","CanvasGradient","CanvasPattern","CanvasRenderingContext2D","CaretPosition","ChannelMergerNode","ChannelSplitterNode","CharacterData","ClientRect","ClientRectList","Clipboard","ClipboardEvent","ClipboardItem","CloseEvent","Collator","CommandEvent","Comment","CompileError","CompositionEvent","CompressionStream","Console","ConstantSourceNode","Controllers","ConvolverNode","CountQueuingStrategy","Counter","Credential","CredentialsContainer","Crypto","CryptoKey","CustomElementRegistry","CustomEvent","DATABASE_ERR","DATA_CLONE_ERR","DATA_ERR","DBLCLICK","DECR","DECR_WRAP","DELETE_STATUS","DEPTH","DEPTH24_STENCIL8","DEPTH32F_STENCIL8","DEPTH_ATTACHMENT","DEPTH_BITS","DEPTH_BUFFER_BIT","DEPTH_CLEAR_VALUE","DEPTH_COMPONENT","DEPTH_COMPONENT16","DEPTH_COMPONENT24","DEPTH_COMPONENT32F","DEPTH_FUNC","DEPTH_RANGE","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","DEPTH_TEST","DEPTH_WRITEMASK","DEVICE_INELIGIBLE","DIRECTION_DOWN","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DISABLED","DISPATCH_REQUEST_ERR","DITHER","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_TYPE_NODE","DOMCursor","DOMError","DOMException","DOMImplementation","DOMImplementationLS","DOMMatrix","DOMMatrixReadOnly","DOMParser","DOMPoint","DOMPointReadOnly","DOMQuad","DOMRect","DOMRectList","DOMRectReadOnly","DOMRequest","DOMSTRING_SIZE_ERR","DOMSettableTokenList","DOMStringList","DOMStringMap","DOMTokenList","DOMTransactionEvent","DOM_DELTA_LINE","DOM_DELTA_PAGE","DOM_DELTA_PIXEL","DOM_INPUT_METHOD_DROP","DOM_INPUT_METHOD_HANDWRITING","DOM_INPUT_METHOD_IME","DOM_INPUT_METHOD_KEYBOARD","DOM_INPUT_METHOD_MULTIMODAL","DOM_INPUT_METHOD_OPTION","DOM_INPUT_METHOD_PASTE","DOM_INPUT_METHOD_SCRIPT","DOM_INPUT_METHOD_UNKNOWN","DOM_INPUT_METHOD_VOICE","DOM_KEY_LOCATION_JOYSTICK","DOM_KEY_LOCATION_LEFT","DOM_KEY_LOCATION_MOBILE","DOM_KEY_LOCATION_NUMPAD","DOM_KEY_LOCATION_RIGHT","DOM_KEY_LOCATION_STANDARD","DOM_VK_0","DOM_VK_1","DOM_VK_2","DOM_VK_3","DOM_VK_4","DOM_VK_5","DOM_VK_6","DOM_VK_7","DOM_VK_8","DOM_VK_9","DOM_VK_A","DOM_VK_ACCEPT","DOM_VK_ADD","DOM_VK_ALT","DOM_VK_ALTGR","DOM_VK_AMPERSAND","DOM_VK_ASTERISK","DOM_VK_AT","DOM_VK_ATTN","DOM_VK_B","DOM_VK_BACKSPACE","DOM_VK_BACK_QUOTE","DOM_VK_BACK_SLASH","DOM_VK_BACK_SPACE","DOM_VK_C","DOM_VK_CANCEL","DOM_VK_CAPS_LOCK","DOM_VK_CIRCUMFLEX","DOM_VK_CLEAR","DOM_VK_CLOSE_BRACKET","DOM_VK_CLOSE_CURLY_BRACKET","DOM_VK_CLOSE_PAREN","DOM_VK_COLON","DOM_VK_COMMA","DOM_VK_CONTEXT_MENU","DOM_VK_CONTROL","DOM_VK_CONVERT","DOM_VK_CRSEL","DOM_VK_CTRL","DOM_VK_D","DOM_VK_DECIMAL","DOM_VK_DELETE","DOM_VK_DIVIDE","DOM_VK_DOLLAR","DOM_VK_DOUBLE_QUOTE","DOM_VK_DOWN","DOM_VK_E","DOM_VK_EISU","DOM_VK_END","DOM_VK_ENTER","DOM_VK_EQUALS","DOM_VK_EREOF","DOM_VK_ESCAPE","DOM_VK_EXCLAMATION","DOM_VK_EXECUTE","DOM_VK_EXSEL","DOM_VK_F","DOM_VK_F1","DOM_VK_F10","DOM_VK_F11","DOM_VK_F12","DOM_VK_F13","DOM_VK_F14","DOM_VK_F15","DOM_VK_F16","DOM_VK_F17","DOM_VK_F18","DOM_VK_F19","DOM_VK_F2","DOM_VK_F20","DOM_VK_F21","DOM_VK_F22","DOM_VK_F23","DOM_VK_F24","DOM_VK_F25","DOM_VK_F26","DOM_VK_F27","DOM_VK_F28","DOM_VK_F29","DOM_VK_F3","DOM_VK_F30","DOM_VK_F31","DOM_VK_F32","DOM_VK_F33","DOM_VK_F34","DOM_VK_F35","DOM_VK_F36","DOM_VK_F4","DOM_VK_F5","DOM_VK_F6","DOM_VK_F7","DOM_VK_F8","DOM_VK_F9","DOM_VK_FINAL","DOM_VK_FRONT","DOM_VK_G","DOM_VK_GREATER_THAN","DOM_VK_H","DOM_VK_HANGUL","DOM_VK_HANJA","DOM_VK_HASH","DOM_VK_HELP","DOM_VK_HK_TOGGLE","DOM_VK_HOME","DOM_VK_HYPHEN_MINUS","DOM_VK_I","DOM_VK_INSERT","DOM_VK_J","DOM_VK_JUNJA","DOM_VK_K","DOM_VK_KANA","DOM_VK_KANJI","DOM_VK_L","DOM_VK_LEFT","DOM_VK_LEFT_TAB","DOM_VK_LESS_THAN","DOM_VK_M","DOM_VK_META","DOM_VK_MODECHANGE","DOM_VK_MULTIPLY","DOM_VK_N","DOM_VK_NONCONVERT","DOM_VK_NUMPAD0","DOM_VK_NUMPAD1","DOM_VK_NUMPAD2","DOM_VK_NUMPAD3","DOM_VK_NUMPAD4","DOM_VK_NUMPAD5","DOM_VK_NUMPAD6","DOM_VK_NUMPAD7","DOM_VK_NUMPAD8","DOM_VK_NUMPAD9","DOM_VK_NUM_LOCK","DOM_VK_O","DOM_VK_OEM_1","DOM_VK_OEM_102","DOM_VK_OEM_2","DOM_VK_OEM_3","DOM_VK_OEM_4","DOM_VK_OEM_5","DOM_VK_OEM_6","DOM_VK_OEM_7","DOM_VK_OEM_8","DOM_VK_OEM_COMMA","DOM_VK_OEM_MINUS","DOM_VK_OEM_PERIOD","DOM_VK_OEM_PLUS","DOM_VK_OPEN_BRACKET","DOM_VK_OPEN_CURLY_BRACKET","DOM_VK_OPEN_PAREN","DOM_VK_P","DOM_VK_PA1","DOM_VK_PAGEDOWN","DOM_VK_PAGEUP","DOM_VK_PAGE_DOWN","DOM_VK_PAGE_UP","DOM_VK_PAUSE","DOM_VK_PERCENT","DOM_VK_PERIOD","DOM_VK_PIPE","DOM_VK_PLAY","DOM_VK_PLUS","DOM_VK_PRINT","DOM_VK_PRINTSCREEN","DOM_VK_PROCESSKEY","DOM_VK_PROPERITES","DOM_VK_Q","DOM_VK_QUESTION_MARK","DOM_VK_QUOTE","DOM_VK_R","DOM_VK_REDO","DOM_VK_RETURN","DOM_VK_RIGHT","DOM_VK_S","DOM_VK_SCROLL_LOCK","DOM_VK_SELECT","DOM_VK_SEMICOLON","DOM_VK_SEPARATOR","DOM_VK_SHIFT","DOM_VK_SLASH","DOM_VK_SLEEP","DOM_VK_SPACE","DOM_VK_SUBTRACT","DOM_VK_T","DOM_VK_TAB","DOM_VK_TILDE","DOM_VK_U","DOM_VK_UNDERSCORE","DOM_VK_UNDO","DOM_VK_UNICODE","DOM_VK_UP","DOM_VK_V","DOM_VK_VOLUME_DOWN","DOM_VK_VOLUME_MUTE","DOM_VK_VOLUME_UP","DOM_VK_W","DOM_VK_WIN","DOM_VK_WINDOW","DOM_VK_WIN_ICO_00","DOM_VK_WIN_ICO_CLEAR","DOM_VK_WIN_ICO_HELP","DOM_VK_WIN_OEM_ATTN","DOM_VK_WIN_OEM_AUTO","DOM_VK_WIN_OEM_BACKTAB","DOM_VK_WIN_OEM_CLEAR","DOM_VK_WIN_OEM_COPY","DOM_VK_WIN_OEM_CUSEL","DOM_VK_WIN_OEM_ENLW","DOM_VK_WIN_OEM_FINISH","DOM_VK_WIN_OEM_FJ_JISHO","DOM_VK_WIN_OEM_FJ_LOYA","DOM_VK_WIN_OEM_FJ_MASSHOU","DOM_VK_WIN_OEM_FJ_ROYA","DOM_VK_WIN_OEM_FJ_TOUROKU","DOM_VK_WIN_OEM_JUMP","DOM_VK_WIN_OEM_PA1","DOM_VK_WIN_OEM_PA2","DOM_VK_WIN_OEM_PA3","DOM_VK_WIN_OEM_RESET","DOM_VK_WIN_OEM_WSCTRL","DOM_VK_X","DOM_VK_XF86XK_ADD_FAVORITE","DOM_VK_XF86XK_APPLICATION_LEFT","DOM_VK_XF86XK_APPLICATION_RIGHT","DOM_VK_XF86XK_AUDIO_CYCLE_TRACK","DOM_VK_XF86XK_AUDIO_FORWARD","DOM_VK_XF86XK_AUDIO_LOWER_VOLUME","DOM_VK_XF86XK_AUDIO_MEDIA","DOM_VK_XF86XK_AUDIO_MUTE","DOM_VK_XF86XK_AUDIO_NEXT","DOM_VK_XF86XK_AUDIO_PAUSE","DOM_VK_XF86XK_AUDIO_PLAY","DOM_VK_XF86XK_AUDIO_PREV","DOM_VK_XF86XK_AUDIO_RAISE_VOLUME","DOM_VK_XF86XK_AUDIO_RANDOM_PLAY","DOM_VK_XF86XK_AUDIO_RECORD","DOM_VK_XF86XK_AUDIO_REPEAT","DOM_VK_XF86XK_AUDIO_REWIND","DOM_VK_XF86XK_AUDIO_STOP","DOM_VK_XF86XK_AWAY","DOM_VK_XF86XK_BACK","DOM_VK_XF86XK_BACK_FORWARD","DOM_VK_XF86XK_BATTERY","DOM_VK_XF86XK_BLUE","DOM_VK_XF86XK_BLUETOOTH","DOM_VK_XF86XK_BOOK","DOM_VK_XF86XK_BRIGHTNESS_ADJUST","DOM_VK_XF86XK_CALCULATOR","DOM_VK_XF86XK_CALENDAR","DOM_VK_XF86XK_CD","DOM_VK_XF86XK_CLOSE","DOM_VK_XF86XK_COMMUNITY","DOM_VK_XF86XK_CONTRAST_ADJUST","DOM_VK_XF86XK_COPY","DOM_VK_XF86XK_CUT","DOM_VK_XF86XK_CYCLE_ANGLE","DOM_VK_XF86XK_DISPLAY","DOM_VK_XF86XK_DOCUMENTS","DOM_VK_XF86XK_DOS","DOM_VK_XF86XK_EJECT","DOM_VK_XF86XK_EXCEL","DOM_VK_XF86XK_EXPLORER","DOM_VK_XF86XK_FAVORITES","DOM_VK_XF86XK_FINANCE","DOM_VK_XF86XK_FORWARD","DOM_VK_XF86XK_FRAME_BACK","DOM_VK_XF86XK_FRAME_FORWARD","DOM_VK_XF86XK_GAME","DOM_VK_XF86XK_GO","DOM_VK_XF86XK_GREEN","DOM_VK_XF86XK_HIBERNATE","DOM_VK_XF86XK_HISTORY","DOM_VK_XF86XK_HOME_PAGE","DOM_VK_XF86XK_HOT_LINKS","DOM_VK_XF86XK_I_TOUCH","DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN","DOM_VK_XF86XK_KBD_BRIGHTNESS_UP","DOM_VK_XF86XK_KBD_LIGHT_ON_OFF","DOM_VK_XF86XK_LAUNCH0","DOM_VK_XF86XK_LAUNCH1","DOM_VK_XF86XK_LAUNCH2","DOM_VK_XF86XK_LAUNCH3","DOM_VK_XF86XK_LAUNCH4","DOM_VK_XF86XK_LAUNCH5","DOM_VK_XF86XK_LAUNCH6","DOM_VK_XF86XK_LAUNCH7","DOM_VK_XF86XK_LAUNCH8","DOM_VK_XF86XK_LAUNCH9","DOM_VK_XF86XK_LAUNCH_A","DOM_VK_XF86XK_LAUNCH_B","DOM_VK_XF86XK_LAUNCH_C","DOM_VK_XF86XK_LAUNCH_D","DOM_VK_XF86XK_LAUNCH_E","DOM_VK_XF86XK_LAUNCH_F","DOM_VK_XF86XK_LIGHT_BULB","DOM_VK_XF86XK_LOG_OFF","DOM_VK_XF86XK_MAIL","DOM_VK_XF86XK_MAIL_FORWARD","DOM_VK_XF86XK_MARKET","DOM_VK_XF86XK_MEETING","DOM_VK_XF86XK_MEMO","DOM_VK_XF86XK_MENU_KB","DOM_VK_XF86XK_MENU_PB","DOM_VK_XF86XK_MESSENGER","DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN","DOM_VK_XF86XK_MON_BRIGHTNESS_UP","DOM_VK_XF86XK_MUSIC","DOM_VK_XF86XK_MY_COMPUTER","DOM_VK_XF86XK_MY_SITES","DOM_VK_XF86XK_NEW","DOM_VK_XF86XK_NEWS","DOM_VK_XF86XK_OFFICE_HOME","DOM_VK_XF86XK_OPEN","DOM_VK_XF86XK_OPEN_URL","DOM_VK_XF86XK_OPTION","DOM_VK_XF86XK_PASTE","DOM_VK_XF86XK_PHONE","DOM_VK_XF86XK_PICTURES","DOM_VK_XF86XK_POWER_DOWN","DOM_VK_XF86XK_POWER_OFF","DOM_VK_XF86XK_RED","DOM_VK_XF86XK_REFRESH","DOM_VK_XF86XK_RELOAD","DOM_VK_XF86XK_REPLY","DOM_VK_XF86XK_ROCKER_DOWN","DOM_VK_XF86XK_ROCKER_ENTER","DOM_VK_XF86XK_ROCKER_UP","DOM_VK_XF86XK_ROTATE_WINDOWS","DOM_VK_XF86XK_ROTATION_KB","DOM_VK_XF86XK_ROTATION_PB","DOM_VK_XF86XK_SAVE","DOM_VK_XF86XK_SCREEN_SAVER","DOM_VK_XF86XK_SCROLL_CLICK","DOM_VK_XF86XK_SCROLL_DOWN","DOM_VK_XF86XK_SCROLL_UP","DOM_VK_XF86XK_SEARCH","DOM_VK_XF86XK_SEND","DOM_VK_XF86XK_SHOP","DOM_VK_XF86XK_SPELL","DOM_VK_XF86XK_SPLIT_SCREEN","DOM_VK_XF86XK_STANDBY","DOM_VK_XF86XK_START","DOM_VK_XF86XK_STOP","DOM_VK_XF86XK_SUBTITLE","DOM_VK_XF86XK_SUPPORT","DOM_VK_XF86XK_SUSPEND","DOM_VK_XF86XK_TASK_PANE","DOM_VK_XF86XK_TERMINAL","DOM_VK_XF86XK_TIME","DOM_VK_XF86XK_TOOLS","DOM_VK_XF86XK_TOP_MENU","DOM_VK_XF86XK_TO_DO_LIST","DOM_VK_XF86XK_TRAVEL","DOM_VK_XF86XK_USER1KB","DOM_VK_XF86XK_USER2KB","DOM_VK_XF86XK_USER_PB","DOM_VK_XF86XK_UWB","DOM_VK_XF86XK_VENDOR_HOME","DOM_VK_XF86XK_VIDEO","DOM_VK_XF86XK_VIEW","DOM_VK_XF86XK_WAKE_UP","DOM_VK_XF86XK_WEB_CAM","DOM_VK_XF86XK_WHEEL_BUTTON","DOM_VK_XF86XK_WLAN","DOM_VK_XF86XK_WORD","DOM_VK_XF86XK_WWW","DOM_VK_XF86XK_XFER","DOM_VK_XF86XK_YELLOW","DOM_VK_XF86XK_ZOOM_IN","DOM_VK_XF86XK_ZOOM_OUT","DOM_VK_Y","DOM_VK_Z","DOM_VK_ZOOM","DONE","DONT_CARE","DOWNLOADING","DRAGDROP","DRAW_BUFFER0","DRAW_BUFFER1","DRAW_BUFFER10","DRAW_BUFFER11","DRAW_BUFFER12","DRAW_BUFFER13","DRAW_BUFFER14","DRAW_BUFFER15","DRAW_BUFFER2","DRAW_BUFFER3","DRAW_BUFFER4","DRAW_BUFFER5","DRAW_BUFFER6","DRAW_BUFFER7","DRAW_BUFFER8","DRAW_BUFFER9","DRAW_FRAMEBUFFER","DRAW_FRAMEBUFFER_BINDING","DST_ALPHA","DST_COLOR","DYNAMIC_COPY","DYNAMIC_DRAW","DYNAMIC_READ","DataChannel","DataTransfer","DataTransferItem","DataTransferItemList","DataView","Date","DateTimeFormat","DecompressionStream","DelayNode","DeprecationReportBody","DesktopNotification","DesktopNotificationCenter","DeviceLightEvent","DeviceMotionEvent","DeviceMotionEventAcceleration","DeviceMotionEventRotationRate","DeviceOrientationEvent","DeviceProximityEvent","DeviceStorage","DeviceStorageChangeEvent","Directory","DisplayNames","Document","DocumentFragment","DocumentTimeline","DocumentType","DragEvent","DynamicsCompressorNode","E","ELEMENT_ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER_BINDING","ELEMENT_NODE","EMPTY","ENCODING_ERR","ENDED","END_TO_END","END_TO_START","ENTITY_NODE","ENTITY_REFERENCE_NODE","EPSILON","EQUAL","EQUALPOWER","ERROR","EXPONENTIAL_DISTANCE","exports","Element","ElementInternals","ElementQuery","EnterPictureInPictureEvent","Entity","EntityReference","Error","ErrorEvent","EvalError","Event","EventException","EventSource","EventTarget","External","FASTEST","FIDOSDK","FILTER_ACCEPT","FILTER_INTERRUPT","FILTER_REJECT","FILTER_SKIP","FINISHED_STATE","FIRST_ORDERED_NODE_TYPE","FLOAT","FLOAT_32_UNSIGNED_INT_24_8_REV","FLOAT_MAT2","FLOAT_MAT2x3","FLOAT_MAT2x4","FLOAT_MAT3","FLOAT_MAT3x2","FLOAT_MAT3x4","FLOAT_MAT4","FLOAT_MAT4x2","FLOAT_MAT4x3","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","FOCUS","FONT_FACE_RULE","FONT_FEATURE_VALUES_RULE","FRAGMENT_SHADER","FRAGMENT_SHADER_DERIVATIVE_HINT","FRAGMENT_SHADER_DERIVATIVE_HINT_OES","FRAMEBUFFER","FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE","FRAMEBUFFER_ATTACHMENT_BLUE_SIZE","FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING","FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE","FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE","FRAMEBUFFER_ATTACHMENT_GREEN_SIZE","FRAMEBUFFER_ATTACHMENT_OBJECT_NAME","FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE","FRAMEBUFFER_ATTACHMENT_RED_SIZE","FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE","FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE","FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER","FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL","FRAMEBUFFER_BINDING","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_DEFAULT","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE","FRAMEBUFFER_UNSUPPORTED","FRONT","FRONT_AND_BACK","FRONT_FACE","FUNC_ADD","FUNC_REVERSE_SUBTRACT","FUNC_SUBTRACT","FeaturePolicy","FeaturePolicyViolationReportBody","FederatedCredential","Feed","FeedEntry","File","FileError","FileList","FileReader","FileSystem","FileSystemDirectoryEntry","FileSystemDirectoryReader","FileSystemEntry","FileSystemFileEntry","FinalizationRegistry","FindInPage","Float32Array","Float64Array","FocusEvent","FontFace","FontFaceSet","FontFaceSetLoadEvent","FormData","FormDataEvent","FragmentDirective","Function","GENERATE_MIPMAP_HINT","GEQUAL","GREATER","GREEN_BITS","GainNode","Gamepad","GamepadAxisMoveEvent","GamepadButton","GamepadButtonEvent","GamepadEvent","GamepadHapticActuator","GamepadPose","Geolocation","GeolocationCoordinates","GeolocationPosition","GeolocationPositionError","GestureEvent","Global","Gyroscope","HALF_FLOAT","HAVE_CURRENT_DATA","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","HAVE_METADATA","HAVE_NOTHING","HEADERS_RECEIVED","HIDDEN","HIERARCHY_REQUEST_ERR","HIGHPASS","HIGHSHELF","HIGH_FLOAT","HIGH_INT","HORIZONTAL","HORIZONTAL_AXIS","HRTF","HTMLAllCollection","HTMLAnchorElement","HTMLAppletElement","HTMLAreaElement","HTMLAudioElement","HTMLBRElement","HTMLBaseElement","HTMLBaseFontElement","HTMLBlockquoteElement","HTMLBodyElement","HTMLButtonElement","HTMLCanvasElement","HTMLCollection","HTMLCommandElement","HTMLContentElement","HTMLDListElement","HTMLDataElement","HTMLDataListElement","HTMLDetailsElement","HTMLDialogElement","HTMLDirectoryElement","HTMLDivElement","HTMLDocument","HTMLElement","HTMLEmbedElement","HTMLFieldSetElement","HTMLFontElement","HTMLFormControlsCollection","HTMLFormElement","HTMLFrameElement","HTMLFrameSetElement","HTMLHRElement","HTMLHeadElement","HTMLHeadingElement","HTMLHtmlElement","HTMLIFrameElement","HTMLImageElement","HTMLInputElement","HTMLIsIndexElement","HTMLKeygenElement","HTMLLIElement","HTMLLabelElement","HTMLLegendElement","HTMLLinkElement","HTMLMapElement","HTMLMarqueeElement","HTMLMediaElement","HTMLMenuElement","HTMLMenuItemElement","HTMLMetaElement","HTMLMeterElement","HTMLModElement","HTMLOListElement","HTMLObjectElement","HTMLOptGroupElement","HTMLOptionElement","HTMLOptionsCollection","HTMLOutputElement","HTMLParagraphElement","HTMLParamElement","HTMLPictureElement","HTMLPreElement","HTMLProgressElement","HTMLPropertiesCollection","HTMLQuoteElement","HTMLScriptElement","HTMLSelectElement","HTMLShadowElement","HTMLSlotElement","HTMLSourceElement","HTMLSpanElement","HTMLStyleElement","HTMLTableCaptionElement","HTMLTableCellElement","HTMLTableColElement","HTMLTableElement","HTMLTableRowElement","HTMLTableSectionElement","HTMLTemplateElement","HTMLTextAreaElement","HTMLTimeElement","HTMLTitleElement","HTMLTrackElement","HTMLUListElement","HTMLUnknownElement","HTMLVideoElement","HashChangeEvent","Headers","History","Hz","ICE_CHECKING","ICE_CLOSED","ICE_COMPLETED","ICE_CONNECTED","ICE_FAILED","ICE_GATHERING","ICE_WAITING","IDBCursor","IDBCursorWithValue","IDBDatabase","IDBDatabaseException","IDBFactory","IDBFileHandle","IDBFileRequest","IDBIndex","IDBKeyRange","IDBMutableFile","IDBObjectStore","IDBOpenDBRequest","IDBRequest","IDBTransaction","IDBVersionChangeEvent","IDLE","IIRFilterNode","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","IMPORT_RULE","INCR","INCR_WRAP","INDEX_SIZE_ERR","INT","INTERLEAVED_ATTRIBS","INT_2_10_10_10_REV","INT_SAMPLER_2D","INT_SAMPLER_2D_ARRAY","INT_SAMPLER_3D","INT_SAMPLER_CUBE","INT_VEC2","INT_VEC3","INT_VEC4","INUSE_ATTRIBUTE_ERR","INVALID_ACCESS_ERR","INVALID_CHARACTER_ERR","INVALID_ENUM","INVALID_EXPRESSION_ERR","INVALID_FRAMEBUFFER_OPERATION","INVALID_INDEX","INVALID_MODIFICATION_ERR","INVALID_NODE_TYPE_ERR","INVALID_OPERATION","INVALID_STATE_ERR","INVALID_VALUE","INVERSE_DISTANCE","INVERT","IceCandidate","IdleDeadline","Image","ImageBitmap","ImageBitmapRenderingContext","ImageCapture","ImageData","Infinity","InputDeviceCapabilities","InputDeviceInfo","InputEvent","InputMethodContext","InstallTrigger","InstallTriggerImpl","Instance","Int16Array","Int32Array","Int8Array","Intent","InternalError","IntersectionObserver","IntersectionObserverEntry","Intl","IsSearchProviderInstalled","Iterator","JSON","KEEP","KEYDOWN","KEYFRAMES_RULE","KEYFRAME_RULE","KEYPRESS","KEYUP","KeyEvent","Keyboard","KeyboardEvent","KeyboardLayoutMap","KeyframeEffect","LENGTHADJUST_SPACING","LENGTHADJUST_SPACINGANDGLYPHS","LENGTHADJUST_UNKNOWN","LEQUAL","LESS","LINEAR","LINEAR_DISTANCE","LINEAR_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINES","LINE_LOOP","LINE_STRIP","LINE_WIDTH","LINK_STATUS","LIVE","LN10","LN2","LOADED","LOADING","LOG10E","LOG2E","LOWPASS","LOWSHELF","LOW_FLOAT","LOW_INT","LSException","LSParserFilter","LUMINANCE","LUMINANCE_ALPHA","LargestContentfulPaint","LayoutShift","LayoutShiftAttribution","LinearAccelerationSensor","LinkError","ListFormat","LocalMediaStream","Locale","Location","Lock","LockManager","MAX","MAX_3D_TEXTURE_SIZE","MAX_ARRAY_TEXTURE_LAYERS","MAX_CLIENT_WAIT_TIMEOUT_WEBGL","MAX_COLOR_ATTACHMENTS","MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS","MAX_COMBINED_TEXTURE_IMAGE_UNITS","MAX_COMBINED_UNIFORM_BLOCKS","MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS","MAX_CUBE_MAP_TEXTURE_SIZE","MAX_DRAW_BUFFERS","MAX_ELEMENTS_INDICES","MAX_ELEMENTS_VERTICES","MAX_ELEMENT_INDEX","MAX_FRAGMENT_INPUT_COMPONENTS","MAX_FRAGMENT_UNIFORM_BLOCKS","MAX_FRAGMENT_UNIFORM_COMPONENTS","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_PROGRAM_TEXEL_OFFSET","MAX_RENDERBUFFER_SIZE","MAX_SAFE_INTEGER","MAX_SAMPLES","MAX_SERVER_WAIT_TIMEOUT","MAX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_LOD_BIAS","MAX_TEXTURE_MAX_ANISOTROPY_EXT","MAX_TEXTURE_SIZE","MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS","MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS","MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS","MAX_UNIFORM_BLOCK_SIZE","MAX_UNIFORM_BUFFER_BINDINGS","MAX_VALUE","MAX_VARYING_COMPONENTS","MAX_VARYING_VECTORS","MAX_VERTEX_ATTRIBS","MAX_VERTEX_OUTPUT_COMPONENTS","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_VERTEX_UNIFORM_BLOCKS","MAX_VERTEX_UNIFORM_COMPONENTS","MAX_VERTEX_UNIFORM_VECTORS","MAX_VIEWPORT_DIMS","MEDIA_ERR_ABORTED","MEDIA_ERR_DECODE","MEDIA_ERR_ENCRYPTED","MEDIA_ERR_NETWORK","MEDIA_ERR_SRC_NOT_SUPPORTED","MEDIA_KEYERR_CLIENT","MEDIA_KEYERR_DOMAIN","MEDIA_KEYERR_HARDWARECHANGE","MEDIA_KEYERR_OUTPUT","MEDIA_KEYERR_SERVICE","MEDIA_KEYERR_UNKNOWN","MEDIA_RULE","MEDIUM_FLOAT","MEDIUM_INT","META_MASK","MIDIAccess","MIDIConnectionEvent","MIDIInput","MIDIInputMap","MIDIMessageEvent","MIDIOutput","MIDIOutputMap","MIDIPort","MIN","MIN_PROGRAM_TEXEL_OFFSET","MIN_SAFE_INTEGER","MIN_VALUE","MIRRORED_REPEAT","MODE_ASYNCHRONOUS","MODE_SYNCHRONOUS","MODIFICATION","MOUSEDOWN","MOUSEDRAG","MOUSEMOVE","MOUSEOUT","MOUSEOVER","MOUSEUP","MOZ_KEYFRAMES_RULE","MOZ_KEYFRAME_RULE","MOZ_SOURCE_CURSOR","MOZ_SOURCE_ERASER","MOZ_SOURCE_KEYBOARD","MOZ_SOURCE_MOUSE","MOZ_SOURCE_PEN","MOZ_SOURCE_TOUCH","MOZ_SOURCE_UNKNOWN","MSGESTURE_FLAG_BEGIN","MSGESTURE_FLAG_CANCEL","MSGESTURE_FLAG_END","MSGESTURE_FLAG_INERTIA","MSGESTURE_FLAG_NONE","MSPOINTER_TYPE_MOUSE","MSPOINTER_TYPE_PEN","MSPOINTER_TYPE_TOUCH","MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE","MS_ASYNC_CALLBACK_STATUS_CANCEL","MS_ASYNC_CALLBACK_STATUS_CHOOSEANY","MS_ASYNC_CALLBACK_STATUS_ERROR","MS_ASYNC_CALLBACK_STATUS_JOIN","MS_ASYNC_OP_STATUS_CANCELED","MS_ASYNC_OP_STATUS_ERROR","MS_ASYNC_OP_STATUS_SUCCESS","MS_MANIPULATION_STATE_ACTIVE","MS_MANIPULATION_STATE_CANCELLED","MS_MANIPULATION_STATE_COMMITTED","MS_MANIPULATION_STATE_DRAGGING","MS_MANIPULATION_STATE_INERTIA","MS_MANIPULATION_STATE_PRESELECT","MS_MANIPULATION_STATE_SELECTING","MS_MANIPULATION_STATE_STOPPED","MS_MEDIA_ERR_ENCRYPTED","MS_MEDIA_KEYERR_CLIENT","MS_MEDIA_KEYERR_DOMAIN","MS_MEDIA_KEYERR_HARDWARECHANGE","MS_MEDIA_KEYERR_OUTPUT","MS_MEDIA_KEYERR_SERVICE","MS_MEDIA_KEYERR_UNKNOWN","Map","Math","MathMLElement","MediaCapabilities","MediaCapabilitiesInfo","MediaController","MediaDeviceInfo","MediaDevices","MediaElementAudioSourceNode","MediaEncryptedEvent","MediaError","MediaKeyError","MediaKeyEvent","MediaKeyMessageEvent","MediaKeyNeededEvent","MediaKeySession","MediaKeyStatusMap","MediaKeySystemAccess","MediaKeys","MediaList","MediaMetadata","MediaQueryList","MediaQueryListEvent","MediaRecorder","MediaRecorderErrorEvent","MediaSession","MediaSettingsRange","MediaSource","MediaStream","MediaStreamAudioDestinationNode","MediaStreamAudioSourceNode","MediaStreamEvent","MediaStreamTrack","MediaStreamTrackAudioSourceNode","MediaStreamTrackEvent","Memory","MessageChannel","MessageEvent","MessagePort","Methods","MimeType","MimeTypeArray","Module","MouseEvent","MouseScrollEvent","MozAnimation","MozAnimationDelay","MozAnimationDirection","MozAnimationDuration","MozAnimationFillMode","MozAnimationIterationCount","MozAnimationName","MozAnimationPlayState","MozAnimationTimingFunction","MozAppearance","MozBackfaceVisibility","MozBinding","MozBorderBottomColors","MozBorderEnd","MozBorderEndColor","MozBorderEndStyle","MozBorderEndWidth","MozBorderImage","MozBorderLeftColors","MozBorderRightColors","MozBorderStart","MozBorderStartColor","MozBorderStartStyle","MozBorderStartWidth","MozBorderTopColors","MozBoxAlign","MozBoxDirection","MozBoxFlex","MozBoxOrdinalGroup","MozBoxOrient","MozBoxPack","MozBoxSizing","MozCSSKeyframeRule","MozCSSKeyframesRule","MozColumnCount","MozColumnFill","MozColumnGap","MozColumnRule","MozColumnRuleColor","MozColumnRuleStyle","MozColumnRuleWidth","MozColumnWidth","MozColumns","MozContactChangeEvent","MozFloatEdge","MozFontFeatureSettings","MozFontLanguageOverride","MozForceBrokenImageIcon","MozHyphens","MozImageRegion","MozMarginEnd","MozMarginStart","MozMmsEvent","MozMmsMessage","MozMobileMessageThread","MozOSXFontSmoothing","MozOrient","MozOsxFontSmoothing","MozOutlineRadius","MozOutlineRadiusBottomleft","MozOutlineRadiusBottomright","MozOutlineRadiusTopleft","MozOutlineRadiusTopright","MozPaddingEnd","MozPaddingStart","MozPerspective","MozPerspectiveOrigin","MozPowerManager","MozSettingsEvent","MozSmsEvent","MozSmsMessage","MozStackSizing","MozTabSize","MozTextAlignLast","MozTextDecorationColor","MozTextDecorationLine","MozTextDecorationStyle","MozTextSizeAdjust","MozTransform","MozTransformOrigin","MozTransformStyle","MozTransition","MozTransitionDelay","MozTransitionDuration","MozTransitionProperty","MozTransitionTimingFunction","MozUserFocus","MozUserInput","MozUserModify","MozUserSelect","MozWindowDragging","MozWindowShadow","MutationEvent","MutationObserver","MutationRecord","NAMESPACE_ERR","NAMESPACE_RULE","NEAREST","NEAREST_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","NEGATIVE_INFINITY","NETWORK_EMPTY","NETWORK_ERR","NETWORK_IDLE","NETWORK_LOADED","NETWORK_LOADING","NETWORK_NO_SOURCE","NEVER","NEW","NEXT","NEXT_NO_DUPLICATE","NICEST","NODE_AFTER","NODE_BEFORE","NODE_BEFORE_AND_AFTER","NODE_INSIDE","NONE","NON_TRANSIENT_ERR","NOTATION_NODE","NOTCH","NOTEQUAL","NOT_ALLOWED_ERR","NOT_FOUND_ERR","NOT_READABLE_ERR","NOT_SUPPORTED_ERR","NO_DATA_ALLOWED_ERR","NO_ERR","NO_ERROR","NO_MODIFICATION_ALLOWED_ERR","NUMBER_TYPE","NUM_COMPRESSED_TEXTURE_FORMATS","NaN","NamedNodeMap","NavigationPreloadManager","Navigator","NearbyLinks","NetworkInformation","Node","NodeFilter","NodeIterator","NodeList","Notation","Notification","NotifyPaintEvent","Number","NumberFormat","OBJECT_TYPE","OBSOLETE","OK","ONE","ONE_MINUS_CONSTANT_ALPHA","ONE_MINUS_CONSTANT_COLOR","ONE_MINUS_DST_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_SRC_COLOR","OPEN","OPENED","OPENING","ORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","OTHER_ERROR","OUT_OF_MEMORY","Object","OfflineAudioCompletionEvent","OfflineAudioContext","OfflineResourceList","OffscreenCanvas","OffscreenCanvasRenderingContext2D","Option","OrientationSensor","OscillatorNode","OverconstrainedError","OverflowEvent","PACK_ALIGNMENT","PACK_ROW_LENGTH","PACK_SKIP_PIXELS","PACK_SKIP_ROWS","PAGE_RULE","PARSE_ERR","PATHSEG_ARC_ABS","PATHSEG_ARC_REL","PATHSEG_CLOSEPATH","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","PATHSEG_LINETO_ABS","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_REL","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_MOVETO_ABS","PATHSEG_MOVETO_REL","PATHSEG_UNKNOWN","PATH_EXISTS_ERR","PEAKING","PERMISSION_DENIED","PERSISTENT","PI","PIXEL_PACK_BUFFER","PIXEL_PACK_BUFFER_BINDING","PIXEL_UNPACK_BUFFER","PIXEL_UNPACK_BUFFER_BINDING","PLAYING_STATE","POINTS","POLYGON_OFFSET_FACTOR","POLYGON_OFFSET_FILL","POLYGON_OFFSET_UNITS","POSITION_UNAVAILABLE","POSITIVE_INFINITY","PREV","PREV_NO_DUPLICATE","PROCESSING_INSTRUCTION_NODE","PageChangeEvent","PageTransitionEvent","PaintRequest","PaintRequestList","PannerNode","PasswordCredential","Path2D","PaymentAddress","PaymentInstruments","PaymentManager","PaymentMethodChangeEvent","PaymentRequest","PaymentRequestUpdateEvent","PaymentResponse","Performance","PerformanceElementTiming","PerformanceEntry","PerformanceEventTiming","PerformanceLongTaskTiming","PerformanceMark","PerformanceMeasure","PerformanceNavigation","PerformanceNavigationTiming","PerformanceObserver","PerformanceObserverEntryList","PerformancePaintTiming","PerformanceResourceTiming","PerformanceServerTiming","PerformanceTiming","PeriodicSyncManager","PeriodicWave","PermissionStatus","Permissions","PhotoCapabilities","PictureInPictureWindow","Plugin","PluginArray","PluralRules","PointerEvent","PopStateEvent","PopupBlockedEvent","Presentation","PresentationAvailability","PresentationConnection","PresentationConnectionAvailableEvent","PresentationConnectionCloseEvent","PresentationConnectionList","PresentationReceiver","PresentationRequest","ProcessingInstruction","ProgressEvent","Promise","PromiseRejectionEvent","PropertyNodeList","Proxy","PublicKeyCredential","PushManager","PushSubscription","PushSubscriptionOptions","Q","QUERY_RESULT","QUERY_RESULT_AVAILABLE","QUOTA_ERR","QUOTA_EXCEEDED_ERR","QueryInterface","R11F_G11F_B10F","R16F","R16I","R16UI","R32F","R32I","R32UI","R8","R8I","R8UI","R8_SNORM","RASTERIZER_DISCARD","READ_BUFFER","READ_FRAMEBUFFER","READ_FRAMEBUFFER_BINDING","READ_ONLY","READ_ONLY_ERR","READ_WRITE","RED","RED_BITS","RED_INTEGER","REMOVAL","RENDERBUFFER","RENDERBUFFER_ALPHA_SIZE","RENDERBUFFER_BINDING","RENDERBUFFER_BLUE_SIZE","RENDERBUFFER_DEPTH_SIZE","RENDERBUFFER_GREEN_SIZE","RENDERBUFFER_HEIGHT","RENDERBUFFER_INTERNAL_FORMAT","RENDERBUFFER_RED_SIZE","RENDERBUFFER_SAMPLES","RENDERBUFFER_STENCIL_SIZE","RENDERBUFFER_WIDTH","RENDERER","RENDERING_INTENT_ABSOLUTE_COLORIMETRIC","RENDERING_INTENT_AUTO","RENDERING_INTENT_PERCEPTUAL","RENDERING_INTENT_RELATIVE_COLORIMETRIC","RENDERING_INTENT_SATURATION","RENDERING_INTENT_UNKNOWN","REPEAT","REPLACE","RG","RG16F","RG16I","RG16UI","RG32F","RG32I","RG32UI","RG8","RG8I","RG8UI","RG8_SNORM","RGB","RGB10_A2","RGB10_A2UI","RGB16F","RGB16I","RGB16UI","RGB32F","RGB32I","RGB32UI","RGB565","RGB5_A1","RGB8","RGB8I","RGB8UI","RGB8_SNORM","RGB9_E5","RGBA","RGBA16F","RGBA16I","RGBA16UI","RGBA32F","RGBA32I","RGBA32UI","RGBA4","RGBA8","RGBA8I","RGBA8UI","RGBA8_SNORM","RGBA_INTEGER","RGBColor","RGB_INTEGER","RG_INTEGER","ROTATION_CLOCKWISE","ROTATION_COUNTERCLOCKWISE","RTCCertificate","RTCDTMFSender","RTCDTMFToneChangeEvent","RTCDataChannel","RTCDataChannelEvent","RTCDtlsTransport","RTCError","RTCErrorEvent","RTCIceCandidate","RTCIceTransport","RTCPeerConnection","RTCPeerConnectionIceErrorEvent","RTCPeerConnectionIceEvent","RTCRtpReceiver","RTCRtpSender","RTCRtpTransceiver","RTCSctpTransport","RTCSessionDescription","RTCStatsReport","RTCTrackEvent","RadioNodeList","Range","RangeError","RangeException","ReadableStream","ReadableStreamDefaultReader","RecordErrorEvent","Rect","ReferenceError","Reflect","RegExp","RelativeOrientationSensor","RelativeTimeFormat","RemotePlayback","Report","ReportBody","ReportingObserver","Request","ResizeObserver","ResizeObserverEntry","ResizeObserverSize","Response","RuntimeError","SAMPLER_2D","SAMPLER_2D_ARRAY","SAMPLER_2D_ARRAY_SHADOW","SAMPLER_2D_SHADOW","SAMPLER_3D","SAMPLER_BINDING","SAMPLER_CUBE","SAMPLER_CUBE_SHADOW","SAMPLES","SAMPLE_ALPHA_TO_COVERAGE","SAMPLE_BUFFERS","SAMPLE_COVERAGE","SAMPLE_COVERAGE_INVERT","SAMPLE_COVERAGE_VALUE","SAWTOOTH","SCHEDULED_STATE","SCISSOR_BOX","SCISSOR_TEST","SCROLL_PAGE_DOWN","SCROLL_PAGE_UP","SDP_ANSWER","SDP_OFFER","SDP_PRANSWER","SECURITY_ERR","SELECT","SEPARATE_ATTRIBS","SERIALIZE_ERR","SEVERITY_ERROR","SEVERITY_FATAL_ERROR","SEVERITY_WARNING","SHADER_COMPILER","SHADER_TYPE","SHADING_LANGUAGE_VERSION","SHIFT_MASK","SHORT","SHOWING","SHOW_ALL","SHOW_ATTRIBUTE","SHOW_CDATA_SECTION","SHOW_COMMENT","SHOW_DOCUMENT","SHOW_DOCUMENT_FRAGMENT","SHOW_DOCUMENT_TYPE","SHOW_ELEMENT","SHOW_ENTITY","SHOW_ENTITY_REFERENCE","SHOW_NOTATION","SHOW_PROCESSING_INSTRUCTION","SHOW_TEXT","SIGNALED","SIGNED_NORMALIZED","SINE","SOUNDFIELD","SQLException","SQRT1_2","SQRT2","SQUARE","SRC_ALPHA","SRC_ALPHA_SATURATE","SRC_COLOR","SRGB","SRGB8","SRGB8_ALPHA8","START_TO_END","START_TO_START","STATIC_COPY","STATIC_DRAW","STATIC_READ","STENCIL","STENCIL_ATTACHMENT","STENCIL_BACK_FAIL","STENCIL_BACK_FUNC","STENCIL_BACK_PASS_DEPTH_FAIL","STENCIL_BACK_PASS_DEPTH_PASS","STENCIL_BACK_REF","STENCIL_BACK_VALUE_MASK","STENCIL_BACK_WRITEMASK","STENCIL_BITS","STENCIL_BUFFER_BIT","STENCIL_CLEAR_VALUE","STENCIL_FAIL","STENCIL_FUNC","STENCIL_INDEX","STENCIL_INDEX8","STENCIL_PASS_DEPTH_FAIL","STENCIL_PASS_DEPTH_PASS","STENCIL_REF","STENCIL_TEST","STENCIL_VALUE_MASK","STENCIL_WRITEMASK","STREAM_COPY","STREAM_DRAW","STREAM_READ","STRING_TYPE","STYLE_RULE","SUBPIXEL_BITS","SUPPORTS_RULE","SVGAElement","SVGAltGlyphDefElement","SVGAltGlyphElement","SVGAltGlyphItemElement","SVGAngle","SVGAnimateColorElement","SVGAnimateElement","SVGAnimateMotionElement","SVGAnimateTransformElement","SVGAnimatedAngle","SVGAnimatedBoolean","SVGAnimatedEnumeration","SVGAnimatedInteger","SVGAnimatedLength","SVGAnimatedLengthList","SVGAnimatedNumber","SVGAnimatedNumberList","SVGAnimatedPreserveAspectRatio","SVGAnimatedRect","SVGAnimatedString","SVGAnimatedTransformList","SVGAnimationElement","SVGCircleElement","SVGClipPathElement","SVGColor","SVGComponentTransferFunctionElement","SVGCursorElement","SVGDefsElement","SVGDescElement","SVGDiscardElement","SVGDocument","SVGElement","SVGElementInstance","SVGElementInstanceList","SVGEllipseElement","SVGException","SVGFEBlendElement","SVGFEColorMatrixElement","SVGFEComponentTransferElement","SVGFECompositeElement","SVGFEConvolveMatrixElement","SVGFEDiffuseLightingElement","SVGFEDisplacementMapElement","SVGFEDistantLightElement","SVGFEDropShadowElement","SVGFEFloodElement","SVGFEFuncAElement","SVGFEFuncBElement","SVGFEFuncGElement","SVGFEFuncRElement","SVGFEGaussianBlurElement","SVGFEImageElement","SVGFEMergeElement","SVGFEMergeNodeElement","SVGFEMorphologyElement","SVGFEOffsetElement","SVGFEPointLightElement","SVGFESpecularLightingElement","SVGFESpotLightElement","SVGFETileElement","SVGFETurbulenceElement","SVGFilterElement","SVGFontElement","SVGFontFaceElement","SVGFontFaceFormatElement","SVGFontFaceNameElement","SVGFontFaceSrcElement","SVGFontFaceUriElement","SVGForeignObjectElement","SVGGElement","SVGGeometryElement","SVGGlyphElement","SVGGlyphRefElement","SVGGradientElement","SVGGraphicsElement","SVGHKernElement","SVGImageElement","SVGLength","SVGLengthList","SVGLineElement","SVGLinearGradientElement","SVGMPathElement","SVGMarkerElement","SVGMaskElement","SVGMatrix","SVGMetadataElement","SVGMissingGlyphElement","SVGNumber","SVGNumberList","SVGPaint","SVGPathElement","SVGPathSeg","SVGPathSegArcAbs","SVGPathSegArcRel","SVGPathSegClosePath","SVGPathSegCurvetoCubicAbs","SVGPathSegCurvetoCubicRel","SVGPathSegCurvetoCubicSmoothAbs","SVGPathSegCurvetoCubicSmoothRel","SVGPathSegCurvetoQuadraticAbs","SVGPathSegCurvetoQuadraticRel","SVGPathSegCurvetoQuadraticSmoothAbs","SVGPathSegCurvetoQuadraticSmoothRel","SVGPathSegLinetoAbs","SVGPathSegLinetoHorizontalAbs","SVGPathSegLinetoHorizontalRel","SVGPathSegLinetoRel","SVGPathSegLinetoVerticalAbs","SVGPathSegLinetoVerticalRel","SVGPathSegList","SVGPathSegMovetoAbs","SVGPathSegMovetoRel","SVGPatternElement","SVGPoint","SVGPointList","SVGPolygonElement","SVGPolylineElement","SVGPreserveAspectRatio","SVGRadialGradientElement","SVGRect","SVGRectElement","SVGRenderingIntent","SVGSVGElement","SVGScriptElement","SVGSetElement","SVGStopElement","SVGStringList","SVGStyleElement","SVGSwitchElement","SVGSymbolElement","SVGTRefElement","SVGTSpanElement","SVGTextContentElement","SVGTextElement","SVGTextPathElement","SVGTextPositioningElement","SVGTitleElement","SVGTransform","SVGTransformList","SVGUnitTypes","SVGUseElement","SVGVKernElement","SVGViewElement","SVGViewSpec","SVGZoomAndPan","SVGZoomEvent","SVG_ANGLETYPE_DEG","SVG_ANGLETYPE_GRAD","SVG_ANGLETYPE_RAD","SVG_ANGLETYPE_UNKNOWN","SVG_ANGLETYPE_UNSPECIFIED","SVG_CHANNEL_A","SVG_CHANNEL_B","SVG_CHANNEL_G","SVG_CHANNEL_R","SVG_CHANNEL_UNKNOWN","SVG_COLORTYPE_CURRENTCOLOR","SVG_COLORTYPE_RGBCOLOR","SVG_COLORTYPE_RGBCOLOR_ICCCOLOR","SVG_COLORTYPE_UNKNOWN","SVG_EDGEMODE_DUPLICATE","SVG_EDGEMODE_NONE","SVG_EDGEMODE_UNKNOWN","SVG_EDGEMODE_WRAP","SVG_FEBLEND_MODE_COLOR","SVG_FEBLEND_MODE_COLOR_BURN","SVG_FEBLEND_MODE_COLOR_DODGE","SVG_FEBLEND_MODE_DARKEN","SVG_FEBLEND_MODE_DIFFERENCE","SVG_FEBLEND_MODE_EXCLUSION","SVG_FEBLEND_MODE_HARD_LIGHT","SVG_FEBLEND_MODE_HUE","SVG_FEBLEND_MODE_LIGHTEN","SVG_FEBLEND_MODE_LUMINOSITY","SVG_FEBLEND_MODE_MULTIPLY","SVG_FEBLEND_MODE_NORMAL","SVG_FEBLEND_MODE_OVERLAY","SVG_FEBLEND_MODE_SATURATION","SVG_FEBLEND_MODE_SCREEN","SVG_FEBLEND_MODE_SOFT_LIGHT","SVG_FEBLEND_MODE_UNKNOWN","SVG_FECOLORMATRIX_TYPE_HUEROTATE","SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA","SVG_FECOLORMATRIX_TYPE_MATRIX","SVG_FECOLORMATRIX_TYPE_SATURATE","SVG_FECOLORMATRIX_TYPE_UNKNOWN","SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE","SVG_FECOMPONENTTRANSFER_TYPE_GAMMA","SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY","SVG_FECOMPONENTTRANSFER_TYPE_LINEAR","SVG_FECOMPONENTTRANSFER_TYPE_TABLE","SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN","SVG_FECOMPOSITE_OPERATOR_ARITHMETIC","SVG_FECOMPOSITE_OPERATOR_ATOP","SVG_FECOMPOSITE_OPERATOR_IN","SVG_FECOMPOSITE_OPERATOR_OUT","SVG_FECOMPOSITE_OPERATOR_OVER","SVG_FECOMPOSITE_OPERATOR_UNKNOWN","SVG_FECOMPOSITE_OPERATOR_XOR","SVG_INVALID_VALUE_ERR","SVG_LENGTHTYPE_CM","SVG_LENGTHTYPE_EMS","SVG_LENGTHTYPE_EXS","SVG_LENGTHTYPE_IN","SVG_LENGTHTYPE_MM","SVG_LENGTHTYPE_NUMBER","SVG_LENGTHTYPE_PC","SVG_LENGTHTYPE_PERCENTAGE","SVG_LENGTHTYPE_PT","SVG_LENGTHTYPE_PX","SVG_LENGTHTYPE_UNKNOWN","SVG_MARKERUNITS_STROKEWIDTH","SVG_MARKERUNITS_UNKNOWN","SVG_MARKERUNITS_USERSPACEONUSE","SVG_MARKER_ORIENT_ANGLE","SVG_MARKER_ORIENT_AUTO","SVG_MARKER_ORIENT_UNKNOWN","SVG_MASKTYPE_ALPHA","SVG_MASKTYPE_LUMINANCE","SVG_MATRIX_NOT_INVERTABLE","SVG_MEETORSLICE_MEET","SVG_MEETORSLICE_SLICE","SVG_MEETORSLICE_UNKNOWN","SVG_MORPHOLOGY_OPERATOR_DILATE","SVG_MORPHOLOGY_OPERATOR_ERODE","SVG_MORPHOLOGY_OPERATOR_UNKNOWN","SVG_PAINTTYPE_CURRENTCOLOR","SVG_PAINTTYPE_NONE","SVG_PAINTTYPE_RGBCOLOR","SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR","SVG_PAINTTYPE_UNKNOWN","SVG_PAINTTYPE_URI","SVG_PAINTTYPE_URI_CURRENTCOLOR","SVG_PAINTTYPE_URI_NONE","SVG_PAINTTYPE_URI_RGBCOLOR","SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR","SVG_PRESERVEASPECTRATIO_NONE","SVG_PRESERVEASPECTRATIO_UNKNOWN","SVG_PRESERVEASPECTRATIO_XMAXYMAX","SVG_PRESERVEASPECTRATIO_XMAXYMID","SVG_PRESERVEASPECTRATIO_XMAXYMIN","SVG_PRESERVEASPECTRATIO_XMIDYMAX","SVG_PRESERVEASPECTRATIO_XMIDYMID","SVG_PRESERVEASPECTRATIO_XMIDYMIN","SVG_PRESERVEASPECTRATIO_XMINYMAX","SVG_PRESERVEASPECTRATIO_XMINYMID","SVG_PRESERVEASPECTRATIO_XMINYMIN","SVG_SPREADMETHOD_PAD","SVG_SPREADMETHOD_REFLECT","SVG_SPREADMETHOD_REPEAT","SVG_SPREADMETHOD_UNKNOWN","SVG_STITCHTYPE_NOSTITCH","SVG_STITCHTYPE_STITCH","SVG_STITCHTYPE_UNKNOWN","SVG_TRANSFORM_MATRIX","SVG_TRANSFORM_ROTATE","SVG_TRANSFORM_SCALE","SVG_TRANSFORM_SKEWX","SVG_TRANSFORM_SKEWY","SVG_TRANSFORM_TRANSLATE","SVG_TRANSFORM_UNKNOWN","SVG_TURBULENCE_TYPE_FRACTALNOISE","SVG_TURBULENCE_TYPE_TURBULENCE","SVG_TURBULENCE_TYPE_UNKNOWN","SVG_UNIT_TYPE_OBJECTBOUNDINGBOX","SVG_UNIT_TYPE_UNKNOWN","SVG_UNIT_TYPE_USERSPACEONUSE","SVG_WRONG_TYPE_ERR","SVG_ZOOMANDPAN_DISABLE","SVG_ZOOMANDPAN_MAGNIFY","SVG_ZOOMANDPAN_UNKNOWN","SYNC_CONDITION","SYNC_FENCE","SYNC_FLAGS","SYNC_FLUSH_COMMANDS_BIT","SYNC_GPU_COMMANDS_COMPLETE","SYNC_STATUS","SYNTAX_ERR","SavedPages","Screen","ScreenOrientation","Script","ScriptProcessorNode","ScrollAreaEvent","SecurityPolicyViolationEvent","Selection","Sensor","SensorErrorEvent","ServiceWorker","ServiceWorkerContainer","ServiceWorkerRegistration","SessionDescription","Set","ShadowRoot","SharedArrayBuffer","SharedWorker","SimpleGestureEvent","SourceBuffer","SourceBufferList","SpeechSynthesis","SpeechSynthesisErrorEvent","SpeechSynthesisEvent","SpeechSynthesisUtterance","SpeechSynthesisVoice","StaticRange","StereoPannerNode","StopIteration","Storage","StorageEvent","StorageManager","String","StructType","StylePropertyMap","StylePropertyMapReadOnly","StyleSheet","StyleSheetList","SubmitEvent","SubtleCrypto","Symbol","SyncManager","SyntaxError","TEMPORARY","TEXTPATH_METHODTYPE_ALIGN","TEXTPATH_METHODTYPE_STRETCH","TEXTPATH_METHODTYPE_UNKNOWN","TEXTPATH_SPACINGTYPE_AUTO","TEXTPATH_SPACINGTYPE_EXACT","TEXTPATH_SPACINGTYPE_UNKNOWN","TEXTURE","TEXTURE0","TEXTURE1","TEXTURE10","TEXTURE11","TEXTURE12","TEXTURE13","TEXTURE14","TEXTURE15","TEXTURE16","TEXTURE17","TEXTURE18","TEXTURE19","TEXTURE2","TEXTURE20","TEXTURE21","TEXTURE22","TEXTURE23","TEXTURE24","TEXTURE25","TEXTURE26","TEXTURE27","TEXTURE28","TEXTURE29","TEXTURE3","TEXTURE30","TEXTURE31","TEXTURE4","TEXTURE5","TEXTURE6","TEXTURE7","TEXTURE8","TEXTURE9","TEXTURE_2D","TEXTURE_2D_ARRAY","TEXTURE_3D","TEXTURE_BASE_LEVEL","TEXTURE_BINDING_2D","TEXTURE_BINDING_2D_ARRAY","TEXTURE_BINDING_3D","TEXTURE_BINDING_CUBE_MAP","TEXTURE_COMPARE_FUNC","TEXTURE_COMPARE_MODE","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Z","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_IMMUTABLE_FORMAT","TEXTURE_IMMUTABLE_LEVELS","TEXTURE_MAG_FILTER","TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_MAX_LEVEL","TEXTURE_MAX_LOD","TEXTURE_MIN_FILTER","TEXTURE_MIN_LOD","TEXTURE_WRAP_R","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXT_NODE","TIMEOUT","TIMEOUT_ERR","TIMEOUT_EXPIRED","TIMEOUT_IGNORED","TOO_LARGE_ERR","TRANSACTION_INACTIVE_ERR","TRANSFORM_FEEDBACK","TRANSFORM_FEEDBACK_ACTIVE","TRANSFORM_FEEDBACK_BINDING","TRANSFORM_FEEDBACK_BUFFER","TRANSFORM_FEEDBACK_BUFFER_BINDING","TRANSFORM_FEEDBACK_BUFFER_MODE","TRANSFORM_FEEDBACK_BUFFER_SIZE","TRANSFORM_FEEDBACK_BUFFER_START","TRANSFORM_FEEDBACK_PAUSED","TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN","TRANSFORM_FEEDBACK_VARYINGS","TRIANGLE","TRIANGLES","TRIANGLE_FAN","TRIANGLE_STRIP","TYPE_BACK_FORWARD","TYPE_ERR","TYPE_MISMATCH_ERR","TYPE_NAVIGATE","TYPE_RELOAD","TYPE_RESERVED","Table","TaskAttributionTiming","Text","TextDecoder","TextDecoderStream","TextEncoder","TextEncoderStream","TextEvent","TextMetrics","TextTrack","TextTrackCue","TextTrackCueList","TextTrackList","TimeEvent","TimeRanges","Touch","TouchEvent","TouchList","TrackEvent","TransformStream","TransitionEvent","TreeWalker","TrustedHTML","TrustedScript","TrustedScriptURL","TrustedTypePolicy","TrustedTypePolicyFactory","TypeError","TypedObject","U2F","UIEvent","UNCACHED","UNIFORM_ARRAY_STRIDE","UNIFORM_BLOCK_ACTIVE_UNIFORMS","UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES","UNIFORM_BLOCK_BINDING","UNIFORM_BLOCK_DATA_SIZE","UNIFORM_BLOCK_INDEX","UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER","UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER","UNIFORM_BUFFER","UNIFORM_BUFFER_BINDING","UNIFORM_BUFFER_OFFSET_ALIGNMENT","UNIFORM_BUFFER_SIZE","UNIFORM_BUFFER_START","UNIFORM_IS_ROW_MAJOR","UNIFORM_MATRIX_STRIDE","UNIFORM_OFFSET","UNIFORM_SIZE","UNIFORM_TYPE","UNKNOWN_ERR","UNKNOWN_RULE","UNMASKED_RENDERER_WEBGL","UNMASKED_VENDOR_WEBGL","UNORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","UNPACK_FLIP_Y_WEBGL","UNPACK_IMAGE_HEIGHT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ROW_LENGTH","UNPACK_SKIP_IMAGES","UNPACK_SKIP_PIXELS","UNPACK_SKIP_ROWS","UNSCHEDULED_STATE","UNSENT","UNSIGNALED","UNSIGNED_BYTE","UNSIGNED_INT","UNSIGNED_INT_10F_11F_11F_REV","UNSIGNED_INT_24_8","UNSIGNED_INT_2_10_10_10_REV","UNSIGNED_INT_5_9_9_9_REV","UNSIGNED_INT_SAMPLER_2D","UNSIGNED_INT_SAMPLER_2D_ARRAY","UNSIGNED_INT_SAMPLER_3D","UNSIGNED_INT_SAMPLER_CUBE","UNSIGNED_INT_VEC2","UNSIGNED_INT_VEC3","UNSIGNED_INT_VEC4","UNSIGNED_NORMALIZED","UNSIGNED_SHORT","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","UNSPECIFIED_EVENT_TYPE_ERR","UPDATEREADY","URIError","URL","URLSearchParams","URLUnencoded","URL_MISMATCH_ERR","USB","USBAlternateInterface","USBConfiguration","USBConnectionEvent","USBDevice","USBEndpoint","USBInTransferResult","USBInterface","USBIsochronousInTransferPacket","USBIsochronousInTransferResult","USBIsochronousOutTransferPacket","USBIsochronousOutTransferResult","USBOutTransferResult","UTC","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","UserActivation","UserMessageHandler","UserMessageHandlersNamespace","UserProximityEvent","VALIDATE_STATUS","VALIDATION_ERR","VARIABLES_RULE","VENDOR","VERSION","VERSION_CHANGE","VERSION_ERR","VERTEX_ARRAY_BINDING","VERTEX_ATTRIB_ARRAY_BUFFER_BINDING","VERTEX_ATTRIB_ARRAY_DIVISOR","VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE","VERTEX_ATTRIB_ARRAY_ENABLED","VERTEX_ATTRIB_ARRAY_INTEGER","VERTEX_ATTRIB_ARRAY_NORMALIZED","VERTEX_ATTRIB_ARRAY_POINTER","VERTEX_ATTRIB_ARRAY_SIZE","VERTEX_ATTRIB_ARRAY_STRIDE","VERTEX_ATTRIB_ARRAY_TYPE","VERTEX_SHADER","VERTICAL","VERTICAL_AXIS","VER_ERR","VIEWPORT","VIEWPORT_RULE","VRDisplay","VRDisplayCapabilities","VRDisplayEvent","VREyeParameters","VRFieldOfView","VRFrameData","VRPose","VRStageParameters","VTTCue","VTTRegion","ValidityState","VideoPlaybackQuality","VideoStreamTrack","VisualViewport","WAIT_FAILED","WEBKIT_FILTER_RULE","WEBKIT_KEYFRAMES_RULE","WEBKIT_KEYFRAME_RULE","WEBKIT_REGION_RULE","WRONG_DOCUMENT_ERR","WakeLock","WakeLockSentinel","WasmAnyRef","WaveShaperNode","WeakMap","WeakRef","WeakSet","WebAssembly","WebGL2RenderingContext","WebGLActiveInfo","WebGLBuffer","WebGLContextEvent","WebGLFramebuffer","WebGLProgram","WebGLQuery","WebGLRenderbuffer","WebGLRenderingContext","WebGLSampler","WebGLShader","WebGLShaderPrecisionFormat","WebGLSync","WebGLTexture","WebGLTransformFeedback","WebGLUniformLocation","WebGLVertexArray","WebGLVertexArrayObject","WebKitAnimationEvent","WebKitBlobBuilder","WebKitCSSFilterRule","WebKitCSSFilterValue","WebKitCSSKeyframeRule","WebKitCSSKeyframesRule","WebKitCSSMatrix","WebKitCSSRegionRule","WebKitCSSTransformValue","WebKitDataCue","WebKitGamepad","WebKitMediaKeyError","WebKitMediaKeyMessageEvent","WebKitMediaKeySession","WebKitMediaKeys","WebKitMediaSource","WebKitMutationObserver","WebKitNamespace","WebKitPlaybackTargetAvailabilityEvent","WebKitPoint","WebKitShadowRoot","WebKitSourceBuffer","WebKitSourceBufferList","WebKitTransitionEvent","WebSocket","WebkitAlignContent","WebkitAlignItems","WebkitAlignSelf","WebkitAnimation","WebkitAnimationDelay","WebkitAnimationDirection","WebkitAnimationDuration","WebkitAnimationFillMode","WebkitAnimationIterationCount","WebkitAnimationName","WebkitAnimationPlayState","WebkitAnimationTimingFunction","WebkitAppearance","WebkitBackfaceVisibility","WebkitBackgroundClip","WebkitBackgroundOrigin","WebkitBackgroundSize","WebkitBorderBottomLeftRadius","WebkitBorderBottomRightRadius","WebkitBorderImage","WebkitBorderRadius","WebkitBorderTopLeftRadius","WebkitBorderTopRightRadius","WebkitBoxAlign","WebkitBoxDirection","WebkitBoxFlex","WebkitBoxOrdinalGroup","WebkitBoxOrient","WebkitBoxPack","WebkitBoxShadow","WebkitBoxSizing","WebkitFilter","WebkitFlex","WebkitFlexBasis","WebkitFlexDirection","WebkitFlexFlow","WebkitFlexGrow","WebkitFlexShrink","WebkitFlexWrap","WebkitJustifyContent","WebkitLineClamp","WebkitMask","WebkitMaskClip","WebkitMaskComposite","WebkitMaskImage","WebkitMaskOrigin","WebkitMaskPosition","WebkitMaskPositionX","WebkitMaskPositionY","WebkitMaskRepeat","WebkitMaskSize","WebkitOrder","WebkitPerspective","WebkitPerspectiveOrigin","WebkitTextFillColor","WebkitTextSizeAdjust","WebkitTextStroke","WebkitTextStrokeColor","WebkitTextStrokeWidth","WebkitTransform","WebkitTransformOrigin","WebkitTransformStyle","WebkitTransition","WebkitTransitionDelay","WebkitTransitionDuration","WebkitTransitionProperty","WebkitTransitionTimingFunction","WebkitUserSelect","WheelEvent","Window","Worker","Worklet","WritableStream","WritableStreamDefaultWriter","XMLDocument","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestException","XMLHttpRequestProgressEvent","XMLHttpRequestUpload","XMLSerializer","XMLStylesheetProcessingInstruction","XPathEvaluator","XPathException","XPathExpression","XPathNSResolver","XPathResult","XRBoundedReferenceSpace","XRDOMOverlayState","XRFrame","XRHitTestResult","XRHitTestSource","XRInputSource","XRInputSourceArray","XRInputSourceEvent","XRInputSourcesChangeEvent","XRLayer","XRPose","XRRay","XRReferenceSpace","XRReferenceSpaceEvent","XRRenderState","XRRigidTransform","XRSession","XRSessionEvent","XRSpace","XRSystem","XRTransientInputHitTestResult","XRTransientInputHitTestSource","XRView","XRViewerPose","XRViewport","XRWebGLLayer","XSLTProcessor","ZERO","_XD0M_","_YD0M_","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupSetter__","__opera","__proto__","_browserjsran","a","aLink","abbr","abort","aborted","abs","absolute","acceleration","accelerationIncludingGravity","accelerator","accept","acceptCharset","acceptNode","accessKey","accessKeyLabel","accuracy","acos","acosh","action","actionURL","actions","activated","active","activeCues","activeElement","activeSourceBuffers","activeSourceCount","activeTexture","activeVRDisplays","actualBoundingBoxAscent","actualBoundingBoxDescent","actualBoundingBoxLeft","actualBoundingBoxRight","add","addAll","addBehavior","addCandidate","addColorStop","addCue","addElement","addEventListener","addFilter","addFromString","addFromUri","addIceCandidate","addImport","addListener","addModule","addNamed","addPageRule","addPath","addPointer","addRange","addRegion","addRule","addSearchEngine","addSourceBuffer","addStream","addTextTrack","addTrack","addTransceiver","addWakeLockListener","added","addedNodes","additionalName","additiveSymbols","addons","address","addressLine","adoptNode","adoptedStyleSheets","adr","advance","after","album","alert","algorithm","align","align-content","align-items","align-self","alignContent","alignItems","alignSelf","alignmentBaseline","alinkColor","all","allSettled","allow","allowFullscreen","allowPaymentRequest","allowedDirections","allowedFeatures","allowedToPlay","allowsFeature","alpha","alt","altGraphKey","altHtml","altKey","altLeft","alternate","alternateSetting","alternates","altitude","altitudeAccuracy","amplitude","ancestorOrigins","anchor","anchorNode","anchorOffset","anchors","and","angle","angularAcceleration","angularVelocity","animVal","animate","animatedInstanceRoot","animatedNormalizedPathSegList","animatedPathSegList","animatedPoints","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","animationDelay","animationDirection","animationDuration","animationFillMode","animationIterationCount","animationName","animationPlayState","animationStartTime","animationTimingFunction","animationsPaused","anniversary","antialias","anticipatedRemoval","any","app","appCodeName","appMinorVersion","appName","appNotifications","appVersion","appearance","append","appendBuffer","appendChild","appendData","appendItem","appendMedium","appendNamed","appendRule","appendStream","appendWindowEnd","appendWindowStart","applets","applicationCache","applicationServerKey","apply","applyConstraints","applyElement","arc","arcTo","archive","areas","arguments","ariaAtomic","ariaAutoComplete","ariaBusy","ariaChecked","ariaColCount","ariaColIndex","ariaColSpan","ariaCurrent","ariaDescription","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaKeyShortcuts","ariaLabel","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaSelected","ariaSetSize","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","arrayBuffer","artist","artwork","as","asIntN","asUintN","asin","asinh","assert","assign","assignedElements","assignedNodes","assignedSlot","async","asyncIterator","atEnd","atan","atan2","atanh","atob","attachEvent","attachInternals","attachShader","attachShadow","attachments","attack","attestationObject","attrChange","attrName","attributeFilter","attributeName","attributeNamespace","attributeOldValue","attributeStyleMap","attributes","attribution","audioBitsPerSecond","audioTracks","audioWorklet","authenticatedSignedWrites","authenticatorData","autoIncrement","autobuffer","autocapitalize","autocomplete","autocorrect","autofocus","automationRate","autoplay","availHeight","availLeft","availTop","availWidth","availability","available","aversion","ax","axes","axis","ay","azimuth","b","back","backface-visibility","backfaceVisibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-position-x","background-position-y","background-repeat","background-size","backgroundAttachment","backgroundBlendMode","backgroundClip","backgroundColor","backgroundFetch","backgroundImage","backgroundOrigin","backgroundPosition","backgroundPositionX","backgroundPositionY","backgroundRepeat","backgroundSize","badInput","badge","balance","baseFrequencyX","baseFrequencyY","baseLatency","baseLayer","baseNode","baseOffset","baseURI","baseVal","baselineShift","battery","bday","before","beginElement","beginElementAt","beginPath","beginQuery","beginTransformFeedback","behavior","behaviorCookie","behaviorPart","behaviorUrns","beta","bezierCurveTo","bgColor","bgProperties","bias","big","bigint64","biguint64","binaryType","bind","bindAttribLocation","bindBuffer","bindBufferBase","bindBufferRange","bindFramebuffer","bindRenderbuffer","bindSampler","bindTexture","bindTransformFeedback","bindVertexArray","blendColor","blendEquation","blendEquationSeparate","blendFunc","blendFuncSeparate","blink","blitFramebuffer","blob","block-size","blockDirection","blockSize","blockedURI","blue","bluetooth","blur","body","bodyUsed","bold","bookmarks","booleanValue","border","border-block","border-block-color","border-block-end","border-block-end-color","border-block-end-style","border-block-end-width","border-block-start","border-block-start-color","border-block-start-style","border-block-start-width","border-block-style","border-block-width","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-end-end-radius","border-end-start-radius","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-inline","border-inline-color","border-inline-end","border-inline-end-color","border-inline-end-style","border-inline-end-width","border-inline-start","border-inline-start-color","border-inline-start-style","border-inline-start-width","border-inline-style","border-inline-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-start-end-radius","border-start-start-radius","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","borderBlock","borderBlockColor","borderBlockEnd","borderBlockEndColor","borderBlockEndStyle","borderBlockEndWidth","borderBlockStart","borderBlockStartColor","borderBlockStartStyle","borderBlockStartWidth","borderBlockStyle","borderBlockWidth","borderBottom","borderBottomColor","borderBottomLeftRadius","borderBottomRightRadius","borderBottomStyle","borderBottomWidth","borderBoxSize","borderCollapse","borderColor","borderColorDark","borderColorLight","borderEndEndRadius","borderEndStartRadius","borderImage","borderImageOutset","borderImageRepeat","borderImageSlice","borderImageSource","borderImageWidth","borderInline","borderInlineColor","borderInlineEnd","borderInlineEndColor","borderInlineEndStyle","borderInlineEndWidth","borderInlineStart","borderInlineStartColor","borderInlineStartStyle","borderInlineStartWidth","borderInlineStyle","borderInlineWidth","borderLeft","borderLeftColor","borderLeftStyle","borderLeftWidth","borderRadius","borderRight","borderRightColor","borderRightStyle","borderRightWidth","borderSpacing","borderStartEndRadius","borderStartStartRadius","borderStyle","borderTop","borderTopColor","borderTopLeftRadius","borderTopRightRadius","borderTopStyle","borderTopWidth","borderWidth","bottom","bottomMargin","bound","boundElements","boundingClientRect","boundingHeight","boundingLeft","boundingTop","boundingWidth","bounds","boundsGeometry","box-decoration-break","box-shadow","box-sizing","boxDecorationBreak","boxShadow","boxSizing","break-after","break-before","break-inside","breakAfter","breakBefore","breakInside","broadcast","browserLanguage","btoa","bubbles","buffer","bufferData","bufferDepth","bufferSize","bufferSubData","buffered","bufferedAmount","bufferedAmountLowThreshold","buildID","buildNumber","button","buttonID","buttons","byteLength","byteOffset","bytesWritten","c","cache","caches","call","caller","canBeFormatted","canBeMounted","canBeShared","canHaveChildren","canHaveHTML","canInsertDTMF","canMakePayment","canPlayType","canPresent","canTrickleIceCandidates","cancel","cancelAndHoldAtTime","cancelAnimationFrame","cancelBubble","cancelIdleCallback","cancelScheduledValues","cancelVideoFrameCallback","cancelWatchAvailability","cancelable","candidate","canonicalUUID","canvas","capabilities","caption","caption-side","captionSide","capture","captureEvents","captureStackTrace","captureStream","caret-color","caretBidiLevel","caretColor","caretPositionFromPoint","caretRangeFromPoint","cast","catch","category","cbrt","cd","ceil","cellIndex","cellPadding","cellSpacing","cells","ch","chOff","chain","challenge","changeType","changedTouches","channel","channelCount","channelCountMode","channelInterpretation","char","charAt","charCode","charCodeAt","charIndex","charLength","characterData","characterDataOldValue","characterSet","characteristic","charging","chargingTime","charset","check","checkEnclosure","checkFramebufferStatus","checkIntersection","checkValidity","checked","childElementCount","childList","childNodes","children","chrome","ciphertext","cite","city","claimInterface","claimed","classList","className","classid","clear","clearAppBadge","clearAttributes","clearBufferfi","clearBufferfv","clearBufferiv","clearBufferuiv","clearColor","clearData","clearDepth","clearHalt","clearImmediate","clearInterval","clearLiveSeekableRange","clearMarks","clearMaxGCPauseAccumulator","clearMeasures","clearParameters","clearRect","clearResourceTimings","clearShadow","clearStencil","clearTimeout","clearWatch","click","clickCount","clientDataJSON","clientHeight","clientInformation","clientLeft","clientRect","clientRects","clientTop","clientWaitSync","clientWidth","clientX","clientY","clip","clip-path","clip-rule","clipBottom","clipLeft","clipPath","clipPathUnits","clipRight","clipRule","clipTop","clipboard","clipboardData","clone","cloneContents","cloneNode","cloneRange","close","closePath","closed","closest","clz","clz32","cm","cmp","code","codeBase","codePointAt","codeType","colSpan","collapse","collapseToEnd","collapseToStart","collapsed","collect","colno","color","color-adjust","color-interpolation","color-interpolation-filters","colorAdjust","colorDepth","colorInterpolation","colorInterpolationFilters","colorMask","colorType","cols","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columnCount","columnFill","columnGap","columnNumber","columnRule","columnRuleColor","columnRuleStyle","columnRuleWidth","columnSpan","columnWidth","columns","command","commit","commitPreferences","commitStyles","commonAncestorContainer","compact","compareBoundaryPoints","compareDocumentPosition","compareEndPoints","compareExchange","compareNode","comparePoint","compatMode","compatible","compile","compileShader","compileStreaming","complete","component","componentFromPoint","composed","composedPath","composite","compositionEndOffset","compositionStartOffset","compressedTexImage2D","compressedTexImage3D","compressedTexSubImage2D","compressedTexSubImage3D","computedStyleMap","concat","conditionText","coneInnerAngle","coneOuterAngle","coneOuterGain","configuration","configurationName","configurationValue","configurations","confirm","confirmComposition","confirmSiteSpecificTrackingException","confirmWebWideTrackingException","connect","connectEnd","connectShark","connectStart","connected","connection","connectionList","connectionSpeed","connectionState","connections","console","consolidate","constraint","constrictionActive","construct","constructor","contactID","contain","containerId","containerName","containerSrc","containerType","contains","containsNode","content","contentBoxSize","contentDocument","contentEditable","contentHint","contentOverflow","contentRect","contentScriptType","contentStyleType","contentType","contentWindow","context","contextMenu","contextmenu","continue","continuePrimaryKey","continuous","control","controlTransferIn","controlTransferOut","controller","controls","controlsList","convertPointFromNode","convertQuadFromNode","convertRectFromNode","convertToBlob","convertToSpecifiedUnits","cookie","cookieEnabled","coords","copyBufferSubData","copyFromChannel","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","copyToChannel","copyWithin","correspondingElement","correspondingUseElement","corruptedVideoFrames","cos","cosh","count","countReset","counter-increment","counter-reset","counter-set","counterIncrement","counterReset","counterSet","country","cpuClass","cpuSleepAllowed","create","createAnalyser","createAnswer","createAttribute","createAttributeNS","createBiquadFilter","createBuffer","createBufferSource","createCDATASection","createCSSStyleSheet","createCaption","createChannelMerger","createChannelSplitter","createComment","createConstantSource","createContextualFragment","createControlRange","createConvolver","createDTMFSender","createDataChannel","createDelay","createDelayNode","createDocument","createDocumentFragment","createDocumentType","createDynamicsCompressor","createElement","createElementNS","createEntityReference","createEvent","createEventObject","createExpression","createFramebuffer","createFunction","createGain","createGainNode","createHTML","createHTMLDocument","createIIRFilter","createImageBitmap","createImageData","createIndex","createJavaScriptNode","createLinearGradient","createMediaElementSource","createMediaKeys","createMediaStreamDestination","createMediaStreamSource","createMediaStreamTrackSource","createMutableFile","createNSResolver","createNodeIterator","createNotification","createObjectStore","createObjectURL","createOffer","createOscillator","createPanner","createPattern","createPeriodicWave","createPolicy","createPopup","createProcessingInstruction","createProgram","createQuery","createRadialGradient","createRange","createRangeCollection","createReader","createRenderbuffer","createSVGAngle","createSVGLength","createSVGMatrix","createSVGNumber","createSVGPathSegArcAbs","createSVGPathSegArcRel","createSVGPathSegClosePath","createSVGPathSegCurvetoCubicAbs","createSVGPathSegCurvetoCubicRel","createSVGPathSegCurvetoCubicSmoothAbs","createSVGPathSegCurvetoCubicSmoothRel","createSVGPathSegCurvetoQuadraticAbs","createSVGPathSegCurvetoQuadraticRel","createSVGPathSegCurvetoQuadraticSmoothAbs","createSVGPathSegCurvetoQuadraticSmoothRel","createSVGPathSegLinetoAbs","createSVGPathSegLinetoHorizontalAbs","createSVGPathSegLinetoHorizontalRel","createSVGPathSegLinetoRel","createSVGPathSegLinetoVerticalAbs","createSVGPathSegLinetoVerticalRel","createSVGPathSegMovetoAbs","createSVGPathSegMovetoRel","createSVGPoint","createSVGRect","createSVGTransform","createSVGTransformFromMatrix","createSampler","createScript","createScriptProcessor","createScriptURL","createSession","createShader","createShadowRoot","createStereoPanner","createStyleSheet","createTBody","createTFoot","createTHead","createTextNode","createTextRange","createTexture","createTouch","createTouchList","createTransformFeedback","createTreeWalker","createVertexArray","createWaveShaper","creationTime","credentials","crossOrigin","crossOriginIsolated","crypto","csi","csp","cssFloat","cssRules","cssText","cssValueType","ctrlKey","ctrlLeft","cues","cullFace","currentDirection","currentLocalDescription","currentNode","currentPage","currentRect","currentRemoteDescription","currentScale","currentScript","currentSrc","currentState","currentStyle","currentTarget","currentTime","currentTranslate","currentView","cursor","curve","customElements","customError","cx","cy","d","data","dataFld","dataFormatAs","dataLoss","dataLossMessage","dataPageSize","dataSrc","dataTransfer","database","databases","dataset","dateTime","db","debug","debuggerEnabled","declare","decode","decodeAudioData","decodeURI","decodeURIComponent","decodedBodySize","decoding","decodingInfo","decrypt","default","defaultCharset","defaultChecked","defaultMuted","defaultPlaybackRate","defaultPolicy","defaultPrevented","defaultRequest","defaultSelected","defaultStatus","defaultURL","defaultValue","defaultView","defaultstatus","defer","define","defineMagicFunction","defineMagicVariable","defineProperties","defineProperty","deg","delay","delayTime","delegatesFocus","delete","deleteBuffer","deleteCaption","deleteCell","deleteContents","deleteData","deleteDatabase","deleteFramebuffer","deleteFromDocument","deleteIndex","deleteMedium","deleteObjectStore","deleteProgram","deleteProperty","deleteQuery","deleteRenderbuffer","deleteRow","deleteRule","deleteSampler","deleteShader","deleteSync","deleteTFoot","deleteTHead","deleteTexture","deleteTransformFeedback","deleteVertexArray","deliverChangeRecords","delivery","deliveryInfo","deliveryStatus","deliveryTimestamp","delta","deltaMode","deltaX","deltaY","deltaZ","dependentLocality","depthFar","depthFunc","depthMask","depthNear","depthRange","deref","deriveBits","deriveKey","description","deselectAll","designMode","desiredSize","destination","destinationURL","detach","detachEvent","detachShader","detail","details","detect","detune","device","deviceClass","deviceId","deviceMemory","devicePixelContentBoxSize","devicePixelRatio","deviceProtocol","deviceSubclass","deviceVersionMajor","deviceVersionMinor","deviceVersionSubminor","deviceXDPI","deviceYDPI","didTimeout","diffuseConstant","digest","dimensions","dir","dirName","direction","dirxml","disable","disablePictureInPicture","disableRemotePlayback","disableVertexAttribArray","disabled","dischargingTime","disconnect","disconnectShark","dispatchEvent","display","displayId","displayName","disposition","distanceModel","div","divisor","djsapi","djsproxy","doImport","doNotTrack","doScroll","doctype","document","documentElement","documentMode","documentURI","dolphin","dolphinGameCenter","dolphininfo","dolphinmeta","domComplete","domContentLoadedEventEnd","domContentLoadedEventStart","domInteractive","domLoading","domOverlayState","domain","domainLookupEnd","domainLookupStart","dominant-baseline","dominantBaseline","done","dopplerFactor","dotAll","downDegrees","downlink","download","downloadTotal","downloaded","dpcm","dpi","dppx","dragDrop","draggable","drawArrays","drawArraysInstanced","drawArraysInstancedANGLE","drawBuffers","drawCustomFocusRing","drawElements","drawElementsInstanced","drawElementsInstancedANGLE","drawFocusIfNeeded","drawImage","drawImageFromRect","drawRangeElements","drawSystemFocusRing","drawingBufferHeight","drawingBufferWidth","dropEffect","droppedVideoFrames","dropzone","dtmf","dump","dumpProfile","duplicate","durability","duration","dvname","dvnum","dx","dy","dynsrc","e","edgeMode","effect","effectAllowed","effectiveDirective","effectiveType","elapsedTime","element","elementFromPoint","elementTiming","elements","elementsFromPoint","elevation","ellipse","em","email","embeds","emma","empty","empty-cells","emptyCells","emptyHTML","emptyScript","emulatedPosition","enable","enableBackground","enableDelegations","enableStyleSheetsForSet","enableVertexAttribArray","enabled","enabledPlugin","encode","encodeInto","encodeURI","encodeURIComponent","encodedBodySize","encoding","encodingInfo","encrypt","enctype","end","endContainer","endElement","endElementAt","endOfStream","endOffset","endQuery","endTime","endTransformFeedback","ended","endpoint","endpointNumber","endpoints","endsWith","enterKeyHint","entities","entries","entryType","enumerate","enumerateDevices","enumerateEditable","environmentBlendMode","equals","error","errorCode","errorDetail","errorText","escape","estimate","eval","evaluate","event","eventPhase","every","ex","exception","exchange","exec","execCommand","execCommandShowHelp","execScript","exitFullscreen","exitPictureInPicture","exitPointerLock","exitPresent","exp","expand","expandEntityReferences","expando","expansion","expiration","expirationTime","expires","expiryDate","explicitOriginalTarget","expm1","exponent","exponentialRampToValueAtTime","exportKey","extend","extensions","extentNode","extentOffset","external","externalResourcesRequired","extractContents","extractable","eye","f","face","factoryReset","failureReason","fallback","family","familyName","farthestViewportElement","fastSeek","fatal","featureId","featurePolicy","featureSettings","features","fenceSync","fetch","fetchStart","fftSize","fgColor","fieldOfView","file","fileCreatedDate","fileHandle","fileModifiedDate","fileName","fileSize","fileUpdatedDate","filename","files","filesystem","fill","fill-opacity","fill-rule","fillLightMode","fillOpacity","fillRect","fillRule","fillStyle","fillText","filter","filterResX","filterResY","filterUnits","filters","finally","find","findIndex","findRule","findText","finish","finished","fireEvent","firesTouchEvents","firstChild","firstElementChild","firstPage","fixed","flags","flat","flatMap","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","flexBasis","flexDirection","flexFlow","flexGrow","flexShrink","flexWrap","flipX","flipY","float","float32","float64","flood-color","flood-opacity","floodColor","floodOpacity","floor","flush","focus","focusNode","focusOffset","font","font-family","font-feature-settings","font-kerning","font-language-override","font-optical-sizing","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-variation-settings","font-weight","fontFamily","fontFeatureSettings","fontKerning","fontLanguageOverride","fontOpticalSizing","fontSize","fontSizeAdjust","fontSmoothingEnabled","fontStretch","fontStyle","fontSynthesis","fontVariant","fontVariantAlternates","fontVariantCaps","fontVariantEastAsian","fontVariantLigatures","fontVariantNumeric","fontVariantPosition","fontVariationSettings","fontWeight","fontcolor","fontfaces","fonts","fontsize","for","forEach","force","forceRedraw","form","formAction","formData","formEnctype","formMethod","formNoValidate","formTarget","format","formatToParts","forms","forward","forwardX","forwardY","forwardZ","foundation","fr","fragmentDirective","frame","frameBorder","frameElement","frameSpacing","framebuffer","framebufferHeight","framebufferRenderbuffer","framebufferTexture2D","framebufferTextureLayer","framebufferWidth","frames","freeSpace","freeze","frequency","frequencyBinCount","from","fromCharCode","fromCodePoint","fromElement","fromEntries","fromFloat32Array","fromFloat64Array","fromMatrix","fromPoint","fromQuad","fromRect","frontFace","fround","fullPath","fullScreen","fullscreen","fullscreenElement","fullscreenEnabled","fx","fy","gain","gamepad","gamma","gap","gatheringState","gatt","genderIdentity","generateCertificate","generateKey","generateMipmap","generateRequest","geolocation","gestureObject","get","getActiveAttrib","getActiveUniform","getActiveUniformBlockName","getActiveUniformBlockParameter","getActiveUniforms","getAdjacentText","getAll","getAllKeys","getAllResponseHeaders","getAllowlistForFeature","getAnimations","getAsFile","getAsString","getAttachedShaders","getAttribLocation","getAttribute","getAttributeNS","getAttributeNames","getAttributeNode","getAttributeNodeNS","getAttributeType","getAudioTracks","getAvailability","getBBox","getBattery","getBigInt64","getBigUint64","getBlob","getBookmark","getBoundingClientRect","getBounds","getBoxQuads","getBufferParameter","getBufferSubData","getByteFrequencyData","getByteTimeDomainData","getCSSCanvasContext","getCTM","getCandidateWindowClientRect","getCanonicalLocales","getCapabilities","getChannelData","getCharNumAtPosition","getCharacteristic","getCharacteristics","getClientExtensionResults","getClientRect","getClientRects","getCoalescedEvents","getCompositionAlternatives","getComputedStyle","getComputedTextLength","getComputedTiming","getConfiguration","getConstraints","getContext","getContextAttributes","getContributingSources","getCounterValue","getCueAsHTML","getCueById","getCurrentPosition","getCurrentTime","getData","getDatabaseNames","getDate","getDay","getDefaultComputedStyle","getDescriptor","getDescriptors","getDestinationInsertionPoints","getDevices","getDirectory","getDisplayMedia","getDistributedNodes","getEditable","getElementById","getElementsByClassName","getElementsByName","getElementsByTagName","getElementsByTagNameNS","getEnclosureList","getEndPositionOfChar","getEntries","getEntriesByName","getEntriesByType","getError","getExtension","getExtentOfChar","getEyeParameters","getFeature","getFile","getFiles","getFilesAndDirectories","getFingerprints","getFloat32","getFloat64","getFloatFrequencyData","getFloatTimeDomainData","getFloatValue","getFragDataLocation","getFrameData","getFramebufferAttachmentParameter","getFrequencyResponse","getFullYear","getGamepads","getHitTestResults","getHitTestResultsForTransientInput","getHours","getIdentityAssertion","getIds","getImageData","getIndexedParameter","getInstalledRelatedApps","getInt16","getInt32","getInt8","getInternalformatParameter","getIntersectionList","getItem","getItems","getKey","getKeyframes","getLayers","getLayoutMap","getLineDash","getLocalCandidates","getLocalParameters","getLocalStreams","getMarks","getMatchedCSSRules","getMaxGCPauseSinceClear","getMeasures","getMetadata","getMilliseconds","getMinutes","getModifierState","getMonth","getNamedItem","getNamedItemNS","getNativeFramebufferScaleFactor","getNotifications","getNotifier","getNumberOfChars","getOffsetReferenceSpace","getOutputTimestamp","getOverrideHistoryNavigationMode","getOverrideStyle","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getOwnPropertyNames","getOwnPropertySymbols","getParameter","getParameters","getParent","getPathSegAtLength","getPhotoCapabilities","getPhotoSettings","getPointAtLength","getPose","getPredictedEvents","getPreference","getPreferenceDefault","getPresentationAttribute","getPreventDefault","getPrimaryService","getPrimaryServices","getProgramInfoLog","getProgramParameter","getPropertyCSSValue","getPropertyPriority","getPropertyShorthand","getPropertyType","getPropertyValue","getPrototypeOf","getQuery","getQueryParameter","getRGBColorValue","getRandomValues","getRangeAt","getReader","getReceivers","getRectValue","getRegistration","getRegistrations","getRemoteCandidates","getRemoteCertificates","getRemoteParameters","getRemoteStreams","getRenderbufferParameter","getResponseHeader","getRoot","getRootNode","getRotationOfChar","getSVGDocument","getSamplerParameter","getScreenCTM","getSeconds","getSelectedCandidatePair","getSelection","getSenders","getService","getSettings","getShaderInfoLog","getShaderParameter","getShaderPrecisionFormat","getShaderSource","getSimpleDuration","getSiteIcons","getSources","getSpeculativeParserUrls","getStartPositionOfChar","getStartTime","getState","getStats","getStatusForPolicy","getStorageUpdates","getStreamById","getStringValue","getSubStringLength","getSubscription","getSupportedConstraints","getSupportedExtensions","getSupportedFormats","getSyncParameter","getSynchronizationSources","getTags","getTargetRanges","getTexParameter","getTime","getTimezoneOffset","getTiming","getTotalLength","getTrackById","getTracks","getTransceivers","getTransform","getTransformFeedbackVarying","getTransformToElement","getTransports","getType","getTypeMapping","getUTCDate","getUTCDay","getUTCFullYear","getUTCHours","getUTCMilliseconds","getUTCMinutes","getUTCMonth","getUTCSeconds","getUint16","getUint32","getUint8","getUniform","getUniformBlockIndex","getUniformIndices","getUniformLocation","getUserMedia","getVRDisplays","getValues","getVarDate","getVariableValue","getVertexAttrib","getVertexAttribOffset","getVideoPlaybackQuality","getVideoTracks","getViewerPose","getViewport","getVoices","getWakeLockState","getWriter","getYear","givenName","global","globalAlpha","globalCompositeOperation","globalThis","glyphOrientationHorizontal","glyphOrientationVertical","glyphRef","go","grabFrame","grad","gradientTransform","gradientUnits","grammars","green","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-rows","grid-column","grid-column-end","grid-column-gap","grid-column-start","grid-gap","grid-row","grid-row-end","grid-row-gap","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","gridArea","gridAutoColumns","gridAutoFlow","gridAutoRows","gridColumn","gridColumnEnd","gridColumnGap","gridColumnStart","gridGap","gridRow","gridRowEnd","gridRowGap","gridRowStart","gridTemplate","gridTemplateAreas","gridTemplateColumns","gridTemplateRows","gripSpace","group","groupCollapsed","groupEnd","groupId","hadRecentInput","hand","handedness","hapticActuators","hardwareConcurrency","has","hasAttribute","hasAttributeNS","hasAttributes","hasBeenActive","hasChildNodes","hasComposition","hasEnrolledInstrument","hasExtension","hasExternalDisplay","hasFeature","hasFocus","hasInstance","hasLayout","hasOrientation","hasOwnProperty","hasPointerCapture","hasPosition","hasReading","hasStorageAccess","hash","head","headers","heading","height","hidden","hide","hideFocus","high","highWaterMark","hint","history","honorificPrefix","honorificSuffix","horizontalOverflow","host","hostCandidate","hostname","href","hrefTranslate","hreflang","hspace","html5TagCheckInerface","htmlFor","htmlText","httpEquiv","httpRequestStatusCode","hwTimestamp","hyphens","hypot","iccId","iceConnectionState","iceGatheringState","iceTransport","icon","iconURL","id","identifier","identity","idpLoginUrl","ignoreBOM","ignoreCase","ignoreDepthValues","image-orientation","image-rendering","imageHeight","imageOrientation","imageRendering","imageSizes","imageSmoothingEnabled","imageSmoothingQuality","imageSrcset","imageWidth","images","ime-mode","imeMode","implementation","importKey","importNode","importStylesheet","imports","impp","imul","in","in1","in2","inBandMetadataTrackDispatchType","inRange","includes","incremental","indeterminate","index","indexNames","indexOf","indexedDB","indicate","inertiaDestinationX","inertiaDestinationY","info","init","initAnimationEvent","initBeforeLoadEvent","initClipboardEvent","initCloseEvent","initCommandEvent","initCompositionEvent","initCustomEvent","initData","initDataType","initDeviceMotionEvent","initDeviceOrientationEvent","initDragEvent","initErrorEvent","initEvent","initFocusEvent","initGestureEvent","initHashChangeEvent","initKeyEvent","initKeyboardEvent","initMSManipulationEvent","initMessageEvent","initMouseEvent","initMouseScrollEvent","initMouseWheelEvent","initMutationEvent","initNSMouseEvent","initOverflowEvent","initPageEvent","initPageTransitionEvent","initPointerEvent","initPopStateEvent","initProgressEvent","initScrollAreaEvent","initSimpleGestureEvent","initStorageEvent","initTextEvent","initTimeEvent","initTouchEvent","initTransitionEvent","initUIEvent","initWebKitAnimationEvent","initWebKitTransitionEvent","initWebKitWheelEvent","initWheelEvent","initialTime","initialize","initiatorType","inline-size","inlineSize","inlineVerticalFieldOfView","inner","innerHTML","innerHeight","innerText","innerWidth","input","inputBuffer","inputEncoding","inputMethod","inputMode","inputSource","inputSources","inputType","inputs","insertAdjacentElement","insertAdjacentHTML","insertAdjacentText","insertBefore","insertCell","insertDTMF","insertData","insertItemBefore","insertNode","insertRow","insertRule","inset","inset-block","inset-block-end","inset-block-start","inset-inline","inset-inline-end","inset-inline-start","insetBlock","insetBlockEnd","insetBlockStart","insetInline","insetInlineEnd","insetInlineStart","installing","instanceRoot","instantiate","instantiateStreaming","instruments","int16","int32","int8","integrity","interactionMode","intercept","interfaceClass","interfaceName","interfaceNumber","interfaceProtocol","interfaceSubclass","interfaces","interimResults","internalSubset","interpretation","intersectionRatio","intersectionRect","intersectsNode","interval","invalidIteratorState","invalidateFramebuffer","invalidateSubFramebuffer","inverse","invertSelf","is","is2D","isActive","isAlternate","isArray","isBingCurrentSearchDefault","isBuffer","isCandidateWindowVisible","isChar","isCollapsed","isComposing","isConcatSpreadable","isConnected","isContentEditable","isContentHandlerRegistered","isContextLost","isDefaultNamespace","isDirectory","isDisabled","isEnabled","isEqual","isEqualNode","isExtensible","isExternalCTAP2SecurityKeySupported","isFile","isFinite","isFramebuffer","isFrozen","isGenerator","isHTML","isHistoryNavigation","isId","isIdentity","isInjected","isInteger","isIntersecting","isLockFree","isMap","isMultiLine","isNaN","isOpen","isPointInFill","isPointInPath","isPointInRange","isPointInStroke","isPrefAlternate","isPresenting","isPrimary","isProgram","isPropertyImplicit","isProtocolHandlerRegistered","isPrototypeOf","isQuery","isRenderbuffer","isSafeInteger","isSameNode","isSampler","isScript","isScriptURL","isSealed","isSecureContext","isSessionSupported","isShader","isSupported","isSync","isTextEdit","isTexture","isTransformFeedback","isTrusted","isTypeSupported","isUserVerifyingPlatformAuthenticatorAvailable","isVertexArray","isView","isVisible","isochronousTransferIn","isochronousTransferOut","isolation","italics","item","itemId","itemProp","itemRef","itemScope","itemType","itemValue","items","iterateNext","iterationComposite","iterator","javaEnabled","jobTitle","join","json","justify-content","justify-items","justify-self","justifyContent","justifyItems","justifySelf","k1","k2","k3","k4","kHz","keepalive","kernelMatrix","kernelUnitLengthX","kernelUnitLengthY","kerning","key","keyCode","keyFor","keyIdentifier","keyLightEnabled","keyLocation","keyPath","keyStatuses","keySystem","keyText","keyUsage","keyboard","keys","keytype","kind","knee","label","labels","lang","language","languages","largeArcFlag","lastChild","lastElementChild","lastEventId","lastIndex","lastIndexOf","lastInputTime","lastMatch","lastMessageSubject","lastMessageType","lastModified","lastModifiedDate","lastPage","lastParen","lastState","lastStyleSheetSet","latitude","layerX","layerY","layoutFlow","layoutGrid","layoutGridChar","layoutGridLine","layoutGridMode","layoutGridType","lbound","left","leftContext","leftDegrees","leftMargin","leftProjectionMatrix","leftViewMatrix","length","lengthAdjust","lengthComputable","letter-spacing","letterSpacing","level","lighting-color","lightingColor","limitingConeAngle","line","line-break","line-height","lineAlign","lineBreak","lineCap","lineDashOffset","lineHeight","lineJoin","lineNumber","lineTo","lineWidth","linearAcceleration","linearRampToValueAtTime","linearVelocity","lineno","lines","link","linkColor","linkProgram","links","list","list-style","list-style-image","list-style-position","list-style-type","listStyle","listStyleImage","listStylePosition","listStyleType","listener","load","loadEventEnd","loadEventStart","loadTime","loadTimes","loaded","loading","localDescription","localName","localService","localStorage","locale","localeCompare","location","locationbar","lock","locked","lockedFile","locks","log","log10","log1p","log2","logicalXDPI","logicalYDPI","longDesc","longitude","lookupNamespaceURI","lookupPrefix","loop","loopEnd","loopStart","looping","low","lower","lowerBound","lowerOpen","lowsrc","m11","m12","m13","m14","m21","m22","m23","m24","m31","m32","m33","m34","m41","m42","m43","m44","makeXRCompatible","manifest","manufacturer","manufacturerName","map","mapping","margin","margin-block","margin-block-end","margin-block-start","margin-bottom","margin-inline","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","marginBlock","marginBlockEnd","marginBlockStart","marginBottom","marginHeight","marginInline","marginInlineEnd","marginInlineStart","marginLeft","marginRight","marginTop","marginWidth","mark","marker","marker-end","marker-mid","marker-offset","marker-start","markerEnd","markerHeight","markerMid","markerOffset","markerStart","markerUnits","markerWidth","marks","mask","mask-clip","mask-composite","mask-image","mask-mode","mask-origin","mask-position","mask-position-x","mask-position-y","mask-repeat","mask-size","mask-type","maskClip","maskComposite","maskContentUnits","maskImage","maskMode","maskOrigin","maskPosition","maskPositionX","maskPositionY","maskRepeat","maskSize","maskType","maskUnits","match","matchAll","matchMedia","matchMedium","matches","matrix","matrixTransform","max","max-block-size","max-height","max-inline-size","max-width","maxActions","maxAlternatives","maxBlockSize","maxChannelCount","maxChannels","maxConnectionsPerServer","maxDecibels","maxDistance","maxHeight","maxInlineSize","maxLayers","maxLength","maxMessageSize","maxPacketLifeTime","maxRetransmits","maxTouchPoints","maxValue","maxWidth","measure","measureText","media","mediaCapabilities","mediaDevices","mediaElement","mediaGroup","mediaKeys","mediaSession","mediaStream","mediaText","meetOrSlice","memory","menubar","mergeAttributes","message","messageClass","messageHandlers","messageType","metaKey","metadata","method","methodDetails","methodName","mid","mimeType","mimeTypes","min","min-block-size","min-height","min-inline-size","min-width","minBlockSize","minDecibels","minHeight","minInlineSize","minLength","minValue","minWidth","miterLimit","mix-blend-mode","mixBlendMode","mm","mode","modify","mount","move","moveBy","moveEnd","moveFirst","moveFocusDown","moveFocusLeft","moveFocusRight","moveFocusUp","moveNext","moveRow","moveStart","moveTo","moveToBookmark","moveToElementText","moveToPoint","movementX","movementY","mozAdd","mozAnimationStartTime","mozAnon","mozApps","mozAudioCaptured","mozAudioChannelType","mozAutoplayEnabled","mozCancelAnimationFrame","mozCancelFullScreen","mozCancelRequestAnimationFrame","mozCaptureStream","mozCaptureStreamUntilEnded","mozClearDataAt","mozContact","mozContacts","mozCreateFileHandle","mozCurrentTransform","mozCurrentTransformInverse","mozCursor","mozDash","mozDashOffset","mozDecodedFrames","mozExitPointerLock","mozFillRule","mozFragmentEnd","mozFrameDelay","mozFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozGetAll","mozGetAllKeys","mozGetAsFile","mozGetDataAt","mozGetMetadata","mozGetUserMedia","mozHasAudio","mozHasItem","mozHidden","mozImageSmoothingEnabled","mozIndexedDB","mozInnerScreenX","mozInnerScreenY","mozInputSource","mozIsTextField","mozItem","mozItemCount","mozItems","mozLength","mozLockOrientation","mozMatchesSelector","mozMovementX","mozMovementY","mozOpaque","mozOrientation","mozPaintCount","mozPaintedFrames","mozParsedFrames","mozPay","mozPointerLockElement","mozPresentedFrames","mozPreservesPitch","mozPressure","mozPrintCallback","mozRTCIceCandidate","mozRTCPeerConnection","mozRTCSessionDescription","mozRemove","mozRequestAnimationFrame","mozRequestFullScreen","mozRequestPointerLock","mozSetDataAt","mozSetImageElement","mozSourceNode","mozSrcObject","mozSystem","mozTCPSocket","mozTextStyle","mozTypesAt","mozUnlockOrientation","mozUserCancelled","mozVisibilityState","ms","msAnimation","msAnimationDelay","msAnimationDirection","msAnimationDuration","msAnimationFillMode","msAnimationIterationCount","msAnimationName","msAnimationPlayState","msAnimationStartTime","msAnimationTimingFunction","msBackfaceVisibility","msBlockProgression","msCSSOMElementFloatMetrics","msCaching","msCachingEnabled","msCancelRequestAnimationFrame","msCapsLockWarningOff","msClearImmediate","msClose","msContentZoomChaining","msContentZoomFactor","msContentZoomLimit","msContentZoomLimitMax","msContentZoomLimitMin","msContentZoomSnap","msContentZoomSnapPoints","msContentZoomSnapType","msContentZooming","msConvertURL","msCrypto","msDoNotTrack","msElementsFromPoint","msElementsFromRect","msExitFullscreen","msExtendedCode","msFillRule","msFirstPaint","msFlex","msFlexAlign","msFlexDirection","msFlexFlow","msFlexItemAlign","msFlexLinePack","msFlexNegative","msFlexOrder","msFlexPack","msFlexPositive","msFlexPreferredSize","msFlexWrap","msFlowFrom","msFlowInto","msFontFeatureSettings","msFullscreenElement","msFullscreenEnabled","msGetInputContext","msGetRegionContent","msGetUntransformedBounds","msGraphicsTrustStatus","msGridColumn","msGridColumnAlign","msGridColumnSpan","msGridColumns","msGridRow","msGridRowAlign","msGridRowSpan","msGridRows","msHidden","msHighContrastAdjust","msHyphenateLimitChars","msHyphenateLimitLines","msHyphenateLimitZone","msHyphens","msImageSmoothingEnabled","msImeAlign","msIndexedDB","msInterpolationMode","msIsStaticHTML","msKeySystem","msKeys","msLaunchUri","msLockOrientation","msManipulationViewsEnabled","msMatchMedia","msMatchesSelector","msMaxTouchPoints","msOrientation","msOverflowStyle","msPerspective","msPerspectiveOrigin","msPlayToDisabled","msPlayToPreferredSourceUri","msPlayToPrimary","msPointerEnabled","msRegionOverflow","msReleasePointerCapture","msRequestAnimationFrame","msRequestFullscreen","msSaveBlob","msSaveOrOpenBlob","msScrollChaining","msScrollLimit","msScrollLimitXMax","msScrollLimitXMin","msScrollLimitYMax","msScrollLimitYMin","msScrollRails","msScrollSnapPointsX","msScrollSnapPointsY","msScrollSnapType","msScrollSnapX","msScrollSnapY","msScrollTranslation","msSetImmediate","msSetMediaKeys","msSetPointerCapture","msTextCombineHorizontal","msTextSizeAdjust","msToBlob","msTouchAction","msTouchSelect","msTraceAsyncCallbackCompleted","msTraceAsyncCallbackStarting","msTraceAsyncOperationCompleted","msTraceAsyncOperationStarting","msTransform","msTransformOrigin","msTransformStyle","msTransition","msTransitionDelay","msTransitionDuration","msTransitionProperty","msTransitionTimingFunction","msUnlockOrientation","msUpdateAsyncCallbackRelation","msUserSelect","msVisibilityState","msWrapFlow","msWrapMargin","msWrapThrough","msWriteProfilerMark","msZoom","msZoomTo","mt","mul","multiEntry","multiSelectionObj","multiline","multiple","multiply","multiplySelf","mutableFile","muted","n","name","nameProp","namedItem","namedRecordset","names","namespaceURI","namespaces","naturalHeight","naturalWidth","navigate","navigation","navigationMode","navigationPreload","navigationStart","navigator","near","nearestViewportElement","negative","negotiated","netscape","networkState","newScale","newTranslate","newURL","newValue","newValueSpecifiedUnits","newVersion","newhome","next","nextElementSibling","nextHopProtocol","nextNode","nextPage","nextSibling","nickname","noHref","noModule","noResize","noShade","noValidate","noWrap","node","nodeName","nodeType","nodeValue","nonce","normalize","normalizedPathSegList","notationName","notations","note","noteGrainOn","noteOff","noteOn","notify","now","numOctaves","number","numberOfChannels","numberOfInputs","numberOfItems","numberOfOutputs","numberValue","oMatchesSelector","object","object-fit","object-position","objectFit","objectPosition","objectStore","objectStoreNames","objectType","observe","of","offscreenBuffering","offset","offset-anchor","offset-distance","offset-path","offset-rotate","offsetAnchor","offsetDistance","offsetHeight","offsetLeft","offsetNode","offsetParent","offsetPath","offsetRotate","offsetTop","offsetWidth","offsetX","offsetY","ok","oldURL","oldValue","oldVersion","olderShadowRoot","onLine","onabort","onabsolutedeviceorientation","onactivate","onactive","onaddsourcebuffer","onaddstream","onaddtrack","onafterprint","onafterscriptexecute","onafterupdate","onanimationcancel","onanimationend","onanimationiteration","onanimationstart","onappinstalled","onaudioend","onaudioprocess","onaudiostart","onautocomplete","onautocompleteerror","onauxclick","onbeforeactivate","onbeforecopy","onbeforecut","onbeforedeactivate","onbeforeeditfocus","onbeforeinstallprompt","onbeforepaste","onbeforeprint","onbeforescriptexecute","onbeforeunload","onbeforeupdate","onbeforexrselect","onbegin","onblocked","onblur","onbounce","onboundary","onbufferedamountlow","oncached","oncancel","oncandidatewindowhide","oncandidatewindowshow","oncandidatewindowupdate","oncanplay","oncanplaythrough","once","oncellchange","onchange","oncharacteristicvaluechanged","onchargingchange","onchargingtimechange","onchecking","onclick","onclose","onclosing","oncompassneedscalibration","oncomplete","onconnect","onconnecting","onconnectionavailable","onconnectionstatechange","oncontextmenu","oncontrollerchange","oncontrolselect","oncopy","oncuechange","oncut","ondataavailable","ondatachannel","ondatasetchanged","ondatasetcomplete","ondblclick","ondeactivate","ondevicechange","ondevicelight","ondevicemotion","ondeviceorientation","ondeviceorientationabsolute","ondeviceproximity","ondischargingtimechange","ondisconnect","ondisplay","ondownloading","ondrag","ondragend","ondragenter","ondragexit","ondragleave","ondragover","ondragstart","ondrop","ondurationchange","onemptied","onencrypted","onend","onended","onenter","onenterpictureinpicture","onerror","onerrorupdate","onexit","onfilterchange","onfinish","onfocus","onfocusin","onfocusout","onformdata","onfreeze","onfullscreenchange","onfullscreenerror","ongatheringstatechange","ongattserverdisconnected","ongesturechange","ongestureend","ongesturestart","ongotpointercapture","onhashchange","onhelp","onicecandidate","onicecandidateerror","oniceconnectionstatechange","onicegatheringstatechange","oninactive","oninput","oninputsourceschange","oninvalid","onkeydown","onkeypress","onkeystatuseschange","onkeyup","onlanguagechange","onlayoutcomplete","onleavepictureinpicture","onlevelchange","onload","onloadeddata","onloadedmetadata","onloadend","onloading","onloadingdone","onloadingerror","onloadstart","onlosecapture","onlostpointercapture","only","onmark","onmessage","onmessageerror","onmidimessage","onmousedown","onmouseenter","onmouseleave","onmousemove","onmouseout","onmouseover","onmouseup","onmousewheel","onmove","onmoveend","onmovestart","onmozfullscreenchange","onmozfullscreenerror","onmozorientationchange","onmozpointerlockchange","onmozpointerlockerror","onmscontentzoom","onmsfullscreenchange","onmsfullscreenerror","onmsgesturechange","onmsgesturedoubletap","onmsgestureend","onmsgesturehold","onmsgesturestart","onmsgesturetap","onmsgotpointercapture","onmsinertiastart","onmslostpointercapture","onmsmanipulationstatechanged","onmsneedkey","onmsorientationchange","onmspointercancel","onmspointerdown","onmspointerenter","onmspointerhover","onmspointerleave","onmspointermove","onmspointerout","onmspointerover","onmspointerup","onmssitemodejumplistitemremoved","onmsthumbnailclick","onmute","onnegotiationneeded","onnomatch","onnoupdate","onobsolete","onoffline","ononline","onopen","onorientationchange","onpagechange","onpagehide","onpageshow","onpaste","onpause","onpayerdetailchange","onpaymentmethodchange","onplay","onplaying","onpluginstreamstart","onpointercancel","onpointerdown","onpointerenter","onpointerleave","onpointerlockchange","onpointerlockerror","onpointermove","onpointerout","onpointerover","onpointerrawupdate","onpointerup","onpopstate","onprocessorerror","onprogress","onpropertychange","onratechange","onreading","onreadystatechange","onrejectionhandled","onrelease","onremove","onremovesourcebuffer","onremovestream","onremovetrack","onrepeat","onreset","onresize","onresizeend","onresizestart","onresourcetimingbufferfull","onresult","onresume","onrowenter","onrowexit","onrowsdelete","onrowsinserted","onscroll","onsearch","onsecuritypolicyviolation","onseeked","onseeking","onselect","onselectedcandidatepairchange","onselectend","onselectionchange","onselectstart","onshippingaddresschange","onshippingoptionchange","onshow","onsignalingstatechange","onsoundend","onsoundstart","onsourceclose","onsourceclosed","onsourceended","onsourceopen","onspeechend","onspeechstart","onsqueeze","onsqueezeend","onsqueezestart","onstalled","onstart","onstatechange","onstop","onstorage","onstoragecommit","onsubmit","onsuccess","onsuspend","onterminate","ontextinput","ontimeout","ontimeupdate","ontoggle","ontonechange","ontouchcancel","ontouchend","ontouchmove","ontouchstart","ontrack","ontransitioncancel","ontransitionend","ontransitionrun","ontransitionstart","onunhandledrejection","onunload","onunmute","onupdate","onupdateend","onupdatefound","onupdateready","onupdatestart","onupgradeneeded","onuserproximity","onversionchange","onvisibilitychange","onvoiceschanged","onvolumechange","onvrdisplayactivate","onvrdisplayconnect","onvrdisplaydeactivate","onvrdisplaydisconnect","onvrdisplaypresentchange","onwaiting","onwaitingforkey","onwarning","onwebkitanimationend","onwebkitanimationiteration","onwebkitanimationstart","onwebkitcurrentplaybacktargetiswirelesschanged","onwebkitfullscreenchange","onwebkitfullscreenerror","onwebkitkeyadded","onwebkitkeyerror","onwebkitkeymessage","onwebkitneedkey","onwebkitorientationchange","onwebkitplaybacktargetavailabilitychanged","onwebkitpointerlockchange","onwebkitpointerlockerror","onwebkitresourcetimingbufferfull","onwebkittransitionend","onwheel","onzoom","opacity","open","openCursor","openDatabase","openKeyCursor","opened","opener","opera","operationType","operator","opr","optimum","options","or","order","orderX","orderY","ordered","org","organization","orient","orientAngle","orientType","orientation","orientationX","orientationY","orientationZ","origin","originalPolicy","originalTarget","orphans","oscpu","outerHTML","outerHeight","outerText","outerWidth","outline","outline-color","outline-offset","outline-style","outline-width","outlineColor","outlineOffset","outlineStyle","outlineWidth","outputBuffer","outputLatency","outputs","overflow","overflow-anchor","overflow-block","overflow-inline","overflow-wrap","overflow-x","overflow-y","overflowAnchor","overflowBlock","overflowInline","overflowWrap","overflowX","overflowY","overrideMimeType","oversample","overscroll-behavior","overscroll-behavior-block","overscroll-behavior-inline","overscroll-behavior-x","overscroll-behavior-y","overscrollBehavior","overscrollBehaviorBlock","overscrollBehaviorInline","overscrollBehaviorX","overscrollBehaviorY","ownKeys","ownerDocument","ownerElement","ownerNode","ownerRule","ownerSVGElement","owningElement","p1","p2","p3","p4","packetSize","packets","pad","padEnd","padStart","padding","padding-block","padding-block-end","padding-block-start","padding-bottom","padding-inline","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","paddingBlock","paddingBlockEnd","paddingBlockStart","paddingBottom","paddingInline","paddingInlineEnd","paddingInlineStart","paddingLeft","paddingRight","paddingTop","page","page-break-after","page-break-before","page-break-inside","pageBreakAfter","pageBreakBefore","pageBreakInside","pageCount","pageLeft","pageTop","pageX","pageXOffset","pageY","pageYOffset","pages","paint-order","paintOrder","paintRequests","paintType","paintWorklet","palette","pan","panningModel","parameters","parent","parentElement","parentNode","parentRule","parentStyleSheet","parentTextEdit","parentWindow","parse","parseAll","parseFloat","parseFromString","parseInt","part","participants","passive","password","pasteHTML","path","pathLength","pathSegList","pathSegType","pathSegTypeAsLetter","pathname","pattern","patternContentUnits","patternMismatch","patternTransform","patternUnits","pause","pauseAnimations","pauseOnExit","pauseProfilers","pauseTransformFeedback","paused","payerEmail","payerName","payerPhone","paymentManager","pc","peerIdentity","pending","pendingLocalDescription","pendingRemoteDescription","percent","performance","periodicSync","permission","permissionState","permissions","persist","persisted","personalbar","perspective","perspective-origin","perspectiveOrigin","phone","phoneticFamilyName","phoneticGivenName","photo","pictureInPictureElement","pictureInPictureEnabled","pictureInPictureWindow","ping","pipeThrough","pipeTo","pitch","pixelBottom","pixelDepth","pixelHeight","pixelLeft","pixelRight","pixelStorei","pixelTop","pixelUnitToMillimeterX","pixelUnitToMillimeterY","pixelWidth","place-content","place-items","place-self","placeContent","placeItems","placeSelf","placeholder","platform","platforms","play","playEffect","playState","playbackRate","playbackState","playbackTime","played","playoutDelayHint","playsInline","plugins","pluginspage","pname","pointer-events","pointerBeforeReferenceNode","pointerEnabled","pointerEvents","pointerId","pointerLockElement","pointerType","points","pointsAtX","pointsAtY","pointsAtZ","polygonOffset","pop","populateMatrix","popupWindowFeatures","popupWindowName","popupWindowURI","port","port1","port2","ports","posBottom","posHeight","posLeft","posRight","posTop","posWidth","pose","position","positionAlign","positionX","positionY","positionZ","postError","postMessage","postalCode","poster","pow","powerEfficient","powerOff","preMultiplySelf","precision","preferredStyleSheetSet","preferredStylesheetSet","prefix","preload","prepend","presentation","preserveAlpha","preserveAspectRatio","preserveAspectRatioString","pressed","pressure","prevValue","preventDefault","preventExtensions","preventSilentAccess","previousElementSibling","previousNode","previousPage","previousRect","previousScale","previousSibling","previousTranslate","primaryKey","primitiveType","primitiveUnits","principals","print","priority","privateKey","probablySupportsContext","process","processIceMessage","processingEnd","processingStart","product","productId","productName","productSub","profile","profileEnd","profiles","projectionMatrix","promise","prompt","properties","propertyIsEnumerable","propertyName","protocol","protocolLong","prototype","provider","pseudoClass","pseudoElement","pt","publicId","publicKey","published","pulse","push","pushManager","pushNotification","pushState","put","putImageData","px","quadraticCurveTo","qualifier","quaternion","query","queryCommandEnabled","queryCommandIndeterm","queryCommandState","queryCommandSupported","queryCommandText","queryCommandValue","querySelector","querySelectorAll","queueMicrotask","quote","quotes","r","r1","r2","race","rad","radiogroup","radiusX","radiusY","random","range","rangeCount","rangeMax","rangeMin","rangeOffset","rangeOverflow","rangeParent","rangeUnderflow","rate","ratio","raw","rawId","read","readAsArrayBuffer","readAsBinaryString","readAsBlob","readAsDataURL","readAsText","readBuffer","readEntries","readOnly","readPixels","readReportRequested","readText","readValue","readable","ready","readyState","reason","reboot","receivedAlert","receiver","receivers","recipient","reconnect","recordNumber","recordsAvailable","recordset","rect","red","redEyeReduction","redirect","redirectCount","redirectEnd","redirectStart","redirected","reduce","reduceRight","reduction","refDistance","refX","refY","referenceNode","referenceSpace","referrer","referrerPolicy","refresh","region","regionAnchorX","regionAnchorY","regionId","regions","register","registerContentHandler","registerElement","registerProperty","registerProtocolHandler","reject","rel","relList","relatedAddress","relatedNode","relatedPort","relatedTarget","release","releaseCapture","releaseEvents","releaseInterface","releaseLock","releasePointerCapture","releaseShaderCompiler","reliable","reliableWrite","reload","rem","remainingSpace","remote","remoteDescription","remove","removeAllRanges","removeAttribute","removeAttributeNS","removeAttributeNode","removeBehavior","removeChild","removeCue","removeEventListener","removeFilter","removeImport","removeItem","removeListener","removeNamedItem","removeNamedItemNS","removeNode","removeParameter","removeProperty","removeRange","removeRegion","removeRule","removeSiteSpecificTrackingException","removeSourceBuffer","removeStream","removeTrack","removeVariable","removeWakeLockListener","removeWebWideTrackingException","removed","removedNodes","renderHeight","renderState","renderTime","renderWidth","renderbufferStorage","renderbufferStorageMultisample","renderedBuffer","renderingMode","renotify","repeat","replace","replaceAdjacentText","replaceAll","replaceChild","replaceChildren","replaceData","replaceId","replaceItem","replaceNode","replaceState","replaceSync","replaceTrack","replaceWholeText","replaceWith","reportValidity","request","requestAnimationFrame","requestAutocomplete","requestData","requestDevice","requestFrame","requestFullscreen","requestHitTestSource","requestHitTestSourceForTransientInput","requestId","requestIdleCallback","requestMIDIAccess","requestMediaKeySystemAccess","requestPermission","requestPictureInPicture","requestPointerLock","requestPresent","requestReferenceSpace","requestSession","requestStart","requestStorageAccess","requestSubmit","requestVideoFrameCallback","requestingWindow","requireInteraction","required","requiredExtensions","requiredFeatures","reset","resetPose","resetTransform","resize","resizeBy","resizeTo","resolve","response","responseBody","responseEnd","responseReady","responseStart","responseText","responseType","responseURL","responseXML","restartIce","restore","result","resultIndex","resultType","results","resume","resumeProfilers","resumeTransformFeedback","retry","returnValue","rev","reverse","reversed","revocable","revokeObjectURL","rgbColor","right","rightContext","rightDegrees","rightMargin","rightProjectionMatrix","rightViewMatrix","role","rolloffFactor","root","rootBounds","rootElement","rootMargin","rotate","rotateAxisAngle","rotateAxisAngleSelf","rotateFromVector","rotateFromVectorSelf","rotateSelf","rotation","rotationAngle","rotationRate","round","row-gap","rowGap","rowIndex","rowSpan","rows","rtcpTransport","rtt","ruby-align","ruby-position","rubyAlign","rubyOverhang","rubyPosition","rules","runtime","runtimeStyle","rx","ry","s","safari","sample","sampleCoverage","sampleRate","samplerParameterf","samplerParameteri","sandbox","save","saveData","scale","scale3d","scale3dSelf","scaleNonUniform","scaleNonUniformSelf","scaleSelf","scheme","scissor","scope","scopeName","scoped","screen","screenBrightness","screenEnabled","screenLeft","screenPixelToMillimeterX","screenPixelToMillimeterY","screenTop","screenX","screenY","scriptURL","scripts","scroll","scroll-behavior","scroll-margin","scroll-margin-block","scroll-margin-block-end","scroll-margin-block-start","scroll-margin-bottom","scroll-margin-inline","scroll-margin-inline-end","scroll-margin-inline-start","scroll-margin-left","scroll-margin-right","scroll-margin-top","scroll-padding","scroll-padding-block","scroll-padding-block-end","scroll-padding-block-start","scroll-padding-bottom","scroll-padding-inline","scroll-padding-inline-end","scroll-padding-inline-start","scroll-padding-left","scroll-padding-right","scroll-padding-top","scroll-snap-align","scroll-snap-type","scrollAmount","scrollBehavior","scrollBy","scrollByLines","scrollByPages","scrollDelay","scrollHeight","scrollIntoView","scrollIntoViewIfNeeded","scrollLeft","scrollLeftMax","scrollMargin","scrollMarginBlock","scrollMarginBlockEnd","scrollMarginBlockStart","scrollMarginBottom","scrollMarginInline","scrollMarginInlineEnd","scrollMarginInlineStart","scrollMarginLeft","scrollMarginRight","scrollMarginTop","scrollMaxX","scrollMaxY","scrollPadding","scrollPaddingBlock","scrollPaddingBlockEnd","scrollPaddingBlockStart","scrollPaddingBottom","scrollPaddingInline","scrollPaddingInlineEnd","scrollPaddingInlineStart","scrollPaddingLeft","scrollPaddingRight","scrollPaddingTop","scrollRestoration","scrollSnapAlign","scrollSnapType","scrollTo","scrollTop","scrollTopMax","scrollWidth","scrollX","scrollY","scrollbar-color","scrollbar-width","scrollbar3dLightColor","scrollbarArrowColor","scrollbarBaseColor","scrollbarColor","scrollbarDarkShadowColor","scrollbarFaceColor","scrollbarHighlightColor","scrollbarShadowColor","scrollbarTrackColor","scrollbarWidth","scrollbars","scrolling","scrollingElement","sctp","sctpCauseCode","sdp","sdpLineNumber","sdpMLineIndex","sdpMid","seal","search","searchBox","searchBoxJavaBridge_","searchParams","sectionRowIndex","secureConnectionStart","security","seed","seekToNextFrame","seekable","seeking","select","selectAllChildren","selectAlternateInterface","selectConfiguration","selectNode","selectNodeContents","selectNodes","selectSingleNode","selectSubString","selected","selectedIndex","selectedOptions","selectedStyleSheetSet","selectedStylesheetSet","selection","selectionDirection","selectionEnd","selectionStart","selector","selectorText","self","send","sendAsBinary","sendBeacon","sender","sentAlert","sentTimestamp","separator","serialNumber","serializeToString","serverTiming","service","serviceWorker","session","sessionId","sessionStorage","set","setActionHandler","setActive","setAlpha","setAppBadge","setAttribute","setAttributeNS","setAttributeNode","setAttributeNodeNS","setBaseAndExtent","setBigInt64","setBigUint64","setBingCurrentSearchDefault","setCapture","setCodecPreferences","setColor","setCompositeOperation","setConfiguration","setCurrentTime","setCustomValidity","setData","setDate","setDragImage","setEnd","setEndAfter","setEndBefore","setEndPoint","setFillColor","setFilterRes","setFloat32","setFloat64","setFloatValue","setFormValue","setFullYear","setHeaderValue","setHours","setIdentityProvider","setImmediate","setInt16","setInt32","setInt8","setInterval","setItem","setKeyframes","setLineCap","setLineDash","setLineJoin","setLineWidth","setLiveSeekableRange","setLocalDescription","setMatrix","setMatrixValue","setMediaKeys","setMilliseconds","setMinutes","setMiterLimit","setMonth","setNamedItem","setNamedItemNS","setNonUserCodeExceptions","setOrientToAngle","setOrientToAuto","setOrientation","setOverrideHistoryNavigationMode","setPaint","setParameter","setParameters","setPeriodicWave","setPointerCapture","setPosition","setPositionState","setPreference","setProperty","setPrototypeOf","setRGBColor","setRGBColorICCColor","setRadius","setRangeText","setRemoteDescription","setRequestHeader","setResizable","setResourceTimingBufferSize","setRotate","setScale","setSeconds","setSelectionRange","setServerCertificate","setShadow","setSinkId","setSkewX","setSkewY","setStart","setStartAfter","setStartBefore","setStdDeviation","setStreams","setStringValue","setStrokeColor","setSuggestResult","setTargetAtTime","setTargetValueAtTime","setTime","setTimeout","setTransform","setTranslate","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setUint16","setUint32","setUint8","setUri","setValidity","setValueAtTime","setValueCurveAtTime","setVariable","setVelocity","setVersion","setYear","settingName","settingValue","sex","shaderSource","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","shadowRoot","shape","shape-image-threshold","shape-margin","shape-outside","shape-rendering","shapeImageThreshold","shapeMargin","shapeOutside","shapeRendering","sheet","shift","shiftKey","shiftLeft","shippingAddress","shippingOption","shippingType","show","showHelp","showModal","showModalDialog","showModelessDialog","showNotification","sidebar","sign","signal","signalingState","signature","silent","sin","singleNodeValue","sinh","sinkId","sittingToStandingTransform","size","sizeToContent","sizeX","sizeZ","sizes","skewX","skewXSelf","skewY","skewYSelf","slice","slope","slot","small","smil","smooth","smoothingTimeConstant","snapToLines","snapshotItem","snapshotLength","some","sort","sortingCode","source","sourceBuffer","sourceBuffers","sourceCapabilities","sourceFile","sourceIndex","sources","spacing","span","speak","speakAs","speaking","species","specified","specularConstant","specularExponent","speechSynthesis","speed","speedOfSound","spellcheck","splice","split","splitText","spreadMethod","sqrt","src","srcElement","srcFilter","srcObject","srcUrn","srcdoc","srclang","srcset","stack","stackTraceLimit","stacktrace","stageParameters","standalone","standby","start","startContainer","startIce","startMessages","startNotifications","startOffset","startProfiling","startRendering","startShark","startTime","startsWith","state","status","statusCode","statusMessage","statusText","statusbar","stdDeviationX","stdDeviationY","stencilFunc","stencilFuncSeparate","stencilMask","stencilMaskSeparate","stencilOp","stencilOpSeparate","step","stepDown","stepMismatch","stepUp","sticky","stitchTiles","stop","stop-color","stop-opacity","stopColor","stopImmediatePropagation","stopNotifications","stopOpacity","stopProfiling","stopPropagation","stopShark","stopped","storage","storageArea","storageName","storageStatus","store","storeSiteSpecificTrackingException","storeWebWideTrackingException","stpVersion","stream","streams","stretch","strike","string","stringValue","stringify","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","strokeDasharray","strokeDashoffset","strokeLinecap","strokeLinejoin","strokeMiterlimit","strokeOpacity","strokeRect","strokeStyle","strokeText","strokeWidth","style","styleFloat","styleMap","styleMedia","styleSheet","styleSheetSets","styleSheets","sub","subarray","subject","submit","submitFrame","submitter","subscribe","substr","substring","substringData","subtle","subtree","suffix","suffixes","summary","sup","supported","supportedContentEncodings","supportedEntryTypes","supports","supportsSession","surfaceScale","surroundContents","suspend","suspendRedraw","swapCache","swapNode","sweepFlag","symbols","sync","sysexEnabled","system","systemCode","systemId","systemLanguage","systemXDPI","systemYDPI","tBodies","tFoot","tHead","tabIndex","table","table-layout","tableLayout","tableValues","tag","tagName","tagUrn","tags","taintEnabled","takePhoto","takeRecords","tan","tangentialPressure","tanh","target","targetElement","targetRayMode","targetRaySpace","targetTouches","targetX","targetY","tcpType","tee","tel","terminate","test","texImage2D","texImage3D","texParameterf","texParameteri","texStorage2D","texStorage3D","texSubImage2D","texSubImage3D","text","text-align","text-align-last","text-anchor","text-combine-upright","text-decoration","text-decoration-color","text-decoration-line","text-decoration-skip-ink","text-decoration-style","text-decoration-thickness","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-indent","text-justify","text-orientation","text-overflow","text-rendering","text-shadow","text-transform","text-underline-offset","text-underline-position","textAlign","textAlignLast","textAnchor","textAutospace","textBaseline","textCombineUpright","textContent","textDecoration","textDecorationBlink","textDecorationColor","textDecorationLine","textDecorationLineThrough","textDecorationNone","textDecorationOverline","textDecorationSkipInk","textDecorationStyle","textDecorationThickness","textDecorationUnderline","textEmphasis","textEmphasisColor","textEmphasisPosition","textEmphasisStyle","textIndent","textJustify","textJustifyTrim","textKashida","textKashidaSpace","textLength","textOrientation","textOverflow","textRendering","textShadow","textTracks","textTransform","textUnderlineOffset","textUnderlinePosition","then","threadId","threshold","thresholds","tiltX","tiltY","time","timeEnd","timeLog","timeOrigin","timeRemaining","timeStamp","timecode","timeline","timelineTime","timeout","timestamp","timestampOffset","timing","title","to","toArray","toBlob","toDataURL","toDateString","toElement","toExponential","toFixed","toFloat32Array","toFloat64Array","toGMTString","toISOString","toJSON","toLocaleDateString","toLocaleFormat","toLocaleLowerCase","toLocaleString","toLocaleTimeString","toLocaleUpperCase","toLowerCase","toMatrix","toMethod","toPrecision","toPrimitive","toSdp","toSource","toStaticHTML","toString","toStringTag","toSum","toTimeString","toUTCString","toUpperCase","toggle","toggleAttribute","toggleLongPressEnabled","tone","toneBuffer","tooLong","tooShort","toolbar","top","topMargin","total","totalFrameDelay","totalVideoFrames","touch-action","touchAction","touched","touches","trace","track","trackVisibility","transaction","transactions","transceiver","transferControlToOffscreen","transferFromImageBitmap","transferImageBitmap","transferIn","transferOut","transferSize","transferToImageBitmap","transform","transform-box","transform-origin","transform-style","transformBox","transformFeedbackVaryings","transformOrigin","transformPoint","transformString","transformStyle","transformToDocument","transformToFragment","transition","transition-delay","transition-duration","transition-property","transition-timing-function","transitionDelay","transitionDuration","transitionProperty","transitionTimingFunction","translate","translateSelf","translationX","translationY","transport","trim","trimEnd","trimLeft","trimRight","trimStart","trueSpeed","trunc","truncate","trustedTypes","turn","twist","type","typeDetail","typeMismatch","typeMustMatch","types","u2f","ubound","uint16","uint32","uint8","uint8Clamped","undefined","unescape","uneval","unicode","unicode-bidi","unicodeBidi","unicodeRange","uniform1f","uniform1fv","uniform1i","uniform1iv","uniform1ui","uniform1uiv","uniform2f","uniform2fv","uniform2i","uniform2iv","uniform2ui","uniform2uiv","uniform3f","uniform3fv","uniform3i","uniform3iv","uniform3ui","uniform3uiv","uniform4f","uniform4fv","uniform4i","uniform4iv","uniform4ui","uniform4uiv","uniformBlockBinding","uniformMatrix2fv","uniformMatrix2x3fv","uniformMatrix2x4fv","uniformMatrix3fv","uniformMatrix3x2fv","uniformMatrix3x4fv","uniformMatrix4fv","uniformMatrix4x2fv","uniformMatrix4x3fv","unique","uniqueID","uniqueNumber","unit","unitType","units","unloadEventEnd","unloadEventStart","unlock","unmount","unobserve","unpause","unpauseAnimations","unreadCount","unregister","unregisterContentHandler","unregisterProtocolHandler","unscopables","unselectable","unshift","unsubscribe","unsuspendRedraw","unsuspendRedrawAll","unwatch","unwrapKey","upDegrees","upX","upY","upZ","update","updateCommands","updateIce","updateInterval","updatePlaybackRate","updateRenderState","updateSettings","updateTiming","updateViaCache","updateWith","updated","updating","upgrade","upload","uploadTotal","uploaded","upper","upperBound","upperOpen","uri","url","urn","urns","usages","usb","usbVersionMajor","usbVersionMinor","usbVersionSubminor","useCurrentView","useMap","useProgram","usedSpace","user-select","userActivation","userAgent","userChoice","userHandle","userHint","userLanguage","userSelect","userVisibleOnly","username","usernameFragment","utterance","uuid","v8BreakIterator","vAlign","vLink","valid","validate","validateProgram","validationMessage","validity","value","valueAsDate","valueAsNumber","valueAsString","valueInSpecifiedUnits","valueMissing","valueOf","valueText","valueType","values","variable","variant","variationSettings","vector-effect","vectorEffect","velocityAngular","velocityExpansion","velocityX","velocityY","vendor","vendorId","vendorSub","verify","version","vertexAttrib1f","vertexAttrib1fv","vertexAttrib2f","vertexAttrib2fv","vertexAttrib3f","vertexAttrib3fv","vertexAttrib4f","vertexAttrib4fv","vertexAttribDivisor","vertexAttribDivisorANGLE","vertexAttribI4i","vertexAttribI4iv","vertexAttribI4ui","vertexAttribI4uiv","vertexAttribIPointer","vertexAttribPointer","vertical","vertical-align","verticalAlign","verticalOverflow","vh","vibrate","vibrationActuator","videoBitsPerSecond","videoHeight","videoTracks","videoWidth","view","viewBox","viewBoxString","viewTarget","viewTargetString","viewport","viewportAnchorX","viewportAnchorY","viewportElement","views","violatedDirective","visibility","visibilityState","visible","visualViewport","vlinkColor","vmax","vmin","voice","voiceURI","volume","vrml","vspace","vw","w","wait","waitSync","waiting","wake","wakeLock","wand","warn","wasClean","wasDiscarded","watch","watchAvailability","watchPosition","webdriver","webkitAddKey","webkitAlignContent","webkitAlignItems","webkitAlignSelf","webkitAnimation","webkitAnimationDelay","webkitAnimationDirection","webkitAnimationDuration","webkitAnimationFillMode","webkitAnimationIterationCount","webkitAnimationName","webkitAnimationPlayState","webkitAnimationTimingFunction","webkitAppearance","webkitAudioContext","webkitAudioDecodedByteCount","webkitAudioPannerNode","webkitBackfaceVisibility","webkitBackground","webkitBackgroundAttachment","webkitBackgroundClip","webkitBackgroundColor","webkitBackgroundImage","webkitBackgroundOrigin","webkitBackgroundPosition","webkitBackgroundPositionX","webkitBackgroundPositionY","webkitBackgroundRepeat","webkitBackgroundSize","webkitBackingStorePixelRatio","webkitBorderBottomLeftRadius","webkitBorderBottomRightRadius","webkitBorderImage","webkitBorderImageOutset","webkitBorderImageRepeat","webkitBorderImageSlice","webkitBorderImageSource","webkitBorderImageWidth","webkitBorderRadius","webkitBorderTopLeftRadius","webkitBorderTopRightRadius","webkitBoxAlign","webkitBoxDirection","webkitBoxFlex","webkitBoxOrdinalGroup","webkitBoxOrient","webkitBoxPack","webkitBoxShadow","webkitBoxSizing","webkitCancelAnimationFrame","webkitCancelFullScreen","webkitCancelKeyRequest","webkitCancelRequestAnimationFrame","webkitClearResourceTimings","webkitClosedCaptionsVisible","webkitConvertPointFromNodeToPage","webkitConvertPointFromPageToNode","webkitCreateShadowRoot","webkitCurrentFullScreenElement","webkitCurrentPlaybackTargetIsWireless","webkitDecodedFrameCount","webkitDirectionInvertedFromDevice","webkitDisplayingFullscreen","webkitDroppedFrameCount","webkitEnterFullScreen","webkitEnterFullscreen","webkitEntries","webkitExitFullScreen","webkitExitFullscreen","webkitExitPointerLock","webkitFilter","webkitFlex","webkitFlexBasis","webkitFlexDirection","webkitFlexFlow","webkitFlexGrow","webkitFlexShrink","webkitFlexWrap","webkitFullScreenKeyboardInputAllowed","webkitFullscreenElement","webkitFullscreenEnabled","webkitGenerateKeyRequest","webkitGetAsEntry","webkitGetDatabaseNames","webkitGetEntries","webkitGetEntriesByName","webkitGetEntriesByType","webkitGetFlowByName","webkitGetGamepads","webkitGetImageDataHD","webkitGetNamedFlows","webkitGetRegionFlowRanges","webkitGetUserMedia","webkitHasClosedCaptions","webkitHidden","webkitIDBCursor","webkitIDBDatabase","webkitIDBDatabaseError","webkitIDBDatabaseException","webkitIDBFactory","webkitIDBIndex","webkitIDBKeyRange","webkitIDBObjectStore","webkitIDBRequest","webkitIDBTransaction","webkitImageSmoothingEnabled","webkitIndexedDB","webkitInitMessageEvent","webkitIsFullScreen","webkitJustifyContent","webkitKeys","webkitLineClamp","webkitLineDashOffset","webkitLockOrientation","webkitMask","webkitMaskClip","webkitMaskComposite","webkitMaskImage","webkitMaskOrigin","webkitMaskPosition","webkitMaskPositionX","webkitMaskPositionY","webkitMaskRepeat","webkitMaskSize","webkitMatchesSelector","webkitMediaStream","webkitNotifications","webkitOfflineAudioContext","webkitOrder","webkitOrientation","webkitPeerConnection00","webkitPersistentStorage","webkitPerspective","webkitPerspectiveOrigin","webkitPointerLockElement","webkitPostMessage","webkitPreservesPitch","webkitPutImageDataHD","webkitRTCPeerConnection","webkitRegionOverset","webkitRelativePath","webkitRequestAnimationFrame","webkitRequestFileSystem","webkitRequestFullScreen","webkitRequestFullscreen","webkitRequestPointerLock","webkitResolveLocalFileSystemURL","webkitSetMediaKeys","webkitSetResourceTimingBufferSize","webkitShadowRoot","webkitShowPlaybackTargetPicker","webkitSlice","webkitSpeechGrammar","webkitSpeechGrammarList","webkitSpeechRecognition","webkitSpeechRecognitionError","webkitSpeechRecognitionEvent","webkitStorageInfo","webkitSupportsFullscreen","webkitTemporaryStorage","webkitTextFillColor","webkitTextSizeAdjust","webkitTextStroke","webkitTextStrokeColor","webkitTextStrokeWidth","webkitTransform","webkitTransformOrigin","webkitTransformStyle","webkitTransition","webkitTransitionDelay","webkitTransitionDuration","webkitTransitionProperty","webkitTransitionTimingFunction","webkitURL","webkitUnlockOrientation","webkitUserSelect","webkitVideoDecodedByteCount","webkitVisibilityState","webkitWirelessVideoPlaybackDisabled","webkitdirectory","webkitdropzone","webstore","weight","whatToShow","wheelDelta","wheelDeltaX","wheelDeltaY","whenDefined","which","white-space","whiteSpace","wholeText","widows","width","will-change","willChange","willValidate","window","withCredentials","word-break","word-spacing","word-wrap","wordBreak","wordSpacing","wordWrap","workerStart","wrap","wrapKey","writable","writableAuxiliaries","write","writeText","writeValue","writeWithoutResponse","writeln","writing-mode","writingMode","x","x1","x2","xChannelSelector","xmlEncoding","xmlStandalone","xmlVersion","xmlbase","xmllang","xmlspace","xor","xr","y","y1","y2","yChannelSelector","yandex","z","z-index","zIndex","zoom","zoomAndPan","zoomRectScreen"]')
    }, 7409: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getBinaryBytecodeDecoderTemplate = function () {
        return "\n            // Binary bytecode decoder\n            // Constant type tags\n            let CT_NULL = 0, CT_UNDEF = 1, CT_FALSE = 2, CT_TRUE = 3;\n            let CT_INT8 = 4, CT_INT16 = 5, CT_INT32 = 6, CT_FLOAT64 = 7;\n            let CT_STRING = 8, CT_BIGINT = 9, CT_REGEX = 10;\n\n            // Flag bits\n            let FB_ARROW = 1, FB_ASYNC = 2, FB_GEN = 4, FB_FNAME = 8;\n            let FB_OSEED = 16, FB_OMAP = 32, FB_JKEY = 64, FB_BKEY = 128;\n            let FB_SMSEED = 256, FB_SMSTATE = 512, FB_SEKEY = 1024;\n            let FB_JUMPS = 2048, FB_EXCEPT = 4096;\n\n            // Binary reader class\n            function BinaryReader(buf) {\n                this.buf = buf;\n                // IMPORTANT: Must pass byteOffset and byteLength to handle sliced buffers correctly\n                this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n                this.off = 0;\n            }\n            BinaryReader.prototype.u8 = function() { return this.buf[this.off++]; };\n            BinaryReader.prototype.u16 = function() {\n                let v = this.view.getUint16(this.off, true);\n                this.off += 2;\n                return v;\n            };\n            BinaryReader.prototype.u32 = function() {\n                let v = this.view.getUint32(this.off, true);\n                this.off += 4;\n                return v;\n            };\n            BinaryReader.prototype.i32 = function() {\n                let v = this.view.getInt32(this.off, true);\n                this.off += 4;\n                return v;\n            };\n            BinaryReader.prototype.f64 = function() {\n                let v = this.view.getFloat64(this.off, true);\n                this.off += 8;\n                return v;\n            };\n            BinaryReader.prototype.varint = function() {\n                let result = 0, shift = 0, b;\n                do {\n                    b = this.u8();\n                    result |= (b & 0x7F) << shift;\n                    shift += 7;\n                } while (b >= 0x80);\n                // Zigzag decode\n                return (result >>> 1) ^ -(result & 1);\n            };\n            BinaryReader.prototype.str = function() {\n                let len = this.varint();\n                let bytes = this.buf.slice(this.off, this.off + len);\n                this.off += len;\n                return new TextDecoder().decode(bytes);\n            };\n\n            // Decode base64 to Uint8Array\n            function b64ToUint8(b64) {\n                if (typeof Buffer !== 'undefined') {\n                    return new Uint8Array(Buffer.from(b64, 'base64'));\n                }\n                let bin = atob(b64);\n                let arr = new Uint8Array(bin.length);\n                for (let i = 0; i < bin.length; i++) {\n                    arr[i] = bin.charCodeAt(i);\n                }\n                return arr;\n            }\n\n            // Read a constant value\n            function readConst(r) {\n                let type = r.u8();\n                switch (type) {\n                    case CT_NULL: return null;\n                    case CT_UNDEF: return undefined;\n                    case CT_FALSE: return false;\n                    case CT_TRUE: return true;\n                    case CT_INT8: {\n                        let v = r.u8();\n                        return v > 127 ? v - 256 : v;\n                    }\n                    case CT_INT16: {\n                        let v = r.u16();\n                        return v > 32767 ? v - 65536 : v;\n                    }\n                    case CT_INT32: return r.i32();\n                    case CT_FLOAT64: return r.f64();\n                    case CT_STRING: return r.str();\n                    case CT_BIGINT: return BigInt(r.str());\n                    case CT_REGEX: {\n                        let src = r.str();\n                        let flags = r.str();\n                        return new RegExp(src, flags);\n                    }\n                    default: return null;\n                }\n            }\n\n            // Decode binary bytecode\n            function _decodeBinary(b64, keyMap) {\n                let buf = b64ToUint8(b64);\n                let r = new BinaryReader(buf);\n\n                // Version\n                let version = r.u8();\n\n                // Flags\n                let flags = r.u16();\n\n                // Basic fields\n                let params = r.varint();\n                let locals = r.varint();\n\n                // Key names (use mapping if provided)\n                let kI = keyMap ? keyMap.i : 'i';\n                let kC = keyMap ? keyMap.c : 'c';\n                let kP = keyMap ? keyMap.p : 'p';\n                let kL = keyMap ? keyMap.l : 'l';\n                let kJ = keyMap ? keyMap.j : 'j';\n                let kX = keyMap ? keyMap.x : 'x';\n                let kA = keyMap ? keyMap.a : 'a';\n                let kS = keyMap ? keyMap.s : 's';\n                let kG = keyMap ? keyMap.g : 'g';\n                let kNi = keyMap ? keyMap.ni : 'ni';\n                let kOs = keyMap ? keyMap.os : 'os';\n                let kO = keyMap ? keyMap.o : 'o';\n                let kJk = keyMap ? keyMap.jk : 'jk';\n                let kBk = keyMap ? keyMap.bk : 'bk';\n                let kSmSeed = keyMap ? keyMap.smSeed : 'smSeed';\n                let kSmState = keyMap ? keyMap.smState : 'smState';\n                let kSeKey = keyMap ? keyMap.seKey : 'seKey';\n\n                let result = {};\n                result[kP] = params;\n                result[kL] = locals;\n\n                // Optional fields based on flags\n                if (flags & FB_FNAME) result[kNi] = r.varint();\n                if (flags & FB_OSEED) result[kOs] = r.u32();\n                if (flags & FB_OMAP) {\n                    let mapLen = r.varint();\n                    let omap = {};\n                    for (let i = 0; i < mapLen; i++) {\n                        let logical = r.varint();\n                        let randomized = r.varint();\n                        omap[logical] = randomized;\n                    }\n                    result[kO] = omap;\n                }\n                if (flags & FB_JKEY) result[kJk] = r.u32();\n                if (flags & FB_BKEY) result[kBk] = r.u32();\n                if (flags & FB_SMSEED) result[kSmSeed] = r.u32();\n                if (flags & FB_SMSTATE) result[kSmState] = r.varint();\n                if (flags & FB_SEKEY) result[kSeKey] = r.u32();\n                if (flags & FB_ARROW) result[kA] = 1;\n                if (flags & FB_ASYNC) result[kS] = 1;\n                if (flags & FB_GEN) result[kG] = 1;\n\n                // Constants\n                let constLen = r.varint();\n                let constants = [];\n                for (let i = 0; i < constLen; i++) {\n                    constants.push(readConst(r));\n                }\n                result[kC] = constants;\n\n                // Instructions (flat array)\n                let instrLen = r.varint();\n                let instructions = [];\n                for (let i = 0; i < instrLen; i++) {\n                    let op = r.varint();\n                    let argType = r.u8();\n                    let arg;\n                    switch (argType) {\n                        case CT_NULL: arg = null; break;\n                        case CT_INT8: {\n                            let v = r.u8();\n                            arg = v > 127 ? v - 256 : v;\n                            break;\n                        }\n                        case CT_INT16: {\n                            let v = r.u16();\n                            arg = v > 32767 ? v - 65536 : v;\n                            break;\n                        }\n                        case CT_INT32: arg = r.i32(); break;\n                        case CT_FLOAT64: arg = r.f64(); break;\n                        case CT_STRING: arg = r.str(); break;\n                        default: arg = null;\n                    }\n                    instructions.push(op);\n                    instructions.push(arg);\n                }\n                result[kI] = instructions;\n\n                // Jumps\n                if (flags & FB_JUMPS) {\n                    let jumpLen = r.varint();\n                    let jumps = {};\n                    for (let i = 0; i < jumpLen; i++) {\n                        let idx = r.varint();\n                        let target = r.varint();\n                        jumps[idx] = target;\n                    }\n                    result[kJ] = jumps;\n                }\n\n                // Exceptions\n                if (flags & FB_EXCEPT) {\n                    let excLen = r.varint();\n                    let exceptions = {};\n                    for (let i = 0; i < excLen; i++) {\n                        let idx = r.varint();\n                        let catchIdx = r.varint() - 1; // -1 to restore -1 case\n                        let finallyIdx = r.varint() - 1;\n                        let endIdx = r.varint() - 1;\n                        exceptions[idx] = [catchIdx, finallyIdx, endIdx];\n                    }\n                    result[kX] = exceptions;\n                }\n\n                return result;\n            }\n"
      }, t.getBinaryBytecodeAccessTemplate = function () {
        return "\n            // Bytecode access with binary decoding\n            let _bcCache = {};\n            function _getBytecode(id) {\n                if (_bcCache[id]) return _bcCache[id];\n                let raw = {vmBytecodeArrayName}[id];\n                if (typeof raw === 'string') {\n                    // Binary format - decode from base64\n                    _bcCache[id] = _decodeBinary(raw, {keyMappingRef});\n                } else {\n                    // Already an object (legacy JSON format)\n                    _bcCache[id] = raw;\n                }\n                return _bcCache[id];\n            }\n"
      }
    }, 7536: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.GlobalVariableTemplate1 = function () {
        return "\n        let that;\n        \n        try {\n            const getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    "
      }
    }, 7754: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SelfDefendingTemplate = function (e, t) {
        const r = e.getRandomString(6), o = e.getRandomString(6), n = e.getRandomString(6), i = e.getRandomString(6),
          a = e.getRandomString(6), s = e.getRandomString(6), c = e.getRandomString(6), l = e.getRandomString(6),
          d = e.getRandomString(6);
        return `\n        const StatesClass = function (${r}) {\n            this.${r} = ${r};\n            this.${o} = [1, 0, 0];\n            this.${n} = function(){return 'newState';};\n            this.${i} = '${t.encode("\\w+ *\\(\\) *{\\w+ *", !0)}';\n            this.${a} = '${t.encode("['|\"].+['|\"];? *}", !0)}';\n        };\n        \n        StatesClass.prototype.${s} = function () {\n            const regExp = new RegExp(this.${i} + this.${a});\n            const expression = regExp.test(this.${n}.toString())\n                ? --this.${o}[1]\n                : --this.${o}[0];\n            \n            return this.${c}(expression);\n        };\n        \n        StatesClass.prototype.${c} = function (${d}) {\n            if (!Boolean(~${d})) {\n                return ${d};\n            }\n            \n            return this.${l}(this.${r});\n        };\n\n        StatesClass.prototype.${l} = function (${r}) {\n            for (let i = 0, len = this.${o}.length; i < len; i++) {\n                this.${o}.push(Math.round(Math.random()));\n                len = this.${o}.length;\n            }\n            \n            return ${r}(this.${o}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${s}();\n    `
      }
    }, 7844: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getClassOpcodeTemplates = function () {
        return "\n                        // Class Operations (Getters/Setters)\n                        case opMap[145]: { // DEFINE_GETTER\n                            // Define a getter on an object or class prototype\n                            // Stack before: [object, getterFunction]\n                            // Stack after: [object] (with getter defined)\n                            // arg: property name index in constant pool\n                            let getterFunc = stack.pop();\n                            let getObj = stack[stack.length - 1]; // Peek at object (don't pop)\n                            let getPropName = constants[arg];\n                            // If getObj is a constructor (has prototype), define on prototype\n                            // Otherwise define on the object itself\n                            let getTarget = (typeof getObj === 'function' && getObj.prototype) ? getObj.prototype : getObj;\n                            Object.defineProperty(getTarget, getPropName, {\n                                get: getterFunc,\n                                enumerable: getTarget === getObj, // enumerable for objects, non-enumerable for prototypes\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[146]: { // DEFINE_SETTER\n                            // Define a setter on an object or class prototype\n                            // Stack before: [object, setterFunction]\n                            // Stack after: [object] (with setter defined)\n                            // arg: property name index in constant pool\n                            let setterFunc = stack.pop();\n                            let setObj = stack[stack.length - 1]; // Peek at object (don't pop)\n                            let setPropName = constants[arg];\n                            // If setObj is a constructor (has prototype), define on prototype\n                            // Otherwise define on the object itself\n                            let setTarget = (typeof setObj === 'function' && setObj.prototype) ? setObj.prototype : setObj;\n                            Object.defineProperty(setTarget, setPropName, {\n                                set: setterFunc,\n                                enumerable: setTarget === setObj, // enumerable for objects, non-enumerable for prototypes\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[140]: { // NEW_CLASS\n                            // Create a class constructor function\n                            // Stack before: [constructorFunc, className (or null)]\n                            // Stack after: [classConstructor]\n                            // arg: isDerived flag (0 = base class, 1 = derived class)\n                            let className = stack.pop();\n                            let ctorFunc = stack.pop();\n                            let isDerived = arg;\n\n                            // Create constructor function that calls the bytecode\n                            // IMPORTANT: Use IIFE to create proper closure scope\n                            // Without this, all ClassConstructors share the same className/ctorFunc variables!\n                            let ClassConstructor = (function(capturedClassName, capturedCtorFunc, capturedIsDerived) {\n                                // Create the constructor function\n                                let ConstructorFunc;\n                                if (capturedIsDerived) {\n                                    // DERIVED CLASS: Cannot access 'this' before super() is called\n                                    // The 'this' is in TDZ (Temporal Dead Zone) until super() initializes it\n                                    ConstructorFunc = function() {\n                                        if (capturedCtorFunc) {\n                                            // Inject __$$constructor$$__ as a special variable that the bytecode can access\n                                            // This allows super() to load the parent class from ConstructorFunc.__$$super$$__\n                                            // without needing to access 'this.constructor' (which would throw TDZ error)\n                                            {vmGlobalsName}['__$$constructor$$__'] = ConstructorFunc;\n                                            // Store new.target so VM executor can access it\n                                            // If already set by super() call, don't overwrite it\n                                            let hadNewTarget = '__$$newTarget$$__' in {vmGlobalsName};\n                                            if (!hadNewTarget) {\n                                                {vmGlobalsName}['__$$newTarget$$__'] = new.target;\n                                            }\n                                            try {\n                                                // DON'T use .apply(this, ...) because 'this' is uninitialized!\n                                                // Instead, call with proper binding where 'this' will be accessible\n                                                // after super() runs inside the bytecode\n                                                // Convert arguments to array\n                                                let ctorArgs = [];\n                                                for (let _loopIdx = 0; _loopIdx < arguments.length; _loopIdx++) {\n                                                    ctorArgs.push(arguments[_loopIdx]);\n                                                }\n                                                return capturedCtorFunc.apply(this, ctorArgs);\n                                            } finally {\n                                                // Clean up after constructor runs\n                                                delete {vmGlobalsName}['__$$constructor$$__'];\n                                                if (!hadNewTarget) {\n                                                    delete {vmGlobalsName}['__$$newTarget$$__'];\n                                                }\n                                            }\n                                        }\n                                    };\n                                } else {\n                                    // BASE CLASS: 'this' is created by 'new' operator\n                                    ConstructorFunc = function() {\n                                        // Call the constructor bytecode with proper 'this' binding\n                                        // If no constructor bytecode, return undefined and let 'new' operator return 'this'\n                                        if (capturedCtorFunc) {\n                                            // Store new.target so VM executor can access it\n                                            // If already set by super() call, don't overwrite it\n                                            let hadNewTarget = '__$$newTarget$$__' in {vmGlobalsName};\n                                            if (!hadNewTarget) {\n                                                {vmGlobalsName}['__$$newTarget$$__'] = new.target;\n                                            }\n                                            try {\n                                                // Convert arguments to array\n                                                let ctorArgs = [];\n                                                for (let _loopIdx = 0; _loopIdx < arguments.length; _loopIdx++) {\n                                                    ctorArgs.push(arguments[_loopIdx]);\n                                                }\n                                                return capturedCtorFunc.apply(this, ctorArgs);\n                                            } finally {\n                                                if (!hadNewTarget) {\n                                                    delete {vmGlobalsName}['__$$newTarget$$__'];\n                                                }\n                                            }\n                                        }\n                                        // No explicit return needed - constructor functions automatically return 'this' when called with 'new'\n                                    };\n                                }\n                                return ConstructorFunc;\n                            })(className, ctorFunc, isDerived);\n                            // Set constructor name if provided\n                            if (className) {\n                                Object.defineProperty(ClassConstructor, 'name', {\n                                    value: className,\n                                    configurable: true\n                                });\n                            }\n                            stack.push(ClassConstructor);\n\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[141]: { // CLASS_EXTENDS\n                            // Set up class inheritance\n                            // Stack before: [childClass, parentClass]\n                            // Stack after: [childClass] (with inheritance set up)\n                            // arg: not used\n                            let ParentClass = stack.pop();\n                            let ChildClass = stack[stack.length - 1]; // Peek (don't pop)\n\n                            // Set up prototype chain\n                            Object.setPrototypeOf(ChildClass.prototype, ParentClass.prototype);\n                            Object.setPrototypeOf(ChildClass, ParentClass);\n\n                            // Store parent class on the child class for super() to access\n                            // This prevents the multi-level inheritance bug where all classes\n                            // share the same global __$$super$$__ variable\n                            ChildClass.__$$super$$__ = ParentClass;\n\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[142]: { // GET_SUPER_PROP\n                            // Access super.property\n                            // Stack before: [this, propertyName]\n                            // Stack after: [value]\n                            // arg: not used (property name is on stack for dynamic access)\n                            let superPropName = stack.pop();\n                            let superThis = stack.pop();\n\n                            // Get the prototype of the current class's prototype\n                            let proto = Object.getPrototypeOf(Object.getPrototypeOf(superThis));\n\n                            // Check if it's a getter/setter\n                            let descriptor = Object.getOwnPropertyDescriptor(proto, superPropName);\n                            let superValue;\n\n                            if (descriptor && descriptor.get) {\n                                // It's a getter - call it with superThis as the context\n                                superValue = descriptor.get.call(superThis);\n                                stack.push(superValue);\n                            } else {\n                                // Regular property or method\n                                superValue = proto[superPropName];\n                                // If it's a method, bind it to 'this'\n                                if (typeof superValue === 'function') {\n                                    stack.push(superValue.bind(superThis));\n                                } else {\n                                    stack.push(superValue);\n                                }\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[143]: { // SET_SUPER_PROP\n                            // Set super.property = value\n                            // Stack before: [this, propertyName, value]\n                            // Stack after: [value]\n                            // arg: not used\n                            let superSetValue = stack.pop();\n                            let superSetPropName = stack.pop();\n                            let superSetThis = stack.pop();\n                            // Get the prototype of the current class's prototype\n                            let superSetProto = Object.getPrototypeOf(Object.getPrototypeOf(superSetThis));\n                            superSetProto[superSetPropName] = superSetValue;\n                            stack.push(superSetValue);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[144]: { // DEFINE_METHOD\n                            // Define a method on class prototype\n                            // Stack before: [class, methodFunction]\n                            // Stack after: [class] (with method defined on prototype)\n                            // arg: method name index in constant pool\n                            let methodFunc = stack.pop();\n                            let methodClass = stack[stack.length - 1]; // Peek (don't pop)\n                            let methodName = constants[arg];\n\n\n                            Object.defineProperty(methodClass.prototype, methodName, {\n                                value: methodFunc,\n                                writable: true,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[147]: { // DEFINE_STATIC_METHOD\n                            // Define a static method on class constructor\n                            // Stack before: [class, methodFunction]\n                            // Stack after: [class] (with static method defined on class itself)\n                            // arg: method name index in constant pool\n                            let staticMethodFunc = stack.pop();\n                            let staticMethodClass = stack[stack.length - 1]; // Peek (don't pop)\n                            let staticMethodName = constants[arg];\n\n                            Object.defineProperty(staticMethodClass, staticMethodName, {\n                                value: staticMethodFunc,\n                                writable: true,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[148]: { // DEFINE_STATIC_GETTER\n                            // Define a static getter on class constructor\n                            // Stack before: [class, getterFunction]\n                            // Stack after: [class] (with static getter defined on class itself)\n                            // arg: property name index in constant pool\n                            let staticGetterFunc = stack.pop();\n                            let staticGetterClass = stack[stack.length - 1]; // Peek (don't pop)\n                            let staticGetterName = constants[arg];\n\n                            Object.defineProperty(staticGetterClass, staticGetterName, {\n                                get: staticGetterFunc,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[149]: { // DEFINE_STATIC_SETTER\n                            // Define a static setter on class constructor\n                            // Stack before: [class, setterFunction]\n                            // Stack after: [class] (with static setter defined on class itself)\n                            // arg: property name index in constant pool\n                            let staticSetterFunc = stack.pop();\n                            let staticSetterClass = stack[stack.length - 1]; // Peek (don't pop)\n                            let staticSetterName = constants[arg];\n\n                            Object.defineProperty(staticSetterClass, staticSetterName, {\n                                set: staticSetterFunc,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[170]: { // DEFINE_METHOD_COMPUTED\n                            // Define method with computed property name (name on stack)\n                            // Stack before: [class, methodName, methodFunction]\n                            // Stack after: [class]\n                            let computedMethodFunc = stack.pop();\n                            let computedMethodName = stack.pop();\n                            let computedMethodClass = stack[stack.length - 1]; // Peek\n\n                            Object.defineProperty(computedMethodClass.prototype, computedMethodName, {\n                                value: computedMethodFunc,\n                                writable: true,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[171]: { // DEFINE_STATIC_METHOD_COMPUTED\n                            // Define static method with computed property name\n                            // Stack before: [class, methodName, methodFunction]\n                            // Stack after: [class]\n                            let computedStaticMethodFunc = stack.pop();\n                            let computedStaticMethodName = stack.pop();\n                            let computedStaticMethodClass = stack[stack.length - 1]; // Peek\n\n                            Object.defineProperty(computedStaticMethodClass, computedStaticMethodName, {\n                                value: computedStaticMethodFunc,\n                                writable: true,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[172]: { // DEFINE_GETTER_COMPUTED\n                            // Define getter with computed property name\n                            // Stack before: [object/class, propName, getterFunction]\n                            // Stack after: [object/class]\n                            let computedGetterFunc = stack.pop();\n                            let computedGetterName = stack.pop();\n                            let computedGetterObj = stack[stack.length - 1]; // Peek\n                            // If target is a constructor (has prototype), define on prototype\n                            // Otherwise define on the object itself (for object literals)\n                            let computedGetterTarget = (typeof computedGetterObj === 'function' && computedGetterObj.prototype) ? computedGetterObj.prototype : computedGetterObj;\n\n                            Object.defineProperty(computedGetterTarget, computedGetterName, {\n                                get: computedGetterFunc,\n                                enumerable: computedGetterTarget === computedGetterObj, // enumerable for objects, non-enumerable for prototypes\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[173]: { // DEFINE_SETTER_COMPUTED\n                            // Define setter with computed property name\n                            // Stack before: [object/class, propName, setterFunction]\n                            // Stack after: [object/class]\n                            let computedSetterFunc = stack.pop();\n                            let computedSetterName = stack.pop();\n                            let computedSetterObj = stack[stack.length - 1]; // Peek\n                            // If target is a constructor (has prototype), define on prototype\n                            // Otherwise define on the object itself (for object literals)\n                            let computedSetterTarget = (typeof computedSetterObj === 'function' && computedSetterObj.prototype) ? computedSetterObj.prototype : computedSetterObj;\n\n                            Object.defineProperty(computedSetterTarget, computedSetterName, {\n                                set: computedSetterFunc,\n                                enumerable: computedSetterTarget === computedSetterObj, // enumerable for objects, non-enumerable for prototypes\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[174]: { // DEFINE_STATIC_GETTER_COMPUTED\n                            // Define static getter with computed property name\n                            // Stack before: [class, propName, getterFunction]\n                            // Stack after: [class]\n                            let computedStaticGetterFunc = stack.pop();\n                            let computedStaticGetterName = stack.pop();\n                            let computedStaticGetterClass = stack[stack.length - 1]; // Peek\n\n                            Object.defineProperty(computedStaticGetterClass, computedStaticGetterName, {\n                                get: computedStaticGetterFunc,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[175]: { // DEFINE_STATIC_SETTER_COMPUTED\n                            // Define static setter with computed property name\n                            // Stack before: [class, propName, setterFunction]\n                            // Stack after: [class]\n                            let computedStaticSetterFunc = stack.pop();\n                            let computedStaticSetterName = stack.pop();\n                            let computedStaticSetterClass = stack[stack.length - 1]; // Peek\n\n                            Object.defineProperty(computedStaticSetterClass, computedStaticSetterName, {\n                                set: computedStaticSetterFunc,\n                                enumerable: false,\n                                configurable: true\n                            });\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 7883: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebuggerTemplateNoEval = function () {
        return "\n        if (typeof counter === 'string') {\n            const func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    "
      }
    }, 7962: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AtobTemplate = function (e) {
        return `\n        var {atobFunctionName} = function (input) {\n            const chars = '${o.base64alphabetSwapped}';\n\n            let output = '';\n            let tempEncodedString = '';\n            ${e ? "let func = output + {atobFunctionName};" : ""}\n            \n            for (\n                let bc = 0, bs, buffer, idx = 0;\n                buffer = input.charAt(idx++);\n                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4)\n                    ? output += ${(() => {
          const t = "String.fromCharCode(255 & bs >> (-2 * bc & 6))";
          return e ? `((func.charCodeAt(idx + 10) - 10 !== 0) ? ${t} : bc)` : t
        })()}\n                    : 0\n            ) {\n                buffer = chars.indexOf(buffer);\n            }\n            \n             for (let k = 0, length = output.length; k < length; k++) {\n                tempEncodedString += '%' + ('00' + output.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            return decodeURIComponent(tempEncodedString);\n        };\n    `
      };
      const o = r(38606)
    }, 8041: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionControlFlowStorage = void 0;
      const l = r(45337), d = r(31391), p = r(18741), u = r(76393), f = r(31142), m = r(48720);
      let g = class extends m.MapStorage {
        constructor(e, t, r) {
          super(e, t), this.identifierNamesGenerator = r(t)
        }
      };
      t.FunctionControlFlowStorage = g, t.FunctionControlFlowStorage = g = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), c(2, (0, l.inject)(d.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), s("design:paramtypes", ["function" == typeof (o = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== u.IOptions && u.IOptions) ? n : Object, "function" == typeof (i = void 0 !== p.TIdentifierNamesGeneratorFactory && p.TIdentifierNamesGeneratorFactory) ? i : Object])], g)
    }, 8053: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractCustomNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142);
      let h = class {
        constructor(e, t, r, o) {
          this.cachedNode = null, this.identifierNamesGenerator = e(o), this.customCodeHelperFormatter = t, this.randomGenerator = r, this.options = o
        }

        getNode() {
          return this.cachedNode || (this.cachedNode = this.customCodeHelperFormatter.formatStructure(this.getNodeStructure())), this.cachedNode
        }
      };
      t.AbstractCustomNode = h, t.AbstractCustomNode = h = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], h)
    }, 8492: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VisitedLexicalScopeNodesStackStorage = void 0;
      const l = r(45337), d = r(31391), p = r(26906), u = r(76393), f = r(31142), m = r(62957);
      let g = class extends m.ArrayStorage {
        constructor(e, t, r) {
          super(e, t), this.arrayUtils = r
        }

        getLastElement() {
          return this.arrayUtils.getLastElement(this.getStorage())
        }

        getPenultimateElement() {
          return this.arrayUtils.getLastElementByIndex(this.getStorage(), 1)
        }

        push(e) {
          const t = this.getLength();
          this.set(t, e)
        }

        pop() {
          const e = this.getLength();
          return this.delete(e - 1)
        }
      };
      t.VisitedLexicalScopeNodesStackStorage = g, t.VisitedLexicalScopeNodesStackStorage = g = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), c(2, (0, l.inject)(d.ServiceIdentifiers.IArrayUtils)), s("design:paramtypes", ["function" == typeof (o = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== u.IOptions && u.IOptions) ? n : Object, "function" == typeof (i = void 0 !== p.IArrayUtils && p.IArrayUtils) ? i : Object])], g)
    }, 8759: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IdentifierReplacer = void 0;
      const l = r(45337), d = r(31391), p = r(18741), u = r(10808), f = r(76393), m = r(93571);
      let g = class {
        constructor(e, t, r) {
          this.blockScopesMap = new WeakMap, this.options = r, this.identifierNamesCacheStorage = t, this.identifierNamesGenerator = e(r)
        }

        storeGlobalName(e, t) {
          var r;
          const o = e.name;
          if (this.isReservedName(o)) return;
          const n = this.identifierNamesGenerator.generateForGlobalScope(),
            i = null !== (r = this.blockScopesMap.get(t)) && void 0 !== r ? r : new Map;
          i.set(o, n), this.blockScopesMap.set(t, i), this.options.identifierNamesCache && this.identifierNamesCacheStorage.set(o, n)
        }

        storeLocalName(e, t) {
          var r;
          const o = e.name;
          if (this.isReservedName(o)) return;
          const n = this.identifierNamesGenerator.generateForLexicalScope(t),
            i = null !== (r = this.blockScopesMap.get(t)) && void 0 !== r ? r : new Map;
          i.set(o, n), this.blockScopesMap.set(t, i)
        }

        replace(e, t) {
          var r, o;
          const n = null !== (r = this.blockScopesMap.get(t)) && void 0 !== r ? r : null;
          if (!n) return e;
          const i = null !== (o = n.get(e.name)) && void 0 !== o ? o : null;
          return i ? m.NodeFactory.identifierNode(i) : e
        }

        preserveName(e) {
          this.identifierNamesGenerator.preserveName(e.name)
        }

        preserveNameForLexicalScope(e, t) {
          this.identifierNamesGenerator.preserveNameForLexicalScope(e.name, t)
        }

        isReservedName(e) {
          return !!this.options.reservedNames.length && this.options.reservedNames.some(t => null !== new RegExp(t, "g").exec(e))
        }
      };
      t.IdentifierReplacer = g, t.IdentifierReplacer = g = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IGlobalIdentifierNamesCacheStorage)), c(2, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (o = void 0 !== p.TIdentifierNamesGeneratorFactory && p.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== u.IGlobalIdentifierNamesCacheStorage && u.IGlobalIdentifierNamesCacheStorage) ? n : Object, "function" == typeof (i = void 0 !== f.IOptions && f.IOptions) ? i : Object])], g)
    }, 9328: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MangledShuffledIdentifierNamesGenerator = void 0;
      const p = r(45337), u = r(31391), f = r(26906), m = r(76393), g = r(31142), h = r(82797), y = r(36869),
        S = r(55194), N = r(6088), b = r(47351);
      let _ = o = class extends b.MangledIdentifierNamesGenerator {
        constructor(e, t, r, o) {
          super(t, r, o), this.arrayUtils = e
        }

        initialize() {
          this.initializeNameSequence([...`${y.numbersString}`, ...this.arrayUtils.shuffle([...`${S.alphabetString}${N.alphabetStringUppercase}`])])
        }

        initializeNameSequence(e) {
          this.getNameSequence() || (o.shuffledNameSequence = e)
        }

        getNameSequence() {
          return o.shuffledNameSequence
        }
      };
      t.MangledShuffledIdentifierNamesGenerator = _, c([(0, p.postConstruct)(), l("design:type", Function), l("design:paramtypes", []), l("design:returntype", void 0)], _.prototype, "initialize", null), t.MangledShuffledIdentifierNamesGenerator = _ = o = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.IArrayUtils)), d(1, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IOptions)), d(3, (0, p.inject)(u.ServiceIdentifiers.ISetUtils)), l("design:paramtypes", ["function" == typeof (n = void 0 !== f.IArrayUtils && f.IArrayUtils) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object, "function" == typeof (s = void 0 !== h.ISetUtils && h.ISetUtils) ? s : Object])], _)
    }, 9955: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.PrevailingKindOfVariablesAnalyzer = void 0;
      const u = r(45337), f = r(31391), m = l(r(31659)), g = r(26906), h = r(27391);
      let y = n = class {
        constructor(e) {
          this.prevailingKindOfVariables = n.defaultKindOfVariables, this.arrayUtils = e
        }

        analyze(e) {
          var t;
          const r = [];
          m.traverse(e, {
            enter: e => {
              h.NodeGuards.isVariableDeclarationNode(e) && r.push(e.kind)
            }
          }), this.prevailingKindOfVariables = null !== (t = this.arrayUtils.findMostOccurringElement(r)) && void 0 !== t ? t : n.defaultKindOfVariables
        }

        getPrevailingKind() {
          return this.prevailingKindOfVariables
        }
      };
      t.PrevailingKindOfVariablesAnalyzer = y, y.defaultKindOfVariables = "var", t.PrevailingKindOfVariablesAnalyzer = y = n = c([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.IArrayUtils)), d("design:paramtypes", ["function" == typeof (i = void 0 !== g.IArrayUtils && g.IArrayUtils) ? i : Object])], y)
    }, 10192: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMConstantPool = void 0;
      const n = r(45337);
      let i = class {
        constructor() {
          this.constants = [], this.constantMap = new Map
        }

        add(e) {
          const t = this.getConstantKey(e), r = this.constantMap.get(t);
          if (void 0 !== r) return r;
          const o = this.constants.length;
          return this.constants.push(e), this.constantMap.set(t, o), o
        }

        forceAdd(e) {
          const t = this.constants.length;
          return this.constants.push(e), t
        }

        get(e) {
          return this.constants[e]
        }

        getAll() {
          return [...this.constants]
        }

        getLength() {
          return this.constants.length
        }

        clear() {
          this.constants = [], this.constantMap.clear()
        }

        reset() {
          this.clear()
        }

        getConstantKey(e) {
          if (null === e) return "null";
          if (void 0 === e) return "undefined";
          if (e instanceof RegExp) return `regex:${e.source}:${e.flags}`;
          switch (typeof e) {
            case"string":
              return `string:${e}`;
            case"number":
              return `number:${e}`;
            case"bigint":
              return `bigint:${e}`;
            case"boolean":
              return `boolean:${e}`;
            default:
              return `unknown:${String(e)}`
          }
        }
      };
      t.VMConstantPool = i, t.VMConstantPool = i = o([(0, n.injectable)()], i)
    }, 10419: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractIdentifierNamesGenerator = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(27391);
      let f = class {
        constructor(e, t) {
          this.preservedNamesSet = new Set, this.lexicalScopesPreservedNamesMap = new WeakMap, this.randomGenerator = e, this.options = t
        }

        generate(e, t) {
          return u.NodeGuards.isProgramNode(e) ? this.generateForGlobalScope() : this.generateForLexicalScope(e)
        }

        preserveName(e) {
          this.preservedNamesSet.add(e)
        }

        preserveNameForLexicalScope(e, t) {
          var r;
          const o = null !== (r = this.lexicalScopesPreservedNamesMap.get(t)) && void 0 !== r ? r : new Set;
          o.add(e), this.lexicalScopesPreservedNamesMap.set(t, o)
        }

        isValidIdentifierName(e) {
          return !this.isReservedName(e) && !this.preservedNamesSet.has(e)
        }

        isValidIdentifierNameInLexicalScopes(e, t) {
          var r;
          if (!this.isValidIdentifierName(e)) return !1;
          for (const o of t) {
            const t = null !== (r = this.lexicalScopesPreservedNamesMap.get(o)) && void 0 !== r ? r : null;
            if (t && t.has(e)) return !1
          }
          return !0
        }

        isReservedName(e) {
          return !!this.options.reservedNames.length && this.options.reservedNames.some(t => null !== new RegExp(t, "g").exec(e))
        }
      };
      t.AbstractIdentifierNamesGenerator = f, t.AbstractIdentifierNamesGenerator = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], f)
    }, 10808: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 11688: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ConsoleOutputDisableTemplate = function () {
        return "\n        const {consoleLogDisableFunctionName} = {callControllerFunctionName}(this, function () {\n            {globalVariableTemplate}\n\n            const consoleObject = (that.console = that.console || {});\n            const methods = ['log', 'warn', 'info', 'error', 'exception', 'table', 'trace'];\n\n            for (let index = 0; index < methods.length; index++){\n                const func = {callControllerFunctionName}.constructor.prototype.bind({callControllerFunctionName});\n                const methodName = methods[index];\n                const originalFunction = consoleObject[methodName] || func;\n\n                func.__proto__ = {callControllerFunctionName}.bind({callControllerFunctionName});\n                func.toString = originalFunction.toString.bind(originalFunction);\n                \n                consoleObject[methodName] = func;\n            }\n        });\n\n        {consoleLogDisableFunctionName}();\n    "
      }
    }, 12414: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomainLockTemplate = function () {
        return '\n        const {domainLockFunctionName} = {callControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            const regExp = new RegExp("[{domainsStringDiff}]", "g");\n            const domains = "{domains}".replace(regExp, "").split(";");\n            let document;\n            let domain;\n            let location;\n            let hostname;\n\n            const isName = function(name, length, cs) {\n                if (name.length != length) {\n                    return false;\n                }\n\n                for (let i = 0; i < length; i++) {\n                    for (let j = 0; j < cs.length; j += 2) {\n                        if (i == cs[j] && name.charCodeAt(i) != cs[j+1]) {\n                            return false;\n                        }\n                    }\n                }\n\n                return true;\n            };\n\n            const isNameVariant1 = function(cs, name, length) {\n              return isName(name, length, cs);\n            };\n\n            const isNameVariant2 = function(name, cs, length) {\n              return isNameVariant1(cs, name, length);\n            };\n\n            const isNameVariant3 = function(length, name, cs) {\n              return isNameVariant2(name, cs, length);\n            };\n\n            for (let d in that) {\n                if (isName(d, 8, [7, 116, 5, 101, 3, 117, 0, 100])) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (let d1 in that[document]) {\n                if (isNameVariant3(6, d1, [5, 110, 0, 100])) {\n                    domain = d1;\n\n                    break;\n                }\n            }\n\n            for (let d2 in that[document]) {\n                if (isNameVariant2(d2, [7, 110, 0, 108], 8)) {\n                    location = d2;\n\n                    break;\n                }\n            }\n\n            if (!("~" > domain)) {\n                for (let d3 in that[document][location]) {\n                    if (isNameVariant1([7, 101, 0, 104], d3, 8)) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            const documentDomain = that[document][domain];\n            const documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            const currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            let ok = false;\n                        \n            for (let i = 0; i < domains.length; i++) {\n                const domain = domains[i];\n                const domainNormalized = domain[0] === String.fromCharCode(46)\n                    ? domain.slice(1)\n                    : domain;\n                const position = currentDomain.length - domainNormalized.length;\n                const lastIndex = currentDomain.indexOf(domainNormalized, position);\n                const endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(".") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n\n            if (!ok) {\n                const regExp2 = new RegExp("[{domainLockRedirectUrlDiff}]", "g");\n                const domainLockRedirectUrl = "{hiddenDomainLockRedirectUrl}".replace(regExp2, "");\n\n                that[document][location] = domainLockRedirectUrl;\n            }\n        });\n\n        {domainLockFunctionName}();\n    '
      }
    }, 12422: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ConditionalCommentObfuscatingGuard = void 0;
      const i = r(45337), a = r(62467), s = r(27391);
      let c = o = class {
        constructor() {
          this.obfuscationAllowed = !0
        }

        static isConditionalComment(e) {
          return o.obfuscationEnableCommentRegExp.test(e.value) || o.obfuscationDisableCommentRegExp.test(e.value)
        }

        check(e) {
          if (s.NodeGuards.isNodeWithComments(e)) {
            const t = e.leadingComments;
            t && (this.obfuscationAllowed = this.checkComments(t))
          }
          return this.obfuscationAllowed ? a.ObfuscatingGuardResult.Transform : a.ObfuscatingGuardResult.Ignore
        }

        checkComments(e) {
          const t = e.length;
          let r = this.obfuscationAllowed;
          for (let n = 0; n < t; n++) {
            const t = e[n];
            o.obfuscationEnableCommentRegExp.test(t.value) ? r = !0 : o.obfuscationDisableCommentRegExp.test(t.value) && (r = !1)
          }
          return r
        }
      };
      t.ConditionalCommentObfuscatingGuard = c, c.obfuscationEnableCommentRegExp = new RegExp("javascript-obfuscator *: *enable"), c.obfuscationDisableCommentRegExp = new RegExp("javascript-obfuscator *: *disable"), t.ConditionalCommentObfuscatingGuard = c = o = n([(0, i.injectable)()], c)
    }, 12457: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionFunctionCallCodeHelper = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(39032), g = r(25714), h = r(76393), y = r(31142),
        S = r(50164), N = r(75276), b = r(48222), _ = r(33056);
      let v = class extends b.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t) {
          this.debugProtectionFunctionName = e, this.callsControllerFunctionName = t
        }

        getNodeStructure(e) {
          return _.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          return this.customCodeHelperFormatter.formatTemplate((0, N.DebugProtectionFunctionCallTemplate)(), {
            debugProtectionFunctionName: this.debugProtectionFunctionName,
            callControllerFunctionName: this.callsControllerFunctionName
          })
        }
      };
      t.DebugProtectionFunctionCallCodeHelper = v, c([(0, S.initializable)(), l("design:type", String)], v.prototype, "callsControllerFunctionName", void 0), c([(0, S.initializable)(), l("design:type", String)], v.prototype, "debugProtectionFunctionName", void 0), t.DebugProtectionFunctionCallCodeHelper = v = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperObfuscator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== h.IOptions && h.IOptions) ? s : Object])], v)
    }, 12731: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ControlFlowStorageNode = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(3437), g = r(39032), h = r(76393), y = r(31142),
        S = r(50164), N = r(8053), b = r(93571), _ = r(27391);
      let v = class extends N.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e) {
          this.controlFlowStorage = e
        }

        getNodeStructure() {
          const e = [], t = this.controlFlowStorage.getStorage();
          for (const [r, o] of t) {
            const t = o.getNode()[0];
            if (!_.NodeGuards.isExpressionStatementNode(t)) throw new Error("Function node for control flow storage object should be passed inside the `ExpressionStatement` node!");
            e.push(b.NodeFactory.propertyNode(b.NodeFactory.identifierNode(r), t.expression))
          }
          return [b.NodeFactory.variableDeclarationNode([b.NodeFactory.variableDeclaratorNode(b.NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()), b.NodeFactory.objectExpressionNode(e))], "const")]
        }
      };
      t.ControlFlowStorageNode = v, c([(0, S.initializable)(), l("design:type", "function" == typeof (s = void 0 !== m.IControlFlowStorage && m.IControlFlowStorage) ? s : Object)], v.prototype, "controlFlowStorage", void 0), t.ControlFlowStorageNode = v = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== g.ICustomCodeHelperFormatter && g.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== h.IOptions && h.IOptions) ? a : Object])], v)
    }, 12839: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.renamePropertiesTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(3464), s = r(55208);
      t.renamePropertiesTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(s.RenamePropertiesTransformer).whenTargetNamed(i.NodeTransformer.RenamePropertiesTransformer), e(n.ServiceIdentifiers.IRenamePropertiesReplacer).to(a.RenamePropertiesReplacer)
      })
    }, 12928: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObfuscationResult = void 0;
      const d = r(45337), p = r(31391), u = r(70793), f = r(10808), m = r(59290), g = r(76393), h = r(50164),
        y = r(64858);
      let S = class {
        constructor(e, t, r, o) {
          this.cryptUtils = e, this.globalIdentifierNamesCacheStorage = t, this.propertyIdentifierNamesCacheStorage = r, this.options = o
        }

        initialize(e, t) {
          this.obfuscatedCode = e, this.sourceMap = t
        }

        getIdentifierNamesCache() {
          return this.options.identifierNamesCache ? {
            globalIdentifiers: this.globalIdentifierNamesCacheStorage.getStorageAsDictionary(),
            propertyIdentifiers: this.propertyIdentifierNamesCacheStorage.getStorageAsDictionary()
          } : null
        }

        getObfuscatedCode() {
          return this.correctObfuscatedCode()
        }

        getOptions() {
          return this.options
        }

        getSourceMap() {
          return this.sourceMap
        }

        toString() {
          return this.obfuscatedCode
        }

        correctObfuscatedCode() {
          if (!this.sourceMap) return this.obfuscatedCode;
          const e = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;
          let t = "//# sourceMappingURL=";
          switch (this.options.sourceMapMode) {
            case y.SourceMapMode.Inline:
              t += `data:application/json;base64,${this.cryptUtils.btoa(this.sourceMap)}`;
              break;
            case y.SourceMapMode.Separate:
            default:
              if (!e) return this.obfuscatedCode;
              t += e
          }
          return `${this.obfuscatedCode}\n${t}`
        }
      };
      t.ObfuscationResult = S, s([(0, h.initializable)(), c("design:type", String)], S.prototype, "obfuscatedCode", void 0), s([(0, h.initializable)(), c("design:type", String)], S.prototype, "sourceMap", void 0), t.ObfuscationResult = S = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.ICryptUtils)), l(1, (0, d.inject)(p.ServiceIdentifiers.IGlobalIdentifierNamesCacheStorage)), l(2, (0, d.inject)(p.ServiceIdentifiers.IPropertyIdentifierNamesCacheStorage)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.ICryptUtils && u.ICryptUtils) ? o : Object, "function" == typeof (n = void 0 !== f.IGlobalIdentifierNamesCacheStorage && f.IGlobalIdentifierNamesCacheStorage) ? n : Object, "function" == typeof (i = void 0 !== m.IPropertyIdentifierNamesCacheStorage && m.IPropertyIdentifierNamesCacheStorage) ? i : Object, "function" == typeof (a = void 0 !== g.IOptions && g.IOptions) ? a : Object])], S)
    }, 12951: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayRule = void 0;
      const o = r(20965);
      t.StringArrayRule = e => (e.stringArray || (e = {
        ...e,
        stringArray: !1,
        stringArrayCallsTransform: !1,
        stringArrayCallsTransformThreshold: 0,
        stringArrayEncoding: [o.StringArrayEncoding.None],
        stringArrayIndexShift: !1,
        stringArrayRotate: !1,
        stringArrayShuffle: !1,
        stringArrayWrappersChainedCalls: !1,
        stringArrayWrappersCount: 0,
        stringArrayThreshold: 0
      }), e)
    }, 13014: function (e, t, r) {
      var o, n, i, a, s = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), c = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && s(t, e, r[n]);
        return c(t, e), t
      }), p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CommentsTransformer = void 0;
      const f = r(45337), m = r(31391), g = d(r(31659)), h = r(76393), y = r(31142), S = r(75716), N = r(13245),
        b = r(12422), _ = r(27391);
      let v = n = class extends N.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          switch (e) {
            case S.NodeTransformationStage.Initializing:
              return {
                leave: e => {
                  if (_.NodeGuards.isProgramNode(e)) return this.transformNode(e)
                }
              };
            case S.NodeTransformationStage.Finalizing:
              return {
                leave: e => {
                  if (_.NodeGuards.isProgramNode(e)) return this.filterCommentsOnFinalizingTraverse(e)
                }
              };
            default:
              return null
          }
        }

        transformNode(e) {
          var t;
          if (!(null === (t = (e = this.filterCommentsOnPrimaryTraverse(e)).comments) || void 0 === t ? void 0 : t.length)) return e;
          const r = e.comments.reverse();
          if (0 === r.length) return e;
          if (!e.body.length) return e.leadingComments = r, e;
          let o = !0;
          return g.traverse(e, {
            enter: t => {
              if (t === e) return;
              const n = r.findIndex(e => e.range && t.range && e.range[0] < t.range[0]);
              n >= 0 && ((o ? e : t).leadingComments = r.splice(n, r.length - n).reverse()), o = !1
            }
          }), r.length > 0 && (e.trailingComments = r.reverse()), e
        }

        filterCommentsOnPrimaryTraverse(e) {
          var t;
          return e.comments = null === (t = e.comments) || void 0 === t ? void 0 : t.filter(e => this.filterComment(e, !0)), e
        }

        filterCommentsOnFinalizingTraverse(e) {
          return g.replace(e, {
            enter: e => {
              var t, r;
              return e.leadingComments && (e.leadingComments = null === (t = e.leadingComments) || void 0 === t ? void 0 : t.filter(e => this.filterComment(e, !1))), e.trailingComments && (e.trailingComments = null === (r = e.trailingComments) || void 0 === r ? void 0 : r.filter(e => this.filterComment(e, !1))), e
            }
          }), e
        }

        filterComment(e, t) {
          return !(!t || !b.ConditionalCommentObfuscatingGuard.isConditionalComment(e)) || n.preservedWords.some(t => e.value.includes(t))
        }
      };
      t.CommentsTransformer = v, v.preservedWords = ["@license", "@preserve"], t.CommentsTransformer = v = n = l([(0, f.injectable)(), u(0, (0, f.inject)(m.ServiceIdentifiers.IRandomGenerator)), u(1, (0, f.inject)(m.ServiceIdentifiers.IOptions)), p("design:paramtypes", ["function" == typeof (i = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== h.IOptions && h.IOptions) ? a : Object])], v)
    }, 13245: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractNodeTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142);
      let u = class {
        constructor(e, t) {
          this.randomGenerator = e, this.options = t
        }
      };
      t.AbstractNodeTransformer = u, t.AbstractNodeTransformer = u = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], u)
    }, 13328: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayRotateFunctionCodeHelper = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(39032), g = r(25714), h = r(76393), y = r(31142),
        S = r(50164), N = r(25220), b = r(48222), _ = r(33056);
      let v = class extends b.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t, r) {
          this.stringArrayFunctionName = e, this.comparisonValue = t, this.comparisonExpressionNode = r
        }

        getNodeStructure(e) {
          return _.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          const e = _.NodeUtils.convertStructureToCode([this.comparisonExpressionNode]);
          return this.customCodeHelperFormatter.formatTemplate((0, N.StringArrayRotateFunctionTemplate)(), {
            comparisonExpressionCode: e,
            comparisonValue: this.comparisonValue,
            stringArrayFunctionName: this.stringArrayFunctionName
          })
        }
      };
      t.StringArrayRotateFunctionCodeHelper = v, c([(0, S.initializable)(), l("design:type", Number)], v.prototype, "comparisonValue", void 0), c([(0, S.initializable)(), l("design:type", Object)], v.prototype, "comparisonExpressionNode", void 0), c([(0, S.initializable)(), l("design:type", String)], v.prototype, "stringArrayFunctionName", void 0), t.StringArrayRotateFunctionCodeHelper = v = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperObfuscator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== h.IOptions && h.IOptions) ? s : Object])], v)
    }, 13802: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DeadCodeInjectionThresholdRule = void 0, t.DeadCodeInjectionThresholdRule = e => (0 === e.deadCodeInjectionThreshold && (e = {
        ...e,
        deadCodeInjection: !1,
        deadCodeInjectionThreshold: 0
      }), e)
    }, 14698: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.GlobalVariableNoEvalTemplate = function () {
        return "\n        const that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    "
      }
    }, 14838: function (e, t, r) {
      var o, n, i, a, s = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), c = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && s(t, e, r[n]);
        return c(t, e), t
      }), p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LabeledStatementTransformer = void 0;
      const f = r(45337), m = r(31391), g = d(r(31659)), h = r(51353), y = r(76393), S = r(31142), N = r(75716),
        b = r(13245), _ = r(27391), v = r(75096);
      let I = class extends b.AbstractNodeTransformer {
        constructor(e, t, r) {
          super(t, r), this.identifierReplacer = e
        }

        getVisitor(e) {
          return e === N.NodeTransformationStage.RenameIdentifiers ? {
            enter: (e, t) => {
              if (t && _.NodeGuards.isLabeledStatementNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          const r = v.NodeLexicalScopeUtils.getLexicalScope(e);
          return r ? (this.storeLabeledStatementName(e, r), this.replaceLabeledStatementName(e, r), e) : e
        }

        storeLabeledStatementName(e, t) {
          this.identifierReplacer.storeLocalName(e.label, t)
        }

        replaceLabeledStatementName(e, t) {
          g.replace(e, {
            enter: (e, r) => {
              if (r && _.NodeGuards.isLabelIdentifierNode(e, r)) {
                const r = this.identifierReplacer.replace(e, t);
                e.name = r.name
              }
            }
          })
        }
      };
      t.LabeledStatementTransformer = I, t.LabeledStatementTransformer = I = l([(0, f.injectable)(), u(0, (0, f.inject)(m.ServiceIdentifiers.IIdentifierReplacer)), u(1, (0, f.inject)(m.ServiceIdentifiers.IRandomGenerator)), u(2, (0, f.inject)(m.ServiceIdentifiers.IOptions)), p("design:paramtypes", ["function" == typeof (n = void 0 !== h.IIdentifierReplacer && h.IIdentifierReplacer) ? n : Object, "function" == typeof (i = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== y.IOptions && y.IOptions) ? a : Object])], I)
    }, 14932: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeTransformationStage = void 0, function (e) {
        e.PreparingTransformers = "PreparingTransformers", e.FinalizingTransformers = "FinalizingTransformers"
      }(r || (t.CodeTransformationStage = r = {}))
    }, 15200: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 15914: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 16077: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.vmTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(79148), s = r(64717), c = r(31307), l = r(54651),
        d = r(80904), p = r(70072), u = r(78102), f = r(2878), m = r(56684), g = r(91098), h = r(1896), y = r(96974),
        S = r(97910), N = r(54966), b = r(89492), _ = r(60907), v = r(99176), I = r(79286), O = r(88527), C = r(16187),
        E = r(84011), T = r(43636), R = r(18789), M = r(64395), A = r(68581), F = r(74529), P = r(75851), D = r(35826);
      t.vmTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(_.VMTransformer).whenTargetNamed(i.NodeTransformer.VMTransformer), e(n.ServiceIdentifiers.IVMDestructuringBytecodeCompiler).to(a.VMDestructuringBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMExpressionBytecodeCompiler).to(s.VMExpressionBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMFunctionBytecodeCompiler).to(c.VMFunctionBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMClassBytecodeCompiler).to(l.VMClassBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMLiteralBytecodeCompiler).to(d.VMLiteralBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMParameterBytecodeCompiler).to(p.VMParameterBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMStatementBytecodeCompiler).to(u.VMStatementBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMLoopCompiler).to(f.VMLoopCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMConditionalCompiler).to(m.VMConditionalCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMExceptionCompiler).to(g.VMExceptionCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMDeclarationCompiler).to(h.VMDeclarationCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMOperatorCompiler).to(y.VMOperatorCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMAssignmentCompiler).to(S.VMAssignmentCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMCallCompiler).to(N.VMCallCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMMemberAccessCompiler).to(b.VMMemberAccessCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMBytecodeCompiler).to(v.VMBytecodeCompiler).inSingletonScope(), e(n.ServiceIdentifiers.IVMCompilerUtils).to(I.VMCompilerUtils).inSingletonScope(), e(n.ServiceIdentifiers.IVMVariableCollector).to(O.VMVariableCollector).inSingletonScope(), e(n.ServiceIdentifiers.IVMClosureAnalyzer).to(C.VMClosureAnalyzer).inSingletonScope(), e(n.ServiceIdentifiers.IVMGlobalStorageUtils).to(E.VMGlobalStorageUtils).inSingletonScope(), e(n.ServiceIdentifiers.IVMVariableResolver).to(T.VMVariableResolver).inSingletonScope(), e(n.ServiceIdentifiers.IVMScopeManager).to(R.VMScopeManager).inSingletonScope(), e(n.ServiceIdentifiers.IVMFunctionSelector).to(M.VMFunctionSelector).inSingletonScope(), e(n.ServiceIdentifiers.IVMBytecodeStorage).to(P.VMBytecodeStorage).inSingletonScope(), e(n.ServiceIdentifiers.IVMDeadCodeInjector).to(A.VMDeadCodeInjector).inSingletonScope(), e(n.ServiceIdentifiers.IVMMacroOpOptimizer).to(F.VMMacroOpOptimizer).inSingletonScope(), e(n.ServiceIdentifiers.IVMOpcodeMapStorage).to(D.VMOpcodeMapStorage).inSingletonScope()
      })
    }, 16187: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMClosureAnalyzer = void 0;
      const c = r(45337), l = r(20924), d = r(46725), p = r(31391), u = r(27391);
      let f = class {
        constructor(e, t) {
          this.vmCompilerUtils = e, this.variableCollector = t
        }

        analyzeEnvironmentVariables(e, t) {
          if (!e.body) return;
          if (!u.NodeGuards.isBlockStatementNode(e.body)) return void this.analyzeExpressionBodyClosures(e, t);
          const r = this.variableCollector.collectParameterNames(e),
            o = this.variableCollector.collectDeclaredVariables(e.body.body),
            n = this.findVariablesReferencedByNestedFunctions(e.body.body);
          this.scanParametersForNestedFunctions(e.params, n), this.scanDefaultParameterFunctions(e.params, r, n), this.markCapturedVariables(r, o, n, t)
        }

        scanNodeForIdentifiers(e, t) {
          if (!e) return;
          if (u.NodeGuards.isIdentifierNode(e)) return void t.add(e.name);
          if (u.NodeGuards.isFunctionExpressionNode(e) || u.NodeGuards.isArrowFunctionExpressionNode(e) || u.NodeGuards.isFunctionDeclarationNode(e)) return;
          if (u.NodeGuards.isClassExpressionNode(e) || u.NodeGuards.isClassDeclarationNode(e)) return;
          const r = e;
          for (const o of Object.keys(e)) {
            if ("type" === o || "parentNode" === o) continue;
            const e = r[o];
            if (e && "object" == typeof e) if (Array.isArray(e)) for (const r of e) r && "object" == typeof r && r.type && this.scanNodeForIdentifiers(r, t); else e.type && this.scanNodeForIdentifiers(e, t)
          }
        }

        analyzeExpressionBodyClosures(e, t) {
          const r = this.variableCollector.collectParameterNames(e), o = new Set;
          this.scanNodeForNestedFunctions(e.body, o), this.scanParametersForNestedFunctions(e.params, o), this.scanDefaultParameterFunctions(e.params, r, o);
          for (const e of r) o.has(e) && t.envVars.add(e)
        }

        scanPatternForNestedFunctions(e, t) {
          if (u.NodeGuards.isArrayPatternNode(e)) for (const r of e.elements) r && (u.NodeGuards.isAssignmentPatternNode(r) ? (this.scanNodeForNestedFunctions(r.right, t), this.scanPatternForNestedFunctions(r.left, t)) : u.NodeGuards.isRestElementNode(r) ? this.scanPatternForNestedFunctions(r.argument, t) : this.scanPatternForNestedFunctions(r, t)); else if (u.NodeGuards.isObjectPatternNode(e)) for (const r of e.properties) u.NodeGuards.isRestElementNode(r) ? this.scanPatternForNestedFunctions(r.argument, t) : u.NodeGuards.isPropertyNode(r) && (u.NodeGuards.isAssignmentPatternNode(r.value) ? (this.scanNodeForNestedFunctions(r.value.right, t), this.scanPatternForNestedFunctions(r.value.left, t)) : this.scanPatternForNestedFunctions(r.value, t)); else u.NodeGuards.isAssignmentPatternNode(e) ? (this.scanNodeForNestedFunctions(e.right, t), this.scanPatternForNestedFunctions(e.left, t)) : u.NodeGuards.isRestElementNode(e) && this.scanPatternForNestedFunctions(e.argument, t)
        }

        findVariablesReferencedByNestedFunctions(e) {
          const t = new Set;
          return this.vmCompilerUtils.traverseStatements(e, e => {
            if (u.NodeGuards.isFunctionDeclarationNode(e)) this.scanNestedFunctionForReferences(e, t); else if (u.NodeGuards.isClassDeclarationNode(e)) this.scanClassForReferences(e, t); else if (u.NodeGuards.isVariableDeclarationNode(e)) for (const r of e.declarations) r.init && this.scanNodeForNestedFunctions(r.init, t), (u.NodeGuards.isArrayPatternNode(r.id) || u.NodeGuards.isObjectPatternNode(r.id)) && this.scanPatternForNestedFunctions(r.id, t); else if (u.NodeGuards.isReturnStatementNode(e) && e.argument) this.scanNodeForNestedFunctions(e.argument, t); else if ("ThrowStatement" === e.type) {
              const r = e;
              r.argument && this.scanNodeForNestedFunctions(r.argument, t)
            } else u.NodeGuards.isExpressionStatementNode(e) ? this.scanNodeForNestedFunctions(e.expression, t) : u.NodeGuards.isIfStatementNode(e) || u.NodeGuards.isWhileStatementNode(e) || u.NodeGuards.isDoWhileStatementNode(e) ? this.scanNodeForNestedFunctions(e.test, t) : u.NodeGuards.isForStatementNode(e) && (e.init && this.scanNodeForNestedFunctions(e.init, t), e.test && this.scanNodeForNestedFunctions(e.test, t), e.update && this.scanNodeForNestedFunctions(e.update, t))
          }), t
        }

        markCapturedVariables(e, t, r, o) {
          t.forEach(e => {
            r.has(e) && o.envVars.add(e)
          }), e.forEach(e => {
            r.has(e) && o.envVars.add(e)
          })
        }

        scanParametersForNestedFunctions(e, t) {
          if (e) for (const r of e) r && (u.NodeGuards.isAssignmentPatternNode(r) ? (this.scanNodeForIdentifiers(r.right, t), (u.NodeGuards.isArrayPatternNode(r.left) || u.NodeGuards.isObjectPatternNode(r.left)) && this.scanPatternForNestedFunctions(r.left, t)) : (u.NodeGuards.isArrayPatternNode(r) || u.NodeGuards.isObjectPatternNode(r)) && this.scanPatternForNestedFunctions(r, t))
        }

        scanDefaultParameterFunctions(e, t, r) {
          if (e) for (let o = 0; o < e.length; o++) {
            const n = e[o];
            if (n && u.NodeGuards.isAssignmentPatternNode(n)) {
              const i = new Set;
              for (let t = 0; t < o; t++) {
                const r = e[t];
                r && this.variableCollector.collectFromPattern(r, i)
              }
              this.scanForDirectFunctionReferences(n.right, i, t, r)
            }
          }
        }

        scanForDirectFunctionReferences(e, t, r, o) {
          if (!e) return;
          if (u.NodeGuards.isFunctionExpressionNode(e) || u.NodeGuards.isArrowFunctionExpressionNode(e) || u.NodeGuards.isFunctionDeclarationNode(e)) {
            const t = new Set;
            this.scanNestedFunctionForReferences(e, t);
            const n = new Set;
            if (e.params) for (const t of e.params) this.vmCompilerUtils.extractIdentifiersFromPattern(t).forEach(e => n.add(e));
            if (u.NodeGuards.isBlockStatementNode(e.body)) {
              const t = this.variableCollector.collectDeclaredVariables(e.body.body);
              for (const e of t) n.add(e)
            }
            for (const e of t) r.has(e) && (n.has(e) || o.add(e));
            return
          }
          const n = e;
          for (const i of Object.keys(e)) {
            if ("type" === i || "parentNode" === i) continue;
            const e = n[i];
            if (e && "object" == typeof e) if (Array.isArray(e)) for (const n of e) n && "object" == typeof n && n.type && this.scanForDirectFunctionReferences(n, t, r, o); else e.type && this.scanForDirectFunctionReferences(e, t, r, o)
          }
        }

        scanNodeForNestedFunctions(e, t) {
          if (!e) return;
          if (u.NodeGuards.isFunctionExpressionNode(e) || u.NodeGuards.isArrowFunctionExpressionNode(e) || u.NodeGuards.isFunctionDeclarationNode(e)) return void this.scanNestedFunctionForReferences(e, t);
          if (u.NodeGuards.isClassExpressionNode(e) || u.NodeGuards.isClassDeclarationNode(e)) return void this.scanClassForReferences(e, t);
          const r = e;
          for (const o of Object.keys(e)) {
            if ("type" === o || "parentNode" === o) continue;
            const e = r[o];
            if (e && "object" == typeof e) if (Array.isArray(e)) for (const r of e) r && "object" == typeof r && r.type && this.scanNodeForNestedFunctions(r, t); else e.type && this.scanNodeForNestedFunctions(e, t)
          }
        }

        scanNestedFunctionForReferences(e, t) {
          if (!e.body) return;
          const r = new Set;
          if (e.params) for (const t of e.params) t && u.NodeGuards.isAssignmentPatternNode(t) && this.scanNodeForIdentifiers(t.right, r);
          if (u.NodeGuards.isBlockStatementNode(e.body)) {
            this.scanStatementsForIdentifiers(e.body.body, r);
            const t = new Set;
            this.scanNodeForNestedFunctions(e.body, t);
            for (const e of t) r.add(e)
          } else {
            this.scanNodeForIdentifiers(e.body, r);
            const t = new Set;
            this.scanNodeForNestedFunctions(e.body, t);
            for (const e of t) r.add(e)
          }
          const o = this.variableCollector.collectParameterNames(e);
          if (u.NodeGuards.isBlockStatementNode(e.body)) {
            const t = this.variableCollector.collectFunctionLevelDeclaredVariables(e.body.body);
            for (const e of t) o.add(e)
          }
          r.forEach(e => {
            o.has(e) || t.add(e)
          })
        }

        scanClassForReferences(e, t) {
          var r;
          if (null === (r = e.body) || void 0 === r ? void 0 : r.body) for (const r of e.body.body) if ("MethodDefinition" === r.type && r.value && u.NodeGuards.isFunctionExpressionNode(r.value)) this.scanNestedFunctionForReferences(r.value, t); else if (u.NodeGuards.isPropertyDefinitionNode(r)) r.value && (this.scanNodeForIdentifiers(r.value, t), this.scanNodeForNestedFunctions(r.value, t)); else if (u.NodeGuards.isStaticBlockNode(r)) {
            this.scanStatementsForIdentifiers(r.body, t);
            for (const e of r.body) this.scanNodeForNestedFunctions(e, t)
          }
        }

        scanStatementsForIdentifiers(e, t) {
          this.vmCompilerUtils.traverseStatements(e, e => {
            if (u.NodeGuards.isExpressionStatementNode(e)) this.scanNodeForIdentifiers(e.expression, t); else if (u.NodeGuards.isReturnStatementNode(e) && e.argument) this.scanNodeForIdentifiers(e.argument, t); else if (u.NodeGuards.isIfStatementNode(e)) this.scanNodeForIdentifiers(e.test, t); else if (u.NodeGuards.isVariableDeclarationNode(e)) for (const r of e.declarations) r.init && this.scanNodeForIdentifiers(r.init, t); else if (u.NodeGuards.isForStatementNode(e)) e.init && !u.NodeGuards.isVariableDeclarationNode(e.init) && this.scanNodeForIdentifiers(e.init, t), e.test && this.scanNodeForIdentifiers(e.test, t), e.update && this.scanNodeForIdentifiers(e.update, t); else if (u.NodeGuards.isWhileStatementNode(e) || u.NodeGuards.isDoWhileStatementNode(e)) this.scanNodeForIdentifiers(e.test, t); else if (u.NodeGuards.isForOfStatementNode(e) || u.NodeGuards.isForInStatementNode(e)) this.scanNodeForIdentifiers(e.right, t); else if ("SwitchStatement" === e.type) {
              const r = e;
              this.scanNodeForIdentifiers(r.discriminant, t);
              for (const e of r.cases) e.test && this.scanNodeForIdentifiers(e.test, t)
            } else if ("ThrowStatement" === e.type) {
              const r = e;
              r.argument && this.scanNodeForIdentifiers(r.argument, t)
            }
          })
        }
      };
      t.VMClosureAnalyzer = f, t.VMClosureAnalyzer = f = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IVMCompilerUtils)), s(1, (0, c.inject)(p.ServiceIdentifiers.IVMVariableCollector)), a("design:paramtypes", ["function" == typeof (o = void 0 !== l.IVMCompilerUtils && l.IVMCompilerUtils) ? o : Object, "function" == typeof (n = void 0 !== d.IVMVariableCollector && d.IVMVariableCollector) ? n : Object])], f)
    }, 16737: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomCodeHelperGroupStorage = void 0;
      const d = r(45337), p = r(31391), u = r(73903), f = r(76393), m = r(31142), g = r(52100), h = r(48720);
      let y = o = class extends h.MapStorage {
        constructor(e, t, r) {
          super(t, r), this.customCodeHelperGroupFactory = e
        }

        initialize() {
          super.initialize(), o.customCodeHelperGroupsList.forEach(e => {
            const t = this.customCodeHelperGroupFactory(e);
            this.storage.set(e, t)
          })
        }
      };
      t.CustomCodeHelperGroupStorage = y, y.customCodeHelperGroupsList = [g.CustomCodeHelperGroup.ConsoleOutput, g.CustomCodeHelperGroup.DebugProtection, g.CustomCodeHelperGroup.DomainLock, g.CustomCodeHelperGroup.SelfDefending, g.CustomCodeHelperGroup.StringArray, g.CustomCodeHelperGroup.VM], s([(0, d.postConstruct)(), c("design:type", Function), c("design:paramtypes", []), c("design:returntype", void 0)], y.prototype, "initialize", null), t.CustomCodeHelperGroupStorage = y = o = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__ICustomCodeHelperGroup)), l(1, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(2, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (n = void 0 !== u.TCustomCodeHelperGroupFactory && u.TCustomCodeHelperGroupFactory) ? n : Object, "function" == typeof (i = void 0 !== m.IRandomGenerator && m.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== f.IOptions && f.IOptions) ? a : Object])], y)
    }, 16748: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayHexadecimalNumericStringIndexNode = void 0;
      const c = r(45337), l = r(76393), d = r(31142), p = r(31391), u = r(81131), f = r(93571), m = r(24660);
      let g = class extends u.AbstractStringArrayIndexNode {
        constructor(e, t) {
          super(e, t)
        }

        getNode(e) {
          const t = m.NumberUtils.toHex(e);
          return f.NodeFactory.literalNode(t)
        }
      };
      t.StringArrayHexadecimalNumericStringIndexNode = g, t.StringArrayHexadecimalNumericStringIndexNode = g = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(p.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== d.IRandomGenerator && d.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== l.IOptions && l.IOptions) ? n : Object])], g)
    }, 16868: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ControlFlowStorage = void 0, function (e) {
        e.FunctionControlFlowStorage = "function-control-flow-storage", e.StringControlFlowStorage = "string-control-flow-storage"
      }(r || (t.ControlFlowStorage = r = {}))
    }, 17845: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomainLockCodeHelper = void 0;
      const u = r(45337), f = r(31391), m = r(18741), g = r(39032), h = r(25714), y = r(70793), S = r(76393),
        N = r(31142), b = r(98151), _ = r(50164), v = r(12414), I = r(14698), O = r(48222), C = r(33056);
      let E = class extends O.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n, i) {
          super(e, t, r, o, n), this.cryptUtils = i
        }

        initialize(e, t) {
          this.callsControllerFunctionName = e, this.domainLockFunctionName = t
        }

        getNodeStructure(e) {
          return C.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          const e = this.options.domainLock.join(";"),
            t = this.options.domainLockRedirectUrl, [r, o] = this.cryptUtils.hideString(e, 3 * e.length), [n, i] = this.cryptUtils.hideString(t, 3 * t.length),
            a = this.options.target !== b.ObfuscationTarget.BrowserNoEval ? this.getGlobalVariableTemplate() : (0, I.GlobalVariableNoEvalTemplate)();
          return this.customCodeHelperFormatter.formatTemplate((0, v.DomainLockTemplate)(), {
            callControllerFunctionName: this.callsControllerFunctionName,
            domainLockFunctionName: this.domainLockFunctionName,
            domainsStringDiff: o,
            domains: r,
            domainLockRedirectUrlDiff: i,
            hiddenDomainLockRedirectUrl: n,
            globalVariableTemplate: a
          })
        }
      };
      t.DomainLockCodeHelper = E, l([(0, _.initializable)(), d("design:type", String)], E.prototype, "callsControllerFunctionName", void 0), l([(0, _.initializable)(), d("design:type", String)], E.prototype, "domainLockFunctionName", void 0), t.DomainLockCodeHelper = E = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperFormatter)), p(2, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperObfuscator)), p(3, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(4, (0, u.inject)(f.ServiceIdentifiers.IOptions)), p(5, (0, u.inject)(f.ServiceIdentifiers.ICryptUtils)), d("design:paramtypes", ["function" == typeof (o = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== g.ICustomCodeHelperFormatter && g.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== h.ICustomCodeHelperObfuscator && h.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== N.IRandomGenerator && N.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== S.IOptions && S.IOptions) ? s : Object, "function" == typeof (c = void 0 !== y.ICryptUtils && y.ICryptUtils) ? c : Object])], E)
    }, 18083: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ScopeThroughIdentifiersTransformer = void 0;
      const d = r(45337), p = r(31391), u = r(76393), f = r(31142), m = r(57809), g = r(23622), h = r(75716),
        y = r(13245), S = r(27391);
      let N = class extends y.AbstractNodeTransformer {
        constructor(e, t, r, o) {
          super(r, o), this.throughIdentifierReplacer = e, this.scopeIdentifiersTraverser = t
        }

        getVisitor(e) {
          switch (e) {
            case h.NodeTransformationStage.Preparing:
            case h.NodeTransformationStage.RenameIdentifiers:
              return {
                enter: (e, t) => {
                  if (t && S.NodeGuards.isProgramNode(e)) return this.transformNode(e, t)
                }
              };
            default:
              return null
          }
        }

        transformNode(e, t) {
          return this.scopeIdentifiersTraverser.traverseScopeThroughIdentifiers(e, t, e => {
            const { reference: t, variableLexicalScopeNode: r } = e;
            this.transformScopeThroughIdentifiers(t, r)
          }), e
        }

        transformScopeThroughIdentifiers(e, t) {
          e.resolved || this.replaceIdentifierName(e)
        }

        replaceIdentifierName(e) {
          const t = e.identifier, r = this.throughIdentifierReplacer.replace(t);
          e.identifier.name = r.name
        }
      };
      t.ScopeThroughIdentifiersTransformer = N, t.ScopeThroughIdentifiersTransformer = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.IThroughIdentifierReplacer)), l(1, (0, d.inject)(p.ServiceIdentifiers.IScopeIdentifiersTraverser)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== g.IThroughIdentifierReplacer && g.IThroughIdentifierReplacer) ? o : Object, "function" == typeof (n = void 0 !== m.IScopeIdentifiersTraverser && m.IScopeIdentifiersTraverser) ? n : Object, "function" == typeof (i = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== u.IOptions && u.IOptions) ? a : Object])], N)
    }, 18255: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayRC4DecodeTemplate = function (e) {
        const t = e.getRandomString(6), r = e.getRandomString(6), o = e.getRandomString(6), n = e.getRandomString(6);
        return `\n        if ({stringArrayCallsWrapperName}.${t} === undefined) {\n            {atobPolyfill}\n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${r} = {rc4FunctionName};\n            \n            {stringArrayCallsWrapperName}.${o} = {};\n            \n            {stringArrayCallsWrapperName}.${t} = true;\n        }\n  \n        const firstValue = stringArray[0];\n        const cacheKey = index + firstValue;\n        const cachedValue = {stringArrayCallsWrapperName}.${o}[cacheKey];\n\n        if (!cachedValue) {\n            if ({stringArrayCallsWrapperName}.${n} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${n} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${r}(value, key);\n            {stringArrayCallsWrapperName}.${o}[cacheKey] = value;\n        } else {\n            value = cachedValue;\n        }\n    `
      }
    }, 18365: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DeadCodeInjectionRule = void 0;
      const o = r(45887);
      t.DeadCodeInjectionRule = e => (e.deadCodeInjection && ((e = {
        ...e,
        deadCodeInjection: !0,
        stringArray: !0
      }).stringArrayThreshold || (e = {
        ...e,
        stringArray: !0,
        stringArrayThreshold: o.DEFAULT_PRESET.stringArrayThreshold
      })), e)
    }, 18741: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 18789: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMScopeManager = void 0;
      const s = r(45337), c = r(31391), l = r(46725), d = r(59805), p = r(27391);
      let u = class {
        constructor(e) {
          this.variableCollector = e
        }

        enterParametersTDZ(e, t) {
          e.parametersInTDZ.clear();
          for (const r of t) e.parametersInTDZ.add(r)
        }

        exitParameterTDZ(e, t) {
          e.parametersInTDZ.delete(t)
        }

        clearParametersTDZ(e) {
          e.parametersInTDZ.clear()
        }

        enterLocalsTDZ(e, t) {
          for (const r of t) e.localVariablesInTDZ.add(r)
        }

        exitLocalTDZ(e, t) {
          e.localVariablesInTDZ.delete(t)
        }

        checkTDZ(e, t) {
          return e.parametersInTDZ.has(t) ? {
            inTDZ: !0,
            type: "parameter"
          } : e.localVariablesInTDZ.has(t) ? { inTDZ: !0, type: "local" } : { inTDZ: !1, type: null }
        }

        isInTDZWithBypass(e, t) {
          var r;
          return !!e.localVariablesInTDZ.has(t) && !(null === (r = e.perIterationLoopVars) || void 0 === r ? void 0 : r.has(t))
        }

        checkShadowing(e, t, r) {
          var o;
          const { variableKind: n, hasBlockScopedDecl: i = !1 } = r;
          if (e.parentContext) {
            const r = e.parentContext;
            if (r.localVariables.has(t)) return {
              shadows: !0,
              shadowedType: "local",
              action: i ? "createChildEnv" : "useScoped"
            };
            if (r.envVars.has(t)) return {
              shadows: !0,
              shadowedType: "env",
              action: i ? "createChildEnv" : "useScoped"
            };
            if (r.parameters.has(t) && !r.parametersInTDZ.has(t)) return {
              shadows: !0,
              shadowedType: "parameter",
              action: i ? "createChildEnv" : "useScoped"
            }
          }
          if (e.parameters.has(t)) return {
            shadows: !0,
            shadowedType: "parameter",
            action: i ? "createChildEnv" : "useScoped"
          };
          if (e.envVars.has(t)) return { shadows: !0, shadowedType: "env", action: i ? "createChildEnv" : "useScoped" };
          if (e.localVariables.has(t)) return {
            shadows: !0,
            shadowedType: "local",
            action: i ? "useScoped" : "usePlain"
          };
          if (null === (o = e.perIterationLoopVars) || void 0 === o ? void 0 : o.has(t)) return {
            shadows: !0,
            shadowedType: "perIteration",
            action: "useScoped"
          };
          for (const r of e.localVariables.keys()) if (r.split("$$")[0] === t && r !== t) return {
            shadows: !0,
            shadowedType: "local",
            action: "useScoped"
          };
          return e.functionName && t === e.functionName && !e.localVariables.has(t) ? {
            shadows: !0,
            shadowedType: "nfe",
            action: "var" === n ? "usePlain" : "useScoped"
          } : { shadows: !1, action: "none" }
        }

        isDeclaredInParent(e, t) {
          let r = e.parentContext;
          for (; r;) {
            if (r.parameters.has(t) && !r.parametersInTDZ.has(t)) return !0;
            if (r.localVariables.has(t)) return !0;
            if (r.envVars.has(t)) return !0;
            const e = `${t}$$`;
            for (const t of r.parameters.keys()) if (t.startsWith(e) && !r.parametersInTDZ.has(t)) return !0;
            r = r.parentContext
          }
          return !1
        }

        enterBlock(e) {
          return e.blockScopeDepth++, e.activeBlockScopes || (e.activeBlockScopes = new Set), {
            depth: e.blockScopeDepth,
            scopesBefore: new Set(e.activeBlockScopes),
            varsAdded: []
          }
        }

        exitBlockWithHandle(e, t) {
          if (e.activeBlockScopes) for (const r of e.activeBlockScopes) !t.scopesBefore.has(r) && r.endsWith(`$$${t.depth}`) && e.activeBlockScopes.delete(r);
          if (e.activeBlockScopes) for (const r of t.varsAdded) e.activeBlockScopes.delete(r);
          e.blockScopeDepth--
        }

        trackBlockVariable(e, t) {
          e.varsAdded.push(t)
        }

        exitBlock(e, t) {
          const r = e.blockScopeDepth;
          if (t && e.activeBlockScopes) for (const o of t) {
            const t = this.getScopedKey(o, r);
            e.activeBlockScopes.delete(t), e.localVariablesInTDZ.delete(o)
          }
          e.blockScopeDepth--
        }

        registerBlockVariable(e, t, r) {
          const o = e.blockScopeDepth, n = this.getScopedKey(t, o), i = e.localVariables.size;
          return e.localVariables.set(n, i), e.activeBlockScopes || (e.activeBlockScopes = new Set), e.activeBlockScopes.add(n), e.variableScopes.set(n, {
            depth: o,
            index: i
          }), "const" === r && e.constLocalVariables.add(i), { scopedKey: n, localIndex: i, depth: o }
        }

        getScopedKey(e, t) {
          return (0, d.getScopedVariableName)(e, t)
        }

        isScopedVarActive(e, t) {
          return !!e.activeBlockScopes && e.activeBlockScopes.has(t)
        }

        registerPerIterationVar(e, t, r) {
          e.perIterationLoopVars || (e.perIterationLoopVars = new Set), e.perIterationVarScopedKeys || (e.perIterationVarScopedKeys = new Set), e.perIterationLoopVars.add(t), e.perIterationVarScopedKeys.add(r)
        }

        isPerIterationVar(e, t) {
          var r, o;
          return null !== (o = null === (r = e.perIterationLoopVars) || void 0 === r ? void 0 : r.has(t)) && void 0 !== o && o
        }

        isPerIterationScopedKey(e, t) {
          var r, o;
          return null !== (o = null === (r = e.perIterationVarScopedKeys) || void 0 === r ? void 0 : r.has(t)) && void 0 !== o && o
        }

        enterEnv(e, t, r = !1) {
          const o = { previousDepth: e.envDepth };
          return r || t.getEnv(), t.createEnv(), e.envDepth++, o
        }

        exitEnv(e, t, r) {
          t.restoreParentEnv(), e.envDepth--, e.envDepth, r.previousDepth
        }

        pushBreakEnvDepth(e) {
          e.breakEnvDepths.push(e.envDepth)
        }

        popBreakEnvDepth(e) {
          e.breakEnvDepths.pop()
        }

        pushContinueEnvDepth(e) {
          e.continueEnvDepths.push(e.envDepth)
        }

        popContinueEnvDepth(e) {
          e.continueEnvDepths.pop()
        }

        getEnvDepth(e) {
          return e.envDepth
        }

        scanForLexicalDeclarations(e) {
          return this.variableCollector.scanForLexicalDeclarations(e)
        }

        collectLexicalDeclarations(e) {
          return p.NodeGuards.isBlockStatementNode(e) || p.NodeGuards.isProgramNode(e) ? this.variableCollector.scanForLexicalDeclarations(e.body) : new Set
        }
      };
      t.VMScopeManager = u, t.VMScopeManager = u = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.IVMVariableCollector)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.IVMVariableCollector && l.IVMVariableCollector) ? o : Object])], u)
    }, 18829: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SourceMapFileNameRule = void 0;
      const o = r(52849);
      t.SourceMapFileNameRule = e => {
        let { sourceMapFileName: t } = e;
        if (t) {
          t = t.replace(/^\/+/, "").replace(/(?:\.js)?(?:\.map)?$/, "");
          let r = t.split(o.StringSeparator.Dot);
          const n = r.length, i = r[n - 1];
          n > 1 && i.length <= 3 && (r = r.slice(0, -1)), t = r.join(o.StringSeparator.Dot), e = {
            ...e,
            sourceMapFileName: `${t}.js.map`
          }
        }
        return e
      }
    }, 18998: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.deadCodeInjectionTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(94991);
      t.deadCodeInjectionTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(a.DeadCodeInjectionTransformer).whenTargetNamed(i.NodeTransformer.DeadCodeInjectionTransformer)
      })
    }, 19104: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.computeState = function (e, t) {
        return c(e ^ t * i >>> 0) % n
      }, t.deriveStateMachineConfig = function (e, t, r) {
        const a = [];
        for (let t = 0; t < n; t++) {
          const r = l(c(e ^ t * i), o.VM_OPCODE_COUNT), n = {};
          for (let e = 0; e < o.VM_OPCODE_COUNT; e++) n[e] = r[e];
          a.push(n)
        }
        return { seed: e, initialState: t, initialStackKey: r, stateMaps: a }
      }, t.getNumStates = function () {
        return n
      };
      const o = r(79240), n = 8, i = 2654435769, a = 2246822507, s = 3266489909;

      function c(e) {
        return e >>>= 0, e ^= e >>> 16, e = Math.imul(e, a) >>> 0, e ^= e >>> 13, e = Math.imul(e, s) >>> 0, (e ^= e >>> 16) >>> 0
      }

      function l(e, t) {
        const r = [];
        for (let e = 0; e < t; e++) r[e] = e;
        let o = e;
        for (let e = t - 1; e > 0; e--) {
          o = c(o ^ e);
          const t = o % (e + 1), n = r[e];
          r[e] = r[t], r[t] = n
        }
        return r
      }
    }, 19261: e => {
      e.exports = require("eslint-visitor-keys")
    }, 19593: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionFunctionTemplate = function () {
        return "\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    "
      }
    }, 19691: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p, u = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), f = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), m = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, g = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && u(t, e, r[n]);
        return f(t, e), t
      }), h = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, y = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayRotateFunctionTransformer = void 0;
      const S = r(45337), N = r(31391), b = g(r(31659)), _ = r(58544), v = r(80540), I = r(45432), O = r(76393),
        C = r(31142), E = r(28523), T = r(70858), R = r(51875), M = r(75716), A = r(13245), F = r(47250), P = r(27391),
        D = r(93571), j = r(45261), x = r(4592), V = r(92486), G = r(33056), k = r(32238);
      let L = n = class extends A.AbstractNodeTransformer {
        constructor(e, t, r, o, n, i, a) {
          super(e, t), this.stringArrayStorage = o, this.stringArrayStorageAnalyzer = n, this.transformersRunner = r, this.customCodeHelperFactory = i, this.numberNumericalExpressionAnalyzer = a
        }

        static isProgramNodeHasStringLiterals(e) {
          let t = !1;
          return b.traverse(e, {
            enter: e => {
              if (P.NodeGuards.isLiteralNode(e) && j.NodeLiteralUtils.isStringLiteralNode(e)) return t = !0, b.VisitorOption.Break
            }
          }), t
        }

        getVisitor(e) {
          return this.options.stringArrayRotate && e === M.NodeTransformationStage.StringArray ? { enter: e => P.NodeGuards.isProgramNode(e) ? n.isProgramNodeHasStringLiterals(e) ? this.transformNode(e) : b.VisitorOption.Break : e } : null
        }

        transformNode(e) {
          const t = this.getStringArrayRotateFunctionNode(), r = D.NodeFactory.programNode([t]);
          G.NodeUtils.parentizeAst(r);
          const o = [M.NodeTransformationStage.Preparing, M.NodeTransformationStage.Converting, M.NodeTransformationStage.RenameIdentifiers, M.NodeTransformationStage.Finalizing];
          for (const e of o) this.transformersRunner.transform(r, n.stringArrayRotateFunctionTransformers, e);
          return b.traverse(r, {
            enter: e => {
              P.NodeGuards.isLiteralNode(e) && j.NodeLiteralUtils.isStringLiteralNode(e) && (this.isComparisonExpressionStringLiteralNode(e) ? this.stringArrayStorageAnalyzer.addItemDataForLiteralNode(e) : x.NodeMetadata.set(e, { ignoredNode: !0 }))
            }
          }), F.NodeAppender.prepend(e, [t]), e
        }

        getStringArrayRotateFunctionNode() {
          const e = this.getComparisonValue(),
            t = this.numberNumericalExpressionAnalyzer.analyze(e, n.comparisonExpressionAdditionalPartsCount);
          let r = 1;
          const o = k.NumericalExpressionDataToNodeConverter.convertIntegerNumberData(t, (e, t) => {
            const o = e * r, n = D.NodeFactory.literalNode(`${o}${this.randomGenerator.getRandomString(6)}`),
              i = D.NodeFactory.callExpressionNode(D.NodeFactory.identifierNode("parseInt"), [n]),
              a = D.NodeFactory.binaryExpressionNode("/", t ? i : D.NodeFactory.unaryExpressionNode("-", i), D.NodeFactory.literalNode(r, r.toString()));
            return r++, a
          }), i = this.customCodeHelperFactory(R.CustomCodeHelper.StringArrayRotateFunction);
          return i.initialize(this.stringArrayStorage.getStorageName(), e, o), i.getNode()[0]
        }

        isComparisonExpressionStringLiteralNode(e) {
          return /\d/.test(e.value)
        }

        getComparisonValue() {
          return this.randomGenerator.getRandomInteger(1e5, 1e6)
        }
      };
      t.StringArrayRotateFunctionTransformer = L, L.stringArrayRotateFunctionTransformers = [V.NodeTransformer.BooleanLiteralTransformer, V.NodeTransformer.MemberExpressionTransformer, V.NodeTransformer.NumberLiteralTransformer, V.NodeTransformer.NumberToNumericalExpressionTransformer, V.NodeTransformer.ParentificationTransformer, V.NodeTransformer.ScopeIdentifiersTransformer], L.comparisonExpressionAdditionalPartsCount = 7, t.StringArrayRotateFunctionTransformer = L = n = m([(0, S.injectable)(), y(0, (0, S.inject)(N.ServiceIdentifiers.IRandomGenerator)), y(1, (0, S.inject)(N.ServiceIdentifiers.IOptions)), y(2, (0, S.inject)(N.ServiceIdentifiers.INodeTransformersRunner)), y(3, (0, S.inject)(N.ServiceIdentifiers.IStringArrayStorage)), y(4, (0, S.inject)(N.ServiceIdentifiers.IStringArrayStorageAnalyzer)), y(5, (0, S.inject)(N.ServiceIdentifiers.Factory__ICustomCodeHelper)), y(6, (0, S.inject)(N.ServiceIdentifiers.INumberNumericalExpressionAnalyzer)), h("design:paramtypes", ["function" == typeof (i = void 0 !== C.IRandomGenerator && C.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== O.IOptions && O.IOptions) ? a : Object, "function" == typeof (s = void 0 !== v.INodeTransformersRunner && v.INodeTransformersRunner) ? s : Object, "function" == typeof (c = void 0 !== E.IStringArrayStorage && E.IStringArrayStorage) ? c : Object, "function" == typeof (l = void 0 !== T.IStringArrayStorageAnalyzer && T.IStringArrayStorageAnalyzer) ? l : Object, "function" == typeof (d = void 0 !== _.TCustomCodeHelperFactory && _.TCustomCodeHelperFactory) ? d : Object, "function" == typeof (p = void 0 !== I.INumberNumericalExpressionAnalyzer && I.INumberNumericalExpressionAnalyzer) ? p : Object])], L)
    }, 19714: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 20924: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 20965: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayEncoding = void 0;
      const o = r(39079);
      t.StringArrayEncoding = o.Utils.makeEnum({ None: "none", Base64: "base64", Rc4: "rc4" })
    }, 21071: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMCodeHelperGroup = void 0;
      const f = r(45337), m = r(31391), g = r(58544), h = r(18741), y = r(76393), S = r(31142), N = r(68934),
        b = r(60722), _ = r(50164), v = r(51875), I = r(26455);
      let O = class extends I.AbstractCustomCodeHelperGroup {
        constructor(e, t, r, o, n, i) {
          super(o, n, i), this.vmExecutorName = "", this.customCodeHelperFactory = e, this.vmBytecodeStorage = t, this.vmOpcodeMapStorage = r
        }

        initialize() {
          if (this.customCodeHelpers = new Map, !this.options.vmObfuscation) return;
          const e = this.identifierNamesGenerator.generateForGlobalScope(),
            t = Math.floor(16777215 * this.randomGenerator.getMathRandom()).toString(16);
          this.vmExecutorName = `${e}_${t}`, this.identifierNamesGenerator.preserveName(this.vmExecutorName);
          const r = this.customCodeHelperFactory(v.CustomCodeHelper.VMRuntime);
          r.initialize(this.vmBytecodeStorage, this.vmOpcodeMapStorage, this.vmExecutorName), this.customCodeHelpers.set(v.CustomCodeHelper.VMRuntime, r)
        }

        getVMExecutorName() {
          return this.vmExecutorName
        }
      };
      t.VMCodeHelperGroup = O, d([(0, _.initializable)(), p("design:type", "function" == typeof (l = "undefined" != typeof Map && Map) ? l : Object)], O.prototype, "customCodeHelpers", void 0), t.VMCodeHelperGroup = O = d([(0, f.injectable)(), u(0, (0, f.inject)(m.ServiceIdentifiers.Factory__ICustomCodeHelper)), u(1, (0, f.inject)(m.ServiceIdentifiers.IVMBytecodeStorage)), u(2, (0, f.inject)(m.ServiceIdentifiers.IVMOpcodeMapStorage)), u(3, (0, f.inject)(m.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), u(4, (0, f.inject)(m.ServiceIdentifiers.IRandomGenerator)), u(5, (0, f.inject)(m.ServiceIdentifiers.IOptions)), p("design:paramtypes", ["function" == typeof (o = void 0 !== g.TCustomCodeHelperFactory && g.TCustomCodeHelperFactory) ? o : Object, "function" == typeof (n = void 0 !== N.IVMBytecodeStorage && N.IVMBytecodeStorage) ? n : Object, "function" == typeof (i = void 0 !== b.IVMOpcodeMapStorage && b.IVMOpcodeMapStorage) ? i : Object, "function" == typeof (a = void 0 !== h.TIdentifierNamesGeneratorFactory && h.TIdentifierNamesGeneratorFactory) ? a : Object, "function" == typeof (s = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== y.IOptions && y.IOptions) ? c : Object])], O)
    }, 21091: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getExceptionOpcodeTemplates = function () {
        return "\n                        // Exception Handling Operations\n                        case opMap[58]: { // TRY_START\n                            // Register exception handler\n                            // Exception data stored in exHandlers[pc] = [catchIdx, finallyIdx, endIdx]\n                            // Values are XOR-encoded if vmJumpsEncoding is enabled\n                            let exData = exHandlers[pc];\n                            exceptionHandlers.push({\n                                catchIndex: exData[0] >= 0 ? decodeJump(exData[0]) : undefined,\n                                finallyIndex: exData[1] >= 0 ? decodeJump(exData[1]) : undefined,\n                                endIndex: exData[2] >= 0 ? decodeJump(exData[2]) : undefined,\n                                stackSize: stack.length\n                            });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[59]: { // TRY_END\n                            // Normal completion of try block - pop exception handler\n                            exceptionHandlers.pop();\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[60]: { // CATCH_START\n                            // Exception is already on stack (from throw)\n                            // If arg is -1, just pop and discard (catch without parameter)\n                            // Otherwise, arg is the constant pool index of the parameter name\n                            // Store exception in CURRENT environment (not parent) to support shadowing\n                            let exception = stack.pop();\n                            if (arg >= 0) {\n                                let catchParamName = constants[arg];\n                                // Always create variable in current environment, not parent\n                                // This allows catch parameters to shadow outer const variables\n                                env.vars[catchParamName] = exception;\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[61]: { // FINALLY_START\n                            // Finally block begins\n                            // Pop exception handler if it still exists (normal control flow from catch)\n                            // If we got here via exception, the handler was already popped\n                            if (exceptionHandlers.length > 0) {\n                                let topHandler = exceptionHandlers[exceptionHandlers.length - 1];\n                                // Only pop if this is the handler for this try-catch-finally\n                                // (check if finallyIndex matches current pc)\n                                if (topHandler.finallyIndex === pc) {\n                                    // Save any pending exception from this handler\n                                    if (topHandler.pendingException !== undefined) {\n                                        pendingException = topHandler.pendingException;\n                                    }\n                                    exceptionHandlers.pop();\n                                }\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[62]: { // FINALLY_END\n                            // Finally block ended\n                            // If there's a pending return, return that value (unless finally also returned)\n                            if (pendingReturn.hasReturn) {\n                                let returnValue = pendingReturn.value;\n                                pendingReturn.hasReturn = false;\n                                pendingReturn.value = undefined;\n                                return returnValue;\n                            }\n                            // If there's a pending break, jump to break target\n                            if (pendingBreak.hasBreak) {\n                                let breakTarget = pendingBreak.target;\n                                pendingBreak.hasBreak = false;\n                                pendingBreak.target = 0;\n                                pc = breakTarget;\n                                break;\n                            }\n                            // If there's a pending continue, jump to continue target\n                            if (pendingContinue.hasContinue) {\n                                let continueTarget = pendingContinue.target;\n                                pendingContinue.hasContinue = false;\n                                pendingContinue.target = 0;\n                                pc = continueTarget;\n                                break;\n                            }\n                            // If there's a pending exception, re-throw it\n                            if (pendingException !== null) {\n                                let exToThrow = pendingException;\n                                pendingException = null;\n                                throw exToThrow;\n                            }\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 21274: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SplitStringsChunkLengthRule = void 0, t.SplitStringsChunkLengthRule = e => 0 === e.splitStringsChunkLength ? {
        ...e,
        splitStrings: !1,
        splitStringsChunkLength: 0
      } : { ...e, splitStringsChunkLength: Math.floor(e.splitStringsChunkLength) }
    }, 21456: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getArithmeticOpcodeTemplates = function () {
        return "\n                        // Arithmetic Operations\n                        case opMap[10]: { // ADD\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a + b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[11]: { // SUB\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a - b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[12]: { // MUL\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a * b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[13]: { // DIV\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a / b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[14]: { // MOD\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a % b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[15]: // NEG\n                            stack.push(-stack.pop());\n                            pc++;\n                            break;\n\n                        case opMap[19]: // UNARY_PLUS - convert to number\n                            stack.push(+stack.pop());\n                            pc++;\n                            break;\n\n                        case opMap[18]: { // EXPONENT\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(Math.pow(a, b));\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 21559: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionExtractor = void 0, function (e) {
        e.BasePropertiesExtractor = "BasePropertiesExtractor", e.ObjectExpressionToVariableDeclarationExtractor = "ObjectExpressionToVariableDeclarationExtractor"
      }(r || (t.ObjectExpressionExtractor = r = {}))
    }, 21593: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CalleeDataExtractor = void 0, function (e) {
        e.FunctionDeclarationCalleeDataExtractor = "FunctionDeclarationCalleeDataExtractor", e.FunctionExpressionCalleeDataExtractor = "FunctionExpressionCalleeDataExtractor", e.ObjectExpressionCalleeDataExtractor = "ObjectExpressionCalleeDataExtractor"
      }(r || (t.CalleeDataExtractor = r = {}))
    }, 22056: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObfuscatingGuard = void 0, function (e) {
        e.BlackListObfuscatingGuard = "BlackListObfuscatingGuard", e.ConditionalCommentObfuscatingGuard = "ConditionalCommentObfuscatingGuard", e.ForceTransformStringObfuscatingGuard = "ForceTransformStringObfuscatingGuard", e.IgnoredImportObfuscatingGuard = "IgnoredImportObfuscatingGuard", e.ImportMetaObfuscationGuard = "ImportMetaObfuscationGuard", e.ReservedStringObfuscatingGuard = "ReservedStringObfuscatingGuard"
      }(r || (t.ObfuscatingGuard = r = {}))
    }, 22927: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 23303: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 23622: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 23972: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getFunctionOpcodeTemplates = function () {
        return "\n                        case opMap[105]: { // SUPER_CALL\n                            let superArgCount = stack.pop();\n                            let superArgs = collectArgs(stack, superArgCount);\n                            let SuperClass = stack.pop();\n\n                            if (arg === 1) {\n                                stack.push(superArgs);\n                                pc++;\n                                break;\n                            }\n\n                            if (typeof SuperClass !== 'function') {\n                                throw new TypeError('Super expression must be a constructor');\n                            }\n\n                            {vmGlobalsName}['__$$newTarget$$__'] = newTarget;\n                            try {\n                                SuperClass.apply(_this, superArgs);\n                            } finally {\n                                delete {vmGlobalsName}['__$$newTarget$$__'];\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[100]: { // NEW_FUNC\n                            let funcBytecodeId = stack.pop();\n                            let funcBytecode = _getBytecode(funcBytecodeId);\n                            let isArrowFunc = funcBytecode && funcBytecode[{keyA}];\n                            let isAsyncFunc = funcBytecode && funcBytecode[{keyS}];\n                            let isGeneratorFunc = funcBytecode && funcBytecode[{keyG}];\n                            let closureEnv = env;\n                            let syncExec = {vmExecutorName};\n                            let asyncExec = {vmAsyncExecutorName};\n                            let genExec = {vmGeneratorExecutorName};\n                            let funcName = funcBytecode && funcBytecode[{keyNi}] !== undefined ? funcBytecode[{keyC}][funcBytecode[{keyNi}]] : undefined;\n\n                            let closure = (function(closureBytecodeId, capturedEnv, isArrow, isAsync, isGenerator, execSync, execAsync, execGen, funcName) {\n                                let createdFunc;\n                                let funcBody;\n                                if (isGenerator) {\n                                    funcBody = function() {\n                                        let closureArgs = [];\n                                        for (let j = 0; j < arguments.length; j++) {\n                                            closureArgs.push(arguments[j]);\n                                        }\n                                        return execGen.call(this, closureBytecodeId, closureArgs, capturedEnv, createdFunc);\n                                    };\n                                } else if (isAsync) {\n                                    funcBody = async function() {\n                                        let closureArgs = [];\n                                        for (let j = 0; j < arguments.length; j++) {\n                                            closureArgs.push(arguments[j]);\n                                        }\n                                        let effectiveNewTarget = new.target !== undefined ? new.target : {vmGlobalsName}['__$$newTarget$$__'];\n                                        if (isArrow) {\n                                            return await execAsync(closureBytecodeId, closureArgs, capturedEnv, createdFunc, undefined);\n                                        } else {\n                                            return await execAsync.call(this, closureBytecodeId, closureArgs, capturedEnv, createdFunc, effectiveNewTarget);\n                                        }\n                                    };\n                                } else {\n                                    funcBody = function() {\n                                        let closureArgs = [];\n                                        for (let j = 0; j < arguments.length; j++) {\n                                            closureArgs.push(arguments[j]);\n                                        }\n                                        let effectiveNewTarget = new.target !== undefined ? new.target : {vmGlobalsName}['__$$newTarget$$__'];\n                                        if (isArrow) {\n                                            return execSync(closureBytecodeId, closureArgs, capturedEnv, createdFunc, undefined);\n                                        } else {\n                                            return execSync.call(this, closureBytecodeId, closureArgs, capturedEnv, createdFunc, effectiveNewTarget);\n                                        }\n                                    };\n                                }\n                                createdFunc = funcBody;\n                                if (funcName) {\n                                    try {\n                                        Object.defineProperty(createdFunc, 'name', {\n                                            value: funcName,\n                                            writable: false,\n                                            enumerable: false,\n                                            configurable: true\n                                        });\n                                    } catch (e) {}\n                                }\n                                return createdFunc;\n                            })(funcBytecodeId, closureEnv, isArrowFunc, isAsyncFunc, isGeneratorFunc, syncExec, asyncExec, genExec, funcName);\n                            if (!closure) {\n                                throw new Error('VM Error: Failed to create closure for bytecode ID ' + funcBytecodeId);\n                            }\n                            stack.push(closure);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[104]: { // NEW\n                            let argCount = stack.pop();\n                            let newArgs = collectArgs(stack, argCount);\n                            let ctor = stack.pop();\n                            if (typeof ctor !== 'function') {\n                                throw new TypeError(ctor + ' is not a constructor');\n                            }\n                            let instance = Reflect.construct(ctor, newArgs);\n                            stack.push(instance);\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 24446: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BasePropertiesExtractor = void 0;
      const i = r(45337), a = r(47250), s = r(93571), c = r(27391), l = r(43243), d = r(33056);
      let p = o = class {
        static getPropertyNodeKeyName(e) {
          const t = e.key;
          return !c.NodeGuards.isLiteralNode(t) || "string" != typeof t.value && "number" != typeof t.value ? c.NodeGuards.isIdentifierNode(t) ? t.name : null : t.value.toString()
        }

        static isProhibitedPropertyNode(e) {
          return "init" !== e.kind
        }

        static isProhibitedPattern(e) {
          return !e || c.NodeGuards.isObjectPatternNode(e) || c.NodeGuards.isArrayPatternNode(e) || c.NodeGuards.isAssignmentPatternNode(e) || c.NodeGuards.isRestElementNode(e)
        }

        static shouldCreateLiteralNode(e) {
          return !e.computed || e.computed && !!e.key && c.NodeGuards.isLiteralNode(e.key)
        }

        extract(e, t) {
          const r = e.parentNode;
          return r && c.NodeGuards.isVariableDeclaratorNode(r) && c.NodeGuards.isIdentifierNode(r.id) ? this.transformObjectExpressionNode(e, t, r.id) : {
            nodeToReplace: e,
            objectExpressionHostStatement: t,
            objectExpressionNode: e
          }
        }

        transformObjectExpressionNode(e, t, r) {
          const o = e.properties, [n, i] = this.extractPropertiesToExpressionStatements(o, t, r),
            s = l.NodeStatementUtils.getScopeOfNode(t);
          return this.filterExtractedObjectExpressionProperties(e, i), a.NodeAppender.insertAfter(s, n, t), n.forEach(e => {
            d.NodeUtils.parentizeAst(e), d.NodeUtils.parentizeNode(e, s)
          }), { nodeToReplace: e, objectExpressionHostStatement: t, objectExpressionNode: e }
        }

        extractPropertiesToExpressionStatements(e, t, r) {
          const n = [], i = [];
          for (let a = e.length - 1; a >= 0; a--) {
            const l = e[a];
            if (c.NodeGuards.isSpreadElementNode(l)) break;
            if (o.isProhibitedPropertyNode(l)) continue;
            const d = l.value;
            if (o.isProhibitedPattern(d)) continue;
            const p = o.getPropertyNodeKeyName(l);
            if (!p) continue;
            const u = o.shouldCreateLiteralNode(l) ? s.NodeFactory.literalNode(p) : s.NodeFactory.identifierNode(p),
              f = s.NodeFactory.memberExpressionNode(r, u, !0),
              m = s.NodeFactory.expressionStatementNode(s.NodeFactory.assignmentExpressionNode("=", f, d));
            c.NodeGuards.isObjectExpressionNode(l.value) && this.transformObjectExpressionNode(l.value, t, f), n.unshift(m), i.unshift(a)
          }
          return [n, i]
        }

        filterExtractedObjectExpressionProperties(e, t) {
          e.properties = e.properties.filter((e, r) => !t.includes(r))
        }
      };
      t.BasePropertiesExtractor = p, t.BasePropertiesExtractor = p = o = n([(0, i.injectable)()], p)
    }, 24660: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NumberUtils = void 0;
      const o = r(39079);
      t.NumberUtils = class {
        static toHex(e) {
          const t = "number" == typeof e ? e.toString(16) : `${e.toString(16)}n`;
          return `${o.Utils.hexadecimalPrefix}${t}`
        }

        static extractIntegerAndDecimalParts(e) {
          const t = Math.trunc(e);
          return [t, e !== t ? e % 1 : null]
        }

        static isCeil(e) {
          return "number" != typeof e || e % 1 == 0
        }

        static isPositive(e) {
          if (isNaN(e)) throw new Error("Given value is NaN");
          return e > 0 || !(e < 0) && 1 / e === Number.POSITIVE_INFINITY
        }

        static isUnsafeNumber(e) {
          if (isNaN(e)) throw new Error("Given value is NaN");
          return e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER
        }

        static getFactors(e) {
          if (0 === e) throw new Error("Invalid number. Allowed only non-zero number");
          if (1 === (e = Math.abs(e))) return [-e, e];
          const t = [], r = Math.sqrt(e), o = e % 2 == 0 ? 1 : 2;
          for (let n = 1; n <= r; n += o) {
            const r = e / n;
            e - Math.floor(r) * n !== 0 || (t.push(-n, n), r !== n && t.push(-r, r))
          }
          return t.sort((e, t) => e - t)
        }
      }
    }, 24698: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractStatementSimplifyTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(92486), f = r(13245), m = r(27391),
        g = r(93571);
      let h = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [u.NodeTransformer.ExpressionStatementsMergeTransformer, u.NodeTransformer.VariableDeclarationsMergeTransformer]
        }

        getStatementSimplifyData(e) {
          if (!e) return null;
          if (!m.NodeGuards.isBlockStatementNode(e)) return {
            leadingStatements: [e],
            trailingStatement: null,
            hasReturnStatement: !1,
            hasSingleExpression: !1
          };
          const {
            startIndex: t,
            unwrappedExpressions: r,
            hasReturnStatement: o,
            hasStatementsAfterReturnStatement: n
          } = this.collectIteratedStatementsSimplifyData(e);
          if (n) return {
            leadingStatements: e.body,
            trailingStatement: null,
            hasReturnStatement: !1,
            hasSingleExpression: !1
          };
          const i = this.getLeadingStatements(e, t);
          if (!r.length) return {
            leadingStatements: i,
            trailingStatement: null,
            hasReturnStatement: o,
            hasSingleExpression: !1
          };
          const a = 1 === r.length, s = a ? r[0] : g.NodeFactory.sequenceExpressionNode(r);
          return {
            leadingStatements: i,
            trailingStatement: {
              statement: o ? g.NodeFactory.returnStatementNode(s) : g.NodeFactory.expressionStatementNode(s),
              expression: s
            },
            hasReturnStatement: o,
            hasSingleExpression: a
          }
        }

        collectIteratedStatementsSimplifyData(e) {
          const t = e.body.length, r = [];
          let o = !1, n = !1, i = null;
          for (let a = t - 1; a >= 0; a--) {
            const s = e.body[a];
            if (m.NodeGuards.isExpressionStatementNode(s)) m.NodeGuards.isSequenceExpressionNode(s.expression) ? r.unshift(...s.expression.expressions) : r.unshift(s.expression), i = a; else {
              if (!m.NodeGuards.isReturnStatementNode(s) || !s.argument) break;
              r.unshift(s.argument), o = !0, n = a !== t - 1, i = a
            }
          }
          return { startIndex: i, unwrappedExpressions: r, hasReturnStatement: o, hasStatementsAfterReturnStatement: n }
        }

        getLeadingStatements(e, t) {
          return null === t ? e.body : 0 === t ? [] : e.body.slice(0, t)
        }

        getPartialStatement(e) {
          return !e.leadingStatements.length && e.trailingStatement ? e.trailingStatement.statement : g.NodeFactory.blockStatementNode([...e.leadingStatements.length ? e.leadingStatements : [], ...e.trailingStatement ? [e.trailingStatement.statement] : []])
        }
      };
      t.AbstractStatementSimplifyTransformer = h, t.AbstractStatementSimplifyTransformer = h = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], h)
    }, 25115: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMOpCode = void 0, function (e) {
        e[e.PUSH_CONST = 0] = "PUSH_CONST", e[e.PUSH_UNDEFINED = 1] = "PUSH_UNDEFINED", e[e.PUSH_NULL = 2] = "PUSH_NULL", e[e.POP = 3] = "POP", e[e.DUP = 4] = "DUP", e[e.SWAP = 5] = "SWAP", e[e.LOAD_LOCAL = 6] = "LOAD_LOCAL", e[e.STORE_LOCAL = 7] = "STORE_LOCAL", e[e.LOAD_ARG = 8] = "LOAD_ARG", e[e.STORE_ARG = 9] = "STORE_ARG", e[e.ADD = 10] = "ADD", e[e.SUB = 11] = "SUB", e[e.MUL = 12] = "MUL", e[e.DIV = 13] = "DIV", e[e.MOD = 14] = "MOD", e[e.NEG = 15] = "NEG", e[e.INC = 16] = "INC", e[e.DEC = 17] = "DEC", e[e.EXPONENT = 18] = "EXPONENT", e[e.UNARY_PLUS = 19] = "UNARY_PLUS", e[e.BIT_AND = 20] = "BIT_AND", e[e.BIT_OR = 21] = "BIT_OR", e[e.BIT_XOR = 22] = "BIT_XOR", e[e.BIT_NOT = 23] = "BIT_NOT", e[e.SHL = 24] = "SHL", e[e.SHR = 25] = "SHR", e[e.USHR = 26] = "USHR", e[e.LOGICAL_NOT = 32] = "LOGICAL_NOT", e[e.EQ = 40] = "EQ", e[e.NEQ = 41] = "NEQ", e[e.STRICT_EQ = 42] = "STRICT_EQ", e[e.STRICT_NEQ = 43] = "STRICT_NEQ", e[e.LT = 44] = "LT", e[e.LTE = 45] = "LTE", e[e.GT = 46] = "GT", e[e.GTE = 47] = "GTE", e[e.JUMP = 50] = "JUMP", e[e.JUMP_IF_TRUE = 51] = "JUMP_IF_TRUE", e[e.JUMP_IF_FALSE = 52] = "JUMP_IF_FALSE", e[e.JUMP_NULLISH = 53] = "JUMP_NULLISH", e[e.CALL = 54] = "CALL", e[e.CALL_METHOD = 55] = "CALL_METHOD", e[e.RETURN = 56] = "RETURN", e[e.THROW = 57] = "THROW", e[e.TRY_START = 58] = "TRY_START", e[e.TRY_END = 59] = "TRY_END", e[e.CATCH_START = 60] = "CATCH_START", e[e.FINALLY_START = 61] = "FINALLY_START", e[e.FINALLY_END = 62] = "FINALLY_END", e[e.BREAK = 63] = "BREAK", e[e.CONTINUE = 64] = "CONTINUE", e[e.LABEL = 65] = "LABEL", e[e.GET_PROP = 70] = "GET_PROP", e[e.SET_PROP = 71] = "SET_PROP", e[e.GET_COMPUTED = 72] = "GET_COMPUTED", e[e.SET_COMPUTED = 73] = "SET_COMPUTED", e[e.DELETE_PROP = 74] = "DELETE_PROP", e[e.GET_GLOBAL = 75] = "GET_GLOBAL", e[e.SET_GLOBAL = 76] = "SET_GLOBAL", e[e.NEW_OBJECT = 77] = "NEW_OBJECT", e[e.GET_OPTIONAL = 78] = "GET_OPTIONAL", e[e.IN = 79] = "IN", e[e.HAS_OWN = 80] = "HAS_OWN", e[e.OBJECT_SPREAD = 81] = "OBJECT_SPREAD", e[e.GET_COMPUTED_OPTIONAL = 82] = "GET_COMPUTED_OPTIONAL", e[e.NEW_ARRAY = 90] = "NEW_ARRAY", e[e.ARRAY_PUSH = 91] = "ARRAY_PUSH", e[e.ARRAY_LENGTH = 92] = "ARRAY_LENGTH", e[e.SPREAD = 93] = "SPREAD", e[e.ARRAY_SPREAD_PUSH = 94] = "ARRAY_SPREAD_PUSH", e[e.NEW_FUNC = 100] = "NEW_FUNC", e[e.CALL_FUNC = 101] = "CALL_FUNC", e[e.APPLY = 102] = "APPLY", e[e.BIND = 103] = "BIND", e[e.NEW = 104] = "NEW", e[e.SUPER_CALL = 105] = "SUPER_CALL", e[e.IMPORT_DYNAMIC = 106] = "IMPORT_DYNAMIC", e[e.TYPEOF = 110] = "TYPEOF", e[e.INSTANCEOF = 111] = "INSTANCEOF", e[e.TYPEOF_GLOBAL = 112] = "TYPEOF_GLOBAL", e[e.YIELD = 120] = "YIELD", e[e.YIELD_STAR = 121] = "YIELD_STAR", e[e.AWAIT = 122] = "AWAIT", e[e.ITERATOR_NEXT = 123] = "ITERATOR_NEXT", e[e.ITERATOR_RETURN = 124] = "ITERATOR_RETURN", e[e.ITERATOR_THROW = 125] = "ITERATOR_THROW", e[e.FOR_OF_START = 126] = "FOR_OF_START", e[e.GET_ITERATOR = 127] = "GET_ITERATOR", e[e.ITERATOR_DONE = 128] = "ITERATOR_DONE", e[e.NEW_CLASS = 140] = "NEW_CLASS", e[e.CLASS_EXTENDS = 141] = "CLASS_EXTENDS", e[e.GET_SUPER_PROP = 142] = "GET_SUPER_PROP", e[e.DEFINE_METHOD = 144] = "DEFINE_METHOD", e[e.DEFINE_GETTER = 145] = "DEFINE_GETTER", e[e.DEFINE_SETTER = 146] = "DEFINE_SETTER", e[e.DEFINE_STATIC_METHOD = 147] = "DEFINE_STATIC_METHOD", e[e.DEFINE_STATIC_GETTER = 148] = "DEFINE_STATIC_GETTER", e[e.DEFINE_STATIC_SETTER = 149] = "DEFINE_STATIC_SETTER", e[e.THIS = 160] = "THIS", e[e.ARGUMENTS = 161] = "ARGUMENTS", e[e.NEW_REGEX = 162] = "NEW_REGEX",e[e.VOID = 163] = "VOID",e[e.NEW_TARGET = 164] = "NEW_TARGET",e[e.COMMA = 166] = "COMMA",e[e.SYMBOL = 167] = "SYMBOL",e[e.SYMBOL_FOR = 168] = "SYMBOL_FOR",e[e.SYMBOL_KEY_FOR = 169] = "SYMBOL_KEY_FOR",e[e.DEBUGGER = 200] = "DEBUGGER",e[e.NOP = 201] = "NOP",e[e.END = 202] = "END",e[e.DEFINE_METHOD_COMPUTED = 170] = "DEFINE_METHOD_COMPUTED",e[e.DEFINE_STATIC_METHOD_COMPUTED = 171] = "DEFINE_STATIC_METHOD_COMPUTED",e[e.DEFINE_GETTER_COMPUTED = 172] = "DEFINE_GETTER_COMPUTED",e[e.DEFINE_SETTER_COMPUTED = 173] = "DEFINE_SETTER_COMPUTED",e[e.DEFINE_STATIC_GETTER_COMPUTED = 174] = "DEFINE_STATIC_GETTER_COMPUTED",e[e.DEFINE_STATIC_SETTER_COMPUTED = 175] = "DEFINE_STATIC_SETTER_COMPUTED",e[e.CREATE_ENV = 210] = "CREATE_ENV",e[e.LOAD_FROM_ENV = 211] = "LOAD_FROM_ENV",e[e.STORE_TO_ENV = 212] = "STORE_TO_ENV",e[e.GET_ENV = 213] = "GET_ENV",e[e.RESTORE_PARENT_ENV = 214] = "RESTORE_PARENT_ENV",e[e.STORE_TO_CURRENT_ENV = 215] = "STORE_TO_CURRENT_ENV",e[e.STORE_TO_ENV_CONST = 216] = "STORE_TO_ENV_CONST",e[e.STORE_TO_CURRENT_ENV_CONST = 217] = "STORE_TO_CURRENT_ENV_CONST",e[e.DECLARE_TDZ = 218] = "DECLARE_TDZ",e[e.MACRO_INC_LOCAL = 250] = "MACRO_INC_LOCAL",e[e.MACRO_DEC_LOCAL = 251] = "MACRO_DEC_LOCAL",e[e.MACRO_ADD_LOCAL_CONST = 252] = "MACRO_ADD_LOCAL_CONST",e[e.MACRO_SUB_LOCAL_CONST = 253] = "MACRO_SUB_LOCAL_CONST",e[e.MACRO_MUL_LOCAL_CONST = 254] = "MACRO_MUL_LOCAL_CONST",e[e.MACRO_LOAD_LOCAL_GET_PROP = 255] = "MACRO_LOAD_LOCAL_GET_PROP",e[e.MACRO_LT_LOCAL_CONST = 256] = "MACRO_LT_LOCAL_CONST",e[e.MACRO_JUMP_IF_LOCAL_LT_CONST = 257] = "MACRO_JUMP_IF_LOCAL_LT_CONST",e[e.MACRO_CALL_LOCAL_METHOD = 258] = "MACRO_CALL_LOCAL_METHOD",e[e.MACRO_STORE_LOCAL_POP = 259] = "MACRO_STORE_LOCAL_POP",e[e.MACRO_INC_LOCAL_PRE = 260] = "MACRO_INC_LOCAL_PRE",e[e.MACRO_DEC_LOCAL_PRE = 261] = "MACRO_DEC_LOCAL_PRE"
      }(r || (t.VMOpCode = r = {}))
    }, 25220: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayRotateFunctionTemplate = function () {
        return "\n        (function (stringArrayFunction, comparisonValue) {\n            const stringArray = stringArrayFunction();\n        \n            while (true) {\n                try {\n                    const expression = {comparisonExpressionCode};\n                                            \n                    if (expression === comparisonValue) {\n                        break;\n                    } else {\n                        stringArray['push'](stringArray['shift']());\n                    }\n                } catch (e) {\n                    stringArray['push'](stringArray['shift']());\n                }\n            }\n        })({stringArrayFunctionName}, {comparisonValue});\n    "
      }
    }, 25560: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VariableLocation = void 0, function (e) {
        e[e.Environment = 0] = "Environment", e[e.Parameter = 1] = "Parameter", e[e.Local = 2] = "Local", e[e.Global = 3] = "Global", e[e.TDZ = 4] = "TDZ"
      }(r || (t.VariableLocation = r = {}))
    }, 25653: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionFunctionCodeHelper = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(39032), g = r(25714), h = r(76393), y = r(31142),
        S = r(98151), N = r(50164), b = r(96678), _ = r(7883), v = r(19593), I = r(48222), O = r(33056);
      let C = class extends I.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e) {
          this.debugProtectionFunctionName = e
        }

        getNodeStructure(e) {
          return O.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          const e = this.options.target !== S.ObfuscationTarget.BrowserNoEval ? (0, b.DebuggerTemplate)() : (0, _.DebuggerTemplateNoEval)();
          return this.customCodeHelperFormatter.formatTemplate((0, v.DebugProtectionFunctionTemplate)(), {
            debuggerTemplate: e,
            debugProtectionFunctionName: this.debugProtectionFunctionName
          })
        }
      };
      t.DebugProtectionFunctionCodeHelper = C, c([(0, N.initializable)(), l("design:type", String)], C.prototype, "debugProtectionFunctionName", void 0), t.DebugProtectionFunctionCodeHelper = C = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperObfuscator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== h.IOptions && h.IOptions) ? s : Object])], C)
    }, 25714: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 25850: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 26046: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.GlobalIdentifierNamesCacheStorage = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(48720);
      let f = class extends u.MapStorage {
        constructor(e, t) {
          super(e, t)
        }

        initialize() {
          var e, t;
          super.initialize(), this.storage = new Map(Object.entries(null !== (t = null === (e = this.options.identifierNamesCache) || void 0 === e ? void 0 : e.globalIdentifiers) && void 0 !== t ? t : {}))
        }
      };
      t.GlobalIdentifierNamesCacheStorage = f, i([(0, c.postConstruct)(), a("design:type", Function), a("design:paramtypes", []), a("design:returntype", void 0)], f.prototype, "initialize", null), t.GlobalIdentifierNamesCacheStorage = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], f)
    }, 26251: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p, u, f, m, g = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, h = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, y = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.Options = void 0;
      const S = r(45337), N = r(31391), b = r(97403), _ = r(22927), v = r(5297), I = r(76034), O = r(88847),
        C = r(92905), E = r(77898), T = r(52309), R = r(25850), M = r(76436), A = r(98151), F = r(82038), P = r(68289),
        D = r(64858), j = r(57088), x = r(51110), V = r(20965), G = r(48344), k = r(84133), L = r(45887), w = r(32121),
        B = r(84640), U = r(43853), H = r(82232), K = r(46331), z = r(29755), W = r(4057), X = r(80225), Y = r(75532),
        $ = r(86004);
      let q = o = class {
        constructor(e, t) {
          var r;
          const n = o.getOptionsByPreset(null !== (r = e.optionsPreset) && void 0 !== r ? r : F.OptionsPreset.Default);
          Object.assign(this, n, e);
          const i = (0, b.validateSync)(this, o.validatorOptions);
          if (i.length) throw new ReferenceError(`Validation failed. errors:\n${z.ValidationErrorsFormatter.format(i)}`);
          Object.assign(this, t.normalize(this))
        }

        static getOptionsByPreset(e) {
          var t;
          const r = null !== (t = o.optionPresetsMap.get(e)) && void 0 !== t ? t : null;
          if (!r) throw new Error(`Options for preset name \`${e}\` are not found`);
          return r
        }
      };
      t.Options = q, q.optionPresetsMap = new Map([[F.OptionsPreset.Default, L.DEFAULT_PRESET], [F.OptionsPreset.LowObfuscation, w.LOW_OBFUSCATION_PRESET], [F.OptionsPreset.MediumObfuscation, B.MEDIUM_OBFUSCATION_PRESET], [F.OptionsPreset.HighObfuscation, U.HIGH_OBFUSCATION_PRESET], [F.OptionsPreset.VMLowObfuscation, H.VM_LOW_OBFUSCATION_PRESET], [F.OptionsPreset.VMMediumObfuscation, K.VM_MEDIUM_OBFUSCATION_PRESET]]), q.validatorOptions = {
        forbidUnknownValues: !0,
        validationError: { target: !1 }
      }, g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "compact", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "controlFlowFlattening", void 0), g([(0, b.IsNumber)(), (0, b.Min)(0), (0, b.Max)(1), h("design:type", Number)], q.prototype, "controlFlowFlatteningThreshold", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "deadCodeInjection", void 0), g([(0, b.IsNumber)(), h("design:type", Number)], q.prototype, "deadCodeInjectionThreshold", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "debugProtection", void 0), g([(0, b.IsNumber)(), (0, b.Min)(0), h("design:type", Number)], q.prototype, "debugProtectionInterval", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "disableConsoleOutput", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), (0, W.IsAllowedForObfuscationTargets)([A.ObfuscationTarget.Browser, A.ObfuscationTarget.BrowserNoEval]), h("design:type", Array)], q.prototype, "domainLock", void 0), g([(0, X.IsDomainLockRedirectUrl)(), h("design:type", String)], q.prototype, "domainLockRedirectUrl", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), h("design:type", Array)], q.prototype, "forceTransformStrings", void 0), g([(0, Y.IsIdentifierNamesCache)(), h("design:type", "function" == typeof (a = void 0 !== _.TIdentifierNamesCache && _.TIdentifierNamesCache) ? a : Object)], q.prototype, "identifierNamesCache", void 0), g([(0, b.IsIn)([M.IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator, M.IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator, M.IdentifierNamesGenerator.MangledIdentifierNamesGenerator, M.IdentifierNamesGenerator.MangledShuffledIdentifierNamesGenerator]), h("design:type", "function" == typeof (s = void 0 !== T.TTypeFromEnum && T.TTypeFromEnum) ? s : Object)], q.prototype, "identifierNamesGenerator", void 0), g([(0, b.IsString)(), h("design:type", String)], q.prototype, "identifiersPrefix", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), (0, b.ValidateIf)(e => e.identifierNamesGenerator === M.IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator), (0, b.ArrayNotEmpty)(), h("design:type", Array)], q.prototype, "identifiersDictionary", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "ignoreImports", void 0), g([(0, $.IsInputFileName)(), h("design:type", String)], q.prototype, "inputFileName", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "log", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "numbersToExpressions", void 0), g([(0, b.IsIn)([F.OptionsPreset.Default, F.OptionsPreset.LowObfuscation, F.OptionsPreset.MediumObfuscation, F.OptionsPreset.HighObfuscation, F.OptionsPreset.VMLowObfuscation, F.OptionsPreset.VMMediumObfuscation]), h("design:type", "function" == typeof (c = void 0 !== I.TOptionsPreset && I.TOptionsPreset) ? c : Object)], q.prototype, "optionsPreset", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "renameGlobals", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "renameProperties", void 0), g([(0, b.IsIn)([P.RenamePropertiesMode.Safe, P.RenamePropertiesMode.Unsafe]), h("design:type", "function" == typeof (l = void 0 !== O.TRenamePropertiesMode && O.TRenamePropertiesMode) ? l : Object)], q.prototype, "renamePropertiesMode", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), h("design:type", Array)], q.prototype, "reservedNames", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), h("design:type", Array)], q.prototype, "reservedStrings", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "selfDefending", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "simplify", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "sourceMap", void 0), g([(0, b.IsString)(), (0, b.ValidateIf)(e => Boolean(e.sourceMapBaseUrl)), (0, b.IsUrl)({
        require_protocol: !0,
        require_tld: !1,
        require_valid_protocol: !0
      }), h("design:type", String)], q.prototype, "sourceMapBaseUrl", void 0), g([(0, b.IsString)(), h("design:type", String)], q.prototype, "sourceMapFileName", void 0), g([(0, b.IsIn)([D.SourceMapMode.Inline, D.SourceMapMode.Separate]), h("design:type", "function" == typeof (d = void 0 !== T.TTypeFromEnum && T.TTypeFromEnum) ? d : Object)], q.prototype, "sourceMapMode", void 0), g([(0, b.IsIn)([j.SourceMapSourcesMode.Sources, j.SourceMapSourcesMode.SourcesContent]), h("design:type", "function" == typeof (p = void 0 !== T.TTypeFromEnum && T.TTypeFromEnum) ? p : Object)], q.prototype, "sourceMapSourcesMode", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "splitStrings", void 0), g([(0, b.IsNumber)(), (0, b.ValidateIf)(e => Boolean(e.splitStrings)), (0, b.Min)(1), h("design:type", Number)], q.prototype, "splitStringsChunkLength", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "stringArray", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "stringArrayCallsTransform", void 0), g([(0, b.IsNumber)(), (0, b.Min)(0), (0, b.Max)(1), h("design:type", Number)], q.prototype, "stringArrayCallsTransformThreshold", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsIn)([V.StringArrayEncoding.None, V.StringArrayEncoding.Base64, V.StringArrayEncoding.Rc4], { each: !0 }), h("design:type", Array)], q.prototype, "stringArrayEncoding", void 0), g([(0, b.IsArray)(), (0, b.ArrayNotEmpty)(), (0, b.ArrayUnique)(), (0, b.IsIn)([x.StringArrayIndexesType.HexadecimalNumber, x.StringArrayIndexesType.HexadecimalNumericString], { each: !0 }), h("design:type", Array)], q.prototype, "stringArrayIndexesType", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "stringArrayIndexShift", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "stringArrayRotate", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "stringArrayShuffle", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "stringArrayWrappersChainedCalls", void 0), g([(0, b.IsNumber)(), (0, b.Min)(0), h("design:type", Number)], q.prototype, "stringArrayWrappersCount", void 0), g([(0, b.IsNumber)(), (0, b.Min)(2), h("design:type", Number)], q.prototype, "stringArrayWrappersParametersMaxCount", void 0), g([(0, b.IsIn)([G.StringArrayWrappersType.Variable, G.StringArrayWrappersType.Function]), h("design:type", "function" == typeof (u = void 0 !== C.TStringArrayWrappersType && C.TStringArrayWrappersType) ? u : Object)], q.prototype, "stringArrayWrappersType", void 0), g([(0, b.IsNumber)(), (0, b.Min)(0), (0, b.Max)(1), h("design:type", Number)], q.prototype, "stringArrayThreshold", void 0), g([(0, b.IsIn)([A.ObfuscationTarget.Browser, A.ObfuscationTarget.BrowserNoEval, A.ObfuscationTarget.Node, A.ObfuscationTarget.ServiceWorker]), h("design:type", "function" == typeof (f = void 0 !== T.TTypeFromEnum && T.TTypeFromEnum) ? f : Object)], q.prototype, "target", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "transformObjectKeys", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "unicodeEscapeSequence", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmObfuscation", void 0), g([(0, b.IsNumber)(), (0, b.Min)(0), (0, b.Max)(1), h("design:type", Number)], q.prototype, "vmObfuscationThreshold", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), h("design:type", Array)], q.prototype, "vmTargetFunctions", void 0), g([(0, b.IsArray)(), (0, b.ArrayUnique)(), (0, b.IsString)({ each: !0 }), h("design:type", Array)], q.prototype, "vmExcludeFunctions", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmOpcodeShuffle", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmBytecodeEncoding", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmBytecodeArrayEncoding", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmJumpsEncoding", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmDecoyOpcodes", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmDeadCodeInjection", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmSplitDispatcher", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmMacroOps", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmDebugProtection", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmRuntimeOpcodeDerivation", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmStatefulOpcodes", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmStackEncoding", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmRandomizeKeys", void 0), g([(0, b.IsBoolean)(), h("design:type", Boolean)], q.prototype, "vmIndirectDispatch", void 0), g([(0, b.IsIn)([k.VMBytecodeFormat.Json, k.VMBytecodeFormat.Binary]), h("design:type", "function" == typeof (m = void 0 !== E.TVMBytecodeFormat && E.TVMBytecodeFormat) ? m : Object)], q.prototype, "vmBytecodeFormat", void 0), t.Options = q = o = g([(0, S.injectable)(), y(0, (0, S.inject)(N.ServiceIdentifiers.TInputOptions)), y(1, (0, S.inject)(N.ServiceIdentifiers.IOptionsNormalizer)), h("design:paramtypes", ["function" == typeof (n = void 0 !== v.TInputOptions && v.TInputOptions) ? n : Object, "function" == typeof (i = void 0 !== R.IOptionsNormalizer && R.IOptionsNormalizer) ? i : Object])], q)
    }, 26323: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.simplifyingTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(80053), s = r(7154), c = r(62951), l = r(44847);
      t.simplifyingTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(a.BlockStatementSimplifyTransformer).whenTargetNamed(i.NodeTransformer.BlockStatementSimplifyTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(s.ExpressionStatementsMergeTransformer).whenTargetNamed(i.NodeTransformer.ExpressionStatementsMergeTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(c.IfStatementSimplifyTransformer).whenTargetNamed(i.NodeTransformer.IfStatementSimplifyTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(l.VariableDeclarationsMergeTransformer).whenTargetNamed(i.NodeTransformer.VariableDeclarationsMergeTransformer)
      })
    }, 26455: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractCustomCodeHelperGroup = void 0;
      const l = r(45337), d = r(31391), p = r(18741), u = r(76393), f = r(31142);
      let m = class {
        constructor(e, t, r) {
          this.identifierNamesGenerator = e(r), this.randomGenerator = t, this.options = r
        }

        getCustomCodeHelpers() {
          return this.customCodeHelpers
        }

        appendCustomNodeIfExist(e, t) {
          const r = this.customCodeHelpers.get(e);
          r && t(r)
        }

        getRandomCallsGraphIndex(e) {
          return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(e - 1)))
        }
      };
      t.AbstractCustomCodeHelperGroup = m, t.AbstractCustomCodeHelperGroup = m = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(2, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (o = void 0 !== p.TIdentifierNamesGeneratorFactory && p.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== u.IOptions && u.IOptions) ? i : Object])], m)
    }, 26906: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 27391: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeGuards = void 0;
      const o = r(93184);

      class n {
        static isArrayExpressionNode(e) {
          return e.type === o.NodeType.ArrayExpression
        }

        static isArrayPatternNode(e) {
          return e.type === o.NodeType.ArrayPattern
        }

        static isArrowFunctionExpressionNode(e) {
          return e.type === o.NodeType.ArrowFunctionExpression
        }

        static isAssignmentExpressionNode(e) {
          return e.type === o.NodeType.AssignmentExpression
        }

        static isAssignmentPatternNode(e) {
          return e.type === o.NodeType.AssignmentPattern
        }

        static isAwaitExpressionNode(e) {
          return e.type === o.NodeType.AwaitExpression
        }

        static isBigIntLiteralNode(e) {
          return n.isLiteralNode(e) && !!e.bigint
        }

        static isBinaryExpressionNode(e) {
          return e.type === o.NodeType.BinaryExpression
        }

        static isBlockStatementNode(e) {
          return e.type === o.NodeType.BlockStatement
        }

        static isBreakStatementNode(e) {
          return e.type === o.NodeType.BreakStatement
        }

        static isCallExpressionNode(e) {
          return e.type === o.NodeType.CallExpression
        }

        static isChainExpressionNode(e) {
          return e.type === o.NodeType.ChainExpression
        }

        static isClassBodyNode(e) {
          return e.type === o.NodeType.ClassBody
        }

        static isClassDeclarationNode(e) {
          return e.type === o.NodeType.ClassDeclaration && null !== e.id
        }

        static isClassExpressionNode(e) {
          return e.type === o.NodeType.ClassExpression && null !== e.id
        }

        static isClassNode(e) {
          return e.type === o.NodeType.ClassDeclaration || e.type === o.NodeType.ClassExpression
        }

        static isConditionalExpressionNode(e) {
          return e.type === o.NodeType.ConditionalExpression
        }

        static isContinueStatementNode(e) {
          return e.type === o.NodeType.ContinueStatement
        }

        static isDirectiveNode(e) {
          return e.type === o.NodeType.ExpressionStatement && "directive" in e
        }

        static isDoWhileStatementNode(e) {
          return e.type === o.NodeType.DoWhileStatement
        }

        static isExportAllDeclarationNode(e) {
          return e.type === o.NodeType.ExportAllDeclaration
        }

        static isExportNamedDeclarationNode(e) {
          return e.type === o.NodeType.ExportNamedDeclaration
        }

        static isExportSpecifierNode(e) {
          return e.type === o.NodeType.ExportSpecifier
        }

        static isExpressionStatementNode(e) {
          return e.type === o.NodeType.ExpressionStatement && !("directive" in e)
        }

        static isForStatementNode(e) {
          return e.type === o.NodeType.ForStatement
        }

        static isForInStatementNode(e) {
          return e.type === o.NodeType.ForInStatement
        }

        static isForOfStatementNode(e) {
          return e.type === o.NodeType.ForOfStatement
        }

        static isFunctionNode(e) {
          return n.isFunctionDeclarationNode(e) || n.isFunctionExpressionNode(e) || n.isArrowFunctionExpressionNode(e)
        }

        static isFunctionOrClassNode(e) {
          return n.isFunctionNode(e) || n.isClassNode(e)
        }

        static isFunctionDeclarationNode(e) {
          return e.type === o.NodeType.FunctionDeclaration && null !== e.id
        }

        static isFunctionExpressionNode(e) {
          return e.type === o.NodeType.FunctionExpression
        }

        static isIdentifierNode(e) {
          return e.type === o.NodeType.Identifier
        }

        static isIfStatementNode(e) {
          return e.type === o.NodeType.IfStatement
        }

        static isIfStatementNodeWithSingleStatementBody(e) {
          return !(!n.isIfStatementNode(e) || n.isBlockStatementNode(e.consequent) && (!e.alternate || n.isBlockStatementNode(e.alternate)))
        }

        static isImportDeclarationNode(e) {
          return e.type === o.NodeType.ImportDeclaration
        }

        static isImportExpressionNode(e) {
          return e.type === o.NodeType.ImportExpression
        }

        static isImportSpecifierNode(e) {
          return e.type === o.NodeType.ImportSpecifier
        }

        static isLabelIdentifierNode(e, t) {
          const r = n.isLabeledStatementNode(t) && t.label === e, o = n.isContinueStatementNode(t) && t.label === e,
            i = n.isBreakStatementNode(t) && t.label === e;
          return r || o || i
        }

        static isLabeledStatementNode(e) {
          return e.type === o.NodeType.LabeledStatement
        }

        static isLiteralNode(e) {
          return e.type === o.NodeType.Literal
        }

        static isLogicalExpressionNode(e) {
          return e.type === o.NodeType.LogicalExpression
        }

        static isMemberExpressionNode(e) {
          return e.type === o.NodeType.MemberExpression
        }

        static isMetaPropertyNode(e) {
          return e.type === o.NodeType.MetaProperty
        }

        static isMethodDefinitionNode(e) {
          return e.type === o.NodeType.MethodDefinition
        }

        static isNewExpressionNode(e) {
          return e.type === o.NodeType.NewExpression
        }

        static isNode(e) {
          return e && void 0 !== !e.type
        }

        static isNodeWithLexicalScope(e) {
          return n.isProgramNode(e) || n.isFunctionNode(e)
        }

        static isNodeWithBlockLexicalScope(e) {
          return n.isNodeWithLexicalScope(e) || n.isBlockStatementNode(e) || n.isStaticBlockNode(e)
        }

        static isNodeWithSingleStatementBody(e) {
          return n.isIfStatementNode(e) ? n.isIfStatementNodeWithSingleStatementBody(e) : (n.isForStatementNode(e) || n.isForOfStatementNode(e) || n.isForInStatementNode(e) || n.isWhileStatementNode(e) || n.isDoWhileStatementNode(e) || n.isWithStatementNode(e) || n.isLabeledStatementNode(e)) && !n.isBlockStatementNode(e.body)
        }

        static isNodeWithLexicalScopeStatements(e, t) {
          return n.isProgramNode(e) || n.isBlockStatementNode(e) && n.nodesWithLexicalStatements.includes(t.type)
        }

        static isNodeWithStatements(e) {
          return n.isProgramNode(e) || n.isBlockStatementNode(e) || n.isStaticBlockNode(e) || n.isSwitchCaseNode(e)
        }

        static isNodeWithComments(e) {
          return Boolean(e.leadingComments) || Boolean(e.trailingComments)
        }

        static isStatementOrDeclarationNode(e) {
          return e.type.endsWith("Statement") || e.type.endsWith("Declaration")
        }

        static isObjectPatternNode(e) {
          return e.type === o.NodeType.ObjectPattern
        }

        static isObjectExpressionNode(e) {
          return e.type === o.NodeType.ObjectExpression
        }

        static isPrivateIdentifierNode(e) {
          return e.type === o.NodeType.PrivateIdentifier
        }

        static isProgramNode(e) {
          return e.type === o.NodeType.Program
        }

        static isPropertyNode(e) {
          return e.type === o.NodeType.Property
        }

        static isPropertyDefinitionNode(e) {
          return e.type === o.NodeType.PropertyDefinition
        }

        static isRestElementNode(e) {
          return e.type === o.NodeType.RestElement
        }

        static isReturnStatementNode(e) {
          return e.type === o.NodeType.ReturnStatement
        }

        static isSequenceExpressionNode(e) {
          return e.type === o.NodeType.SequenceExpression
        }

        static isSpreadElementNode(e) {
          return e.type === o.NodeType.SpreadElement
        }

        static isStaticBlockNode(e) {
          return e.type === o.NodeType.StaticBlock
        }

        static isSuperNode(e) {
          return e.type === o.NodeType.Super
        }

        static isSwitchCaseNode(e) {
          return e.type === o.NodeType.SwitchCase
        }

        static isSwitchStatementNode(e) {
          return e.type === o.NodeType.SwitchStatement
        }

        static isTaggedTemplateExpressionNode(e) {
          return e.type === o.NodeType.TaggedTemplateExpression
        }

        static isTemplateLiteralNode(e) {
          return e.type === o.NodeType.TemplateLiteral
        }

        static isThisExpressionNode(e) {
          return e.type === o.NodeType.ThisExpression
        }

        static isTryStatementNode(e) {
          return e.type === o.NodeType.TryStatement
        }

        static isUnaryExpressionNode(e) {
          return e.type === o.NodeType.UnaryExpression
        }

        static isUpdateExpressionNode(e) {
          return e.type === o.NodeType.UpdateExpression
        }

        static isVariableDeclarationNode(e) {
          return e.type === o.NodeType.VariableDeclaration
        }

        static isVariableDeclaratorNode(e) {
          return e.type === o.NodeType.VariableDeclarator
        }

        static isWithStatementNode(e) {
          return e.type === o.NodeType.WithStatement
        }

        static isWhileStatementNode(e) {
          return e.type === o.NodeType.WhileStatement
        }

        static isYieldExpressionNode(e) {
          return e.type === o.NodeType.YieldExpression
        }
      }

      t.NodeGuards = n, n.nodesWithLexicalStatements = [o.NodeType.ArrowFunctionExpression, o.NodeType.FunctionDeclaration, o.NodeType.FunctionExpression, o.NodeType.MethodDefinition]
    }, 27404: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SourceMapBaseUrlRule = void 0, t.SourceMapBaseUrlRule = e => {
        const { sourceMapBaseUrl: t } = e;
        return e.sourceMapFileName ? (t && !t.endsWith("/") && (e = {
          ...e,
          sourceMapBaseUrl: `${t}/`
        }), e) : e = { ...e, sourceMapBaseUrl: "" }
      }
    }, 27757: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractCodeTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142);
      let u = class {
        constructor(e, t) {
          this.randomGenerator = e, this.options = t
        }
      };
      t.AbstractCodeTransformer = u, t.AbstractCodeTransformer = u = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], u)
    }, 28031: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 28057: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DictionaryIdentifierNamesGenerator = void 0;
      const d = r(45337), p = r(31391), u = r(26906), f = r(76393), m = r(31142), g = r(10419), h = r(75096);
      let y = o = class extends g.AbstractIdentifierNamesGenerator {
        constructor(e, t, r) {
          super(e, t), this.arrayUtils = r, this.identifierNamesSet = new Set(this.getInitialIdentifierNames(this.options.identifiersDictionary)), this.identifiersIterator = this.identifierNamesSet.values()
        }

        static incrementIdentifierName(e) {
          let t = "", r = !1;
          for (const o of e) r || o !== o.toUpperCase() ? r || o !== o.toLowerCase() ? t += o : (t += o.toUpperCase(), r = !0) : t += o.toLowerCase();
          return r ? t : null
        }

        generateNext() {
          const e = this.generateNewDictionaryName();
          return this.preserveName(e), e
        }

        generateForGlobalScope() {
          const e = this.options.identifiersPrefix ? `${this.options.identifiersPrefix}` : "",
            t = this.generateNewDictionaryName(t => {
              const r = `${e}${t}`;
              return this.isValidIdentifierName(r)
            }), r = `${e}${t}`;
          return this.preserveName(r), r
        }

        generateForLexicalScope(e) {
          const t = [e, ...h.NodeLexicalScopeUtils.getLexicalScopes(e)],
            r = this.generateNewDictionaryName(e => this.isValidIdentifierNameInLexicalScopes(e, t));
          return this.preserveNameForLexicalScope(r, e), r
        }

        generateForLabel(e) {
          return this.generateNewDictionaryName()
        }

        generateNewDictionaryName(e) {
          const t = () => {
            var r;
            if (!this.identifierNamesSet.size) throw new Error("Too many identifiers in the code, add more words to identifiers dictionary");
            const o = this.identifiersIterator.next();
            if (!o.done) {
              const n = o.value;
              return (null !== (r = null == e ? void 0 : e(n)) && void 0 !== r ? r : this.isValidIdentifierName(n)) ? o.value : t()
            }
            return this.identifierNamesSet = new Set(this.getIncrementedIdentifierNames([...this.identifierNamesSet])), this.identifiersIterator = this.identifierNamesSet.values(), t()
          };
          return t()
        }

        getInitialIdentifierNames(e) {
          const t = e.filter(Boolean).map(e => e.toLowerCase());
          return this.arrayUtils.shuffle(t)
        }

        getIncrementedIdentifierNames(e) {
          const t = [];
          for (const r of e) {
            const e = o.incrementIdentifierName(r);
            e && t.push(e)
          }
          return this.arrayUtils.shuffle(t)
        }
      };
      t.DictionaryIdentifierNamesGenerator = y, t.DictionaryIdentifierNamesGenerator = y = o = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.IOptions)), l(2, (0, d.inject)(p.ServiceIdentifiers.IArrayUtils)), c("design:paramtypes", ["function" == typeof (n = void 0 !== m.IRandomGenerator && m.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== f.IOptions && f.IOptions) ? i : Object, "function" == typeof (a = void 0 !== u.IArrayUtils && u.IArrayUtils) ? a : Object])], y)
    }, 28124: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.renameIdentifiersTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(59405), s = r(8759), c = r(14838), l = r(89438),
        d = r(18083), p = r(54960);
      t.renameIdentifiersTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(a.DeadCodeInjectionIdentifiersTransformer).whenTargetNamed(i.NodeTransformer.DeadCodeInjectionIdentifiersTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(c.LabeledStatementTransformer).whenTargetNamed(i.NodeTransformer.LabeledStatementTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(l.ScopeIdentifiersTransformer).whenTargetNamed(i.NodeTransformer.ScopeIdentifiersTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(d.ScopeThroughIdentifiersTransformer).whenTargetNamed(i.NodeTransformer.ScopeThroughIdentifiersTransformer), e(n.ServiceIdentifiers.IIdentifierReplacer).to(s.IdentifierReplacer).inSingletonScope(), e(n.ServiceIdentifiers.IThroughIdentifierReplacer).to(p.ThroughIdentifierReplacer).inSingletonScope()
      })
    }, 28240: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), l = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && c(t, e, r[n]);
        return l(t, e), t
      }), u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayStorageAnalyzer = void 0;
      const m = r(45337), g = r(31391), h = p(r(31659)), y = r(76393), S = r(31142), N = r(28523), b = r(27391),
        _ = r(45261), v = r(4592);
      let I = n = class {
        constructor(e, t, r) {
          this.stringArrayStorageData = new WeakMap, this.stringArrayStorage = e, this.randomGenerator = t, this.options = r
        }

        analyze(e) {
          this.options.stringArray && h.traverse(e, {
            enter: (e, t) => {
              if (t) return v.NodeMetadata.isIgnoredNode(e) ? h.VisitorOption.Skip : void (b.NodeGuards.isLiteralNode(e) && this.analyzeLiteralNode(e, t))
            }
          })
        }

        analyzeLiteralNode(e, t) {
          _.NodeLiteralUtils.isStringLiteralNode(e) && (_.NodeLiteralUtils.isProhibitedLiteralNode(e, t) || this.shouldAddValueToStringArray(e) && this.addItemDataForLiteralNode(e))
        }

        addItemDataForLiteralNode(e) {
          this.stringArrayStorageData.set(e, this.stringArrayStorage.getOrThrow(e.value))
        }

        getItemDataForLiteralNode(e) {
          return this.stringArrayStorageData.get(e)
        }

        shouldAddValueToStringArray(e) {
          return !!v.NodeMetadata.isForceTransformNode(e) || e.value.length >= n.minimumLengthForStringArray && !!this.options.stringArrayThreshold && this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold
        }
      };
      t.StringArrayStorageAnalyzer = I, I.minimumLengthForStringArray = 3, t.StringArrayStorageAnalyzer = I = n = d([(0, m.injectable)(), f(0, (0, m.inject)(g.ServiceIdentifiers.IStringArrayStorage)), f(1, (0, m.inject)(g.ServiceIdentifiers.IRandomGenerator)), f(2, (0, m.inject)(g.ServiceIdentifiers.IOptions)), u("design:paramtypes", ["function" == typeof (i = void 0 !== N.IStringArrayStorage && N.IStringArrayStorage) ? i : Object, "function" == typeof (a = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== y.IOptions && y.IOptions) ? s : Object])], I)
    }, 28523: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 28558: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.preparingTransformersModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(92486), s = r(22056), c = r(94472), l = r(12422),
        d = r(97114), p = r(39137), u = r(44539), f = r(66628), m = r(68113), g = r(44166), h = r(51234), y = r(1851),
        S = r(6822), N = r(96889);
      t.preparingTransformersModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.INodeTransformer).to(d.CustomCodeHelpersTransformer).whenTargetNamed(a.NodeTransformer.CustomCodeHelpersTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(p.EvalCallExpressionTransformer).whenTargetNamed(a.NodeTransformer.EvalCallExpressionTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(g.MetadataTransformer).whenTargetNamed(a.NodeTransformer.MetadataTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(h.ObfuscatingGuardsTransformer).whenTargetNamed(a.NodeTransformer.ObfuscatingGuardsTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(y.ParentificationTransformer).whenTargetNamed(a.NodeTransformer.ParentificationTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(N.VariablePreserveTransformer).whenTargetNamed(a.NodeTransformer.VariablePreserveTransformer), e(i.ServiceIdentifiers.INodeGuard).to(c.BlackListObfuscatingGuard).inSingletonScope().whenTargetNamed(s.ObfuscatingGuard.BlackListObfuscatingGuard), e(i.ServiceIdentifiers.INodeGuard).to(l.ConditionalCommentObfuscatingGuard).inSingletonScope().whenTargetNamed(s.ObfuscatingGuard.ConditionalCommentObfuscatingGuard), e(i.ServiceIdentifiers.INodeGuard).to(u.ForceTransformStringObfuscatingGuard).inSingletonScope().whenTargetNamed(s.ObfuscatingGuard.ForceTransformStringObfuscatingGuard), e(i.ServiceIdentifiers.INodeGuard).to(f.IgnoredImportObfuscatingGuard).inSingletonScope().whenTargetNamed(s.ObfuscatingGuard.IgnoredImportObfuscatingGuard), e(i.ServiceIdentifiers.INodeGuard).to(m.ImportMetaObfuscationGuard).inSingletonScope().whenTargetNamed(s.ObfuscatingGuard.ImportMetaObfuscationGuard), e(i.ServiceIdentifiers.INodeGuard).to(S.ReservedStringObfuscatingGuard).inSingletonScope().whenTargetNamed(s.ObfuscatingGuard.ReservedStringObfuscatingGuard), e(i.ServiceIdentifiers.Factory__INodeGuard).toFactory(o.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.INodeGuard))
      })
    }, 29154: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DeadCodeInjectionCustomNode = void 0, function (e) {
        e.BlockStatementDeadCodeInjectionNode = "BlockStatementDeadCodeInjectionNode"
      }(r || (t.DeadCodeInjectionCustomNode = r = {}))
    }, 29755: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ValidationErrorsFormatter = void 0;

      class r {
        static format(e) {
          return e.reduce((e, t) => [...e, r.formatWithNestedConstraints(t)], []).join("\n")
        }

        static formatWithNestedConstraints(e) {
          const t = e.constraints;
          return t ? `\`${e.property}\` errors:\n${Object.keys(t).map(e => `    - ${t[e]}\n`).join()}` : `\`${e.property}\` error\n`
        }
      }

      t.ValidationErrorsFormatter = r
    }, 29775: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ControlFlowFlatteningThresholdRule = void 0, t.ControlFlowFlatteningThresholdRule = e => (0 === e.controlFlowFlatteningThreshold && (e = {
        ...e,
        controlFlowFlattening: !1,
        controlFlowFlatteningThreshold: 0
      }), e)
    }, 29992: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.PropertyIdentifierNamesCacheStorage = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(48720);
      let f = class extends u.MapStorage {
        constructor(e, t) {
          super(e, t)
        }

        initialize() {
          var e, t;
          super.initialize(), this.storage = new Map(Object.entries(null !== (t = null === (e = this.options.identifierNamesCache) || void 0 === e ? void 0 : e.propertyIdentifiers) && void 0 !== t ? t : {}))
        }
      };
      t.PropertyIdentifierNamesCacheStorage = f, i([(0, c.postConstruct)(), a("design:type", Function), a("design:paramtypes", []), a("design:returntype", void 0)], f.prototype, "initialize", null), t.PropertyIdentifierNamesCacheStorage = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], f)
    }, 30215: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.nodeModule = void 0;
      const o = r(45337), n = r(31391), i = r(99097);
      t.nodeModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.IScopeIdentifiersTraverser).to(i.ScopeIdentifiersTraverser).inSingletonScope()
      })
    }, 30283: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LogicalExpressionControlFlowReplacer = void 0;
      const p = r(45337), u = r(31391), f = r(46300), m = r(18741), g = r(76393), h = r(31142), y = r(62059),
        S = r(42610), N = r(27391), b = r(33056);
      let _ = o = class extends S.ExpressionWithOperatorControlFlowReplacer {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        replace(e, t, r) {
          if (this.checkForProhibitedExpressions(e.left, e.right)) return e;
          const n = e.operator,
            i = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.LogicalExpressionFunctionNode);
          i.initialize(n);
          const a = this.insertCustomNodeToControlFlowStorage(i, r, n, o.usingExistingIdentifierChance);
          return this.getControlFlowStorageCallNode(r.getStorageId(), a, e.left, e.right)
        }

        checkForProhibitedExpressions(e, t) {
          return [e, t].some(e => {
            let t;
            return t = N.NodeGuards.isUnaryExpressionNode(e) ? b.NodeUtils.getUnaryExpressionArgumentNode(e) : e, !(N.NodeGuards.isLiteralNode(t) || N.NodeGuards.isIdentifierNode(t) || N.NodeGuards.isObjectExpressionNode(t) || N.NodeGuards.isExpressionStatementNode(t))
          })
        }
      };
      t.LogicalExpressionControlFlowReplacer = _, _.usingExistingIdentifierChance = .5, t.LogicalExpressionControlFlowReplacer = _ = o = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IControlFlowCustomNode)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (n = void 0 !== f.TControlFlowCustomNodeFactory && f.TControlFlowCustomNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? i : Object, "function" == typeof (a = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== g.IOptions && g.IOptions) ? s : Object])], _)
    }, 30451: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(13245), m = r(93571),
        g = r(27391);
      let h = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && g.NodeGuards.isObjectExpressionNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          return e.properties.forEach(e => {
            g.NodeGuards.isPropertyNode(e) && e.key && (e.computed ? this.transformComputedProperty(e) : this.transformBaseProperty(e))
          }), e
        }

        transformComputedProperty(e) {
          g.NodeGuards.isLiteralNode(e.key) && "string" == typeof e.key.value && (e.key = m.NodeFactory.literalNode(e.key.value))
        }

        transformBaseProperty(e) {
          e.shorthand && (e.shorthand = !1), g.NodeGuards.isIdentifierNode(e.key) && (e.key = m.NodeFactory.literalNode(e.key.name))
        }
      };
      t.ObjectExpressionTransformer = h, t.ObjectExpressionTransformer = h = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], h)
    }, 31030: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectPatternPropertiesTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(13245), m = r(27391),
        g = r(75096), h = r(33056);
      let y = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && m.NodeGuards.isPropertyNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (!m.NodeGuards.isObjectPatternNode(t) || !e.shorthand) return e;
          if (!this.options.renameGlobals) {
            const t = g.NodeLexicalScopeUtils.getLexicalScope(e);
            if (t && m.NodeGuards.isProgramNode(t)) return e
          }
          return e.shorthand = !1, e.value = h.NodeUtils.clone(e.value), h.NodeUtils.parentizeNode(e.value, e), e
        }
      };
      t.ObjectPatternPropertiesTransformer = y, t.ObjectPatternPropertiesTransformer = y = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], y)
    }, 31081: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LiteralNodesCacheStorage = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(20965), f = r(48720);
      let m = class extends f.MapStorage {
        constructor(e, t) {
          super(e, t)
        }

        buildKey(e, t) {
          return `${e}-${Boolean(t)}`
        }

        shouldUseCachedValue(e, t) {
          return !this.options.stringArrayWrappersCount && (null == t ? void 0 : t.encoding) !== u.StringArrayEncoding.Rc4 && this.storage.has(e)
        }
      };
      t.LiteralNodesCacheStorage = m, t.LiteralNodesCacheStorage = m = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], m)
    }, 31142: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 31307: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), p = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), u = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, f = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && d(t, e, r[n]);
        return p(t, e), t
      }), m = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, g = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMFunctionBytecodeCompiler = void 0;
      const h = r(45337), y = f(r(31659)), S = r(20924), N = r(94487), b = r(46725), _ = r(86173), v = r(25115),
        I = r(31391), O = r(27391), C = r(59805), E = r(57809), T = r(93571);
      let R = n = class {
        constructor(e, t, r, o, n) {
          this.vmCompilerUtils = e, this.variableCollector = t, this.scopeIdentifiersTraverser = r, this.closureAnalyzer = o, this.scopeManager = n
        }

        compileFunctionExpression(e, t) {
          var r, o;
          const n = O.NodeGuards.isArrowFunctionExpressionNode(e), i = this.vmCompilerUtils.createContext(t, n);
          i.declaredVariables = this.collectAllDeclaredVariables(e);
          const a = this.extractFunctionName(e, i), s = this.registerParameters(e.params, i);
          this.closureAnalyzer.analyzeEnvironmentVariables(e, i), this.copyParametersToEnvironment(i), this.emitEarlyTDZForDefaultParams(s.defaultParams, i, t), this.emitDefaultParameterCode(s.defaultParams, i), this.emitDestructuredParameterCode(s.destructuredParams, i), null !== s.restParamName && this.emitRestParameterCode(s.restParamName, s.restParamPattern, s.regularParamCount, i);
          const c = new Set(i.envVars), l = i.instructions.length;
          O.NodeGuards.isBlockStatementNode(e.body) ? this.compileBlockStatementBody(e.body, i) : this.compileExpressionBody(e.body, i, t), this.handleThisStorage(n, l, i), this.copyParametersToEnvironmentLate(l, i, c), this.finalizeFunctionCompilation(i, t, s.regularParamCount, null !== (r = e.async) && void 0 !== r && r, null !== (o = e.generator) && void 0 !== o && o, a)
        }

        compileCompoundOperator(e, t) {
          const r = n.compoundOpMap[e];
          void 0 !== r ? t.instructions.push({ op: r }) : this.vmCompilerUtils.createInstructionBuilder(t).pushUndefined()
        }

        extractFunctionName(e, t) {
          var r, o;
          if (O.NodeGuards.isFunctionExpressionNode(e) && (null === (r = e.id) || void 0 === r ? void 0 : r.name)) {
            const r = e.id.name;
            return t.envVars.add(r), t.functionName = r, r
          }
          if (O.NodeGuards.isFunctionDeclarationNode(e) && (null === (o = e.id) || void 0 === o ? void 0 : o.name)) {
            const r = e.id.name;
            return t.functionName = r, r
          }
          return null
        }

        emitEarlyTDZForDefaultParams(e, t, r) {
          if (0 === e.length) return;
          const o = this.vmCompilerUtils.createInstructionBuilder(t), n = new Set;
          for (const { defaultExpr: t } of e) this.closureAnalyzer.scanNodeForIdentifiers(t, n);
          for (const e of n) r.localVariablesInTDZ.has(e) && o.declareTDZ(e)
        }

        compileBlockStatementBody(e, t) {
          var r;
          this.hoistVarDeclarationsToLocals(e, t), this.hoistFunctionDeclarations(e, t), this.initializeHoistedVarEnvVariables(e, t), this.initializeLateDefinedEnvVariables(e, t);
          const o = this.variableCollector.scanForLexicalDeclarations(e.body);
          o.size > 0 && this.scopeManager.enterLocalsTDZ(t, [...o]);
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          for (const e of o) n.declareTDZ(e);
          t.isFunctionBody = !0, null === (r = t.dispatch) || void 0 === r || r.statement(e), t.isFunctionBody = !1
        }

        compileExpressionBody(e, t, r) {
          var o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t), i = new Set;
          this.closureAnalyzer.scanNodeForIdentifiers(e, i);
          for (const e of i) r.localVariablesInTDZ.has(e) && n.declareTDZ(e);
          null === (o = t.dispatch) || void 0 === o || o.expression(e), n.return()
        }

        finalizeFunctionCompilation(e, t, r, o, n, i) {
          const a = this.mergeNestedFunctions(e, t), s = this.createNestedBytecode(e, r, a, o, n, i),
            c = t.nestedFunctions.size;
          t.nestedFunctions.set(c, s);
          const l = this.vmCompilerUtils.createInstructionBuilder(t), d = t.constantPool.forceAdd(c);
          t.functionRefIndices.add(d), l.loadConstByIndex(d), this.propagateCapturedVariables(e, t), l.newFunc()
        }

        registerParameters(e, t) {
          let r = 0;
          const o = [], n = [];
          let i = null, a = null;
          return e ? (e.forEach((e, s) => {
            if (O.NodeGuards.isIdentifierNode(e)) this.registerSimpleParameter(e, s, t), r++; else if (O.NodeGuards.isAssignmentPatternNode(e)) r++, this.registerDefaultParameter(e, s, t, o, n); else if (O.NodeGuards.isArrayPatternNode(e) || O.NodeGuards.isObjectPatternNode(e)) this.registerDestructuredParameter(e, s, n), r++; else if (O.NodeGuards.isRestElementNode(e)) {
              const r = this.registerRestParameter(e, t);
              i = r.restParamName, a = r.restParamPattern
            }
          }), {
            regularParamCount: r,
            defaultParams: o,
            destructuredParams: n,
            restParamName: i,
            restParamPattern: a
          }) : { regularParamCount: r, defaultParams: o, destructuredParams: n, restParamName: i, restParamPattern: a }
        }

        registerSimpleParameter(e, t, r) {
          r.parameters.set(e.name, t)
        }

        registerDefaultParameter(e, t, r, o, n) {
          O.NodeGuards.isIdentifierNode(e.left) ? (r.parameters.set(e.left.name, t), o.push({
            paramIndex: t,
            defaultExpr: e.right
          })) : (O.NodeGuards.isArrayPatternNode(e.left) || O.NodeGuards.isObjectPatternNode(e.left)) && (n.push({
            paramIndex: t,
            pattern: e.left
          }), o.push({ paramIndex: t, defaultExpr: e.right }))
        }

        registerDestructuredParameter(e, t, r) {
          r.push({ paramIndex: t, pattern: e })
        }

        registerRestParameter(e, t) {
          let r, o = null;
          if (O.NodeGuards.isIdentifierNode(e.argument)) {
            r = e.argument.name;
            const o = t.localVariables.size;
            t.localVariables.set(r, o)
          } else if (O.NodeGuards.isArrayPatternNode(e.argument) || O.NodeGuards.isObjectPatternNode(e.argument)) {
            o = e.argument, r = "__rest_temp__";
            const n = t.localVariables.size;
            t.localVariables.set(r, n)
          } else {
            r = "__rest_temp__";
            const e = t.localVariables.size;
            t.localVariables.set(r, e)
          }
          return { restParamName: r, restParamPattern: o }
        }

        emitDefaultParameterCode(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          for (const { paramIndex: n, defaultExpr: i } of e) {
            o.loadArg(n);
            const e = o.emitUndefinedCheck();
            o.pop(), t.parametersInTDZ.clear();
            for (const [e, r] of t.parameters) r >= n && t.parametersInTDZ.add(e);
            for (const [e, r] of t.parameters) r > n && t.envVars.has(e) && o.declareTDZ(e);
            null === (r = t.dispatch) || void 0 === r || r.expression(i), o.storeArg(n);
            let a = null;
            for (const [e, r] of t.parameters) if (r === n) {
              a = e;
              break
            }
            a && t.envVars.has(a) && (o.loadArg(n), o.storeToEnvByName(a), o.pop());
            const s = o.jump();
            e.patchToHere(), o.pop(), s.patchToHere()
          }
          t.parametersInTDZ.clear()
        }

        emitDestructuredParameterCode(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t), n = t._compilingFunctionParameters;
          t._compilingFunctionParameters = !0;
          for (const {
            paramIndex: n,
            pattern: i
          } of e) o.loadArg(n), null === (r = t.dispatch) || void 0 === r || r.destructuring(i, !1);
          void 0 !== n ? t._compilingFunctionParameters = n : delete t._compilingFunctionParameters
        }

        emitRestParameterCode(e, t, r, o) {
          this.vmCompilerUtils.emitRestParameterHandling(e, t, r, o)
        }

        copyParametersToEnvironment(e, t = new Set) {
          const r = this.vmCompilerUtils.createInstructionBuilder(e);
          let o = !1;
          for (const [t] of e.parameters) if (e.envVars.has(t)) {
            if (!e.parentContext) {
              o = !0;
              break
            }
            if (this.vmCompilerUtils.isDeclaredInParentScope(t, e.parentContext)) {
              o = !0;
              break
            }
          }
          if (!o && e.parentContext) for (const t of e.envVars) if (!e.parameters.has(t) && t !== e.functionName && this.vmCompilerUtils.isDeclaredInParentScope(t, e.parentContext)) {
            o = !0;
            break
          }
          const n = e.parentContext && e.parentContext.envDepth > 0;
          (n || o) && ((n || o) && (r.getEnv(), r.createEnv(), e.envDepth++), e.needsEnvRestoreAtEnd = !0);
          for (const [n, i] of e.parameters) if (e.envVars.has(n)) {
            if (t.has(i)) continue;
            r.loadArg(i), o ? r.storeToCurrentEnvByName(n) : r.storeToEnvByName(n), r.pop()
          }
        }

        initializeHoistedVarEnvVariables(e, t) {
          const r = new Set;
          this.vmCompilerUtils.traverseStatements(e.body, e => {
            if (O.NodeGuards.isVariableDeclarationNode(e) && "var" === e.kind) for (const o of e.declarations) if (O.NodeGuards.isIdentifierNode(o.id)) {
              const e = o.id.name;
              t.envVars.has(e) && !this.isShadowedByFunctionOrParam(e, t) && r.add(e)
            } else if (O.NodeGuards.isArrayPatternNode(o.id) || O.NodeGuards.isObjectPatternNode(o.id)) {
              const e = new Set;
              this.variableCollector.collectFromPattern(o.id, e);
              for (const o of e) t.envVars.has(o) && !this.isShadowedByFunctionOrParam(o, t) && r.add(o)
            }
          });
          for (const e of r) this.emitEnvVarInit(e, t)
        }

        hoistVarDeclarationsToLocals(e, t) {
          for (const r of e.body) this.vmCompilerUtils.traverseBlocksSkipScopes(r, e => {
            if (O.NodeGuards.isVariableDeclarationNode(e) && "var" === e.kind) for (const r of e.declarations) {
              const e = this.vmCompilerUtils.extractIdentifiersFromPattern(r.id);
              for (const r of e) {
                if (t.localVariables.has(r) || t.parameters.has(r)) continue;
                const e = t.localVariables.size;
                t.localVariables.set(r, e)
              }
            }
          })
        }

        initializeLateDefinedEnvVariables(e, t) {
          const r = new Set([...t.parameters.keys(), ...t.localVariables.keys()]), o = new Set(r);
          this.collectAllDeclaredVarsInBlock(e, o);
          const n = this.findLateDefinedVars(e.body, r, o, t);
          this.emitLateDefinedVarInitialization(n, t)
        }

        collectAllDeclaredVarsInBlock(e, t) {
          y.traverse(e, {
            enter: e => {
              if (O.NodeGuards.isVariableDeclarationNode(e)) for (const r of e.declarations) {
                const e = this.vmCompilerUtils.extractIdentifiersFromPattern(r.id);
                for (const r of e) t.add(r)
              } else O.NodeGuards.isFunctionDeclarationNode(e) && t.add(e.id.name);
              if (O.NodeGuards.isFunctionOrClassNode(e)) return y.VisitorOption.Skip
            }
          })
        }

        collectIdentifierReferencesFromNode(e, t) {
          y.traverse(e, {
            enter: (e, r) => {
              if (O.NodeGuards.isIdentifierNode(e)) {
                if (r && O.NodeGuards.isMemberExpressionNode(r) && r.property === e && !r.computed) return;
                if (r && O.NodeGuards.isPropertyNode(r) && r.key === e && !r.computed) return;
                t.add(e.name)
              }
              if (O.NodeGuards.isFunctionDeclarationNode(e) || O.NodeGuards.isClassNode(e)) return y.VisitorOption.Skip
            }
          })
        }

        findClosuresInStatement(e) {
          const t = [];
          return y.traverse(e, {
            enter: e => {
              if ((O.NodeGuards.isFunctionExpressionNode(e) || O.NodeGuards.isArrowFunctionExpressionNode(e)) && t.push(e), O.NodeGuards.isFunctionDeclarationNode(e) || O.NodeGuards.isClassNode(e)) return y.VisitorOption.Skip
            }
          }), t
        }

        markStatementDeclarations(e, t) {
          y.traverse(e, {
            enter: e => {
              if (O.NodeGuards.isVariableDeclarationNode(e)) for (const r of e.declarations) {
                const e = this.vmCompilerUtils.extractIdentifiersFromPattern(r.id);
                for (const r of e) t.add(r)
              } else O.NodeGuards.isFunctionDeclarationNode(e) && t.add(e.id.name);
              if (O.NodeGuards.isFunctionOrClassNode(e)) return y.VisitorOption.Skip
            }
          })
        }

        findLateDefinedVars(e, t, r, o) {
          const n = new Set;
          for (const i of e) {
            this.markStatementDeclarations(i, t);
            const e = this.findClosuresInStatement(i);
            for (const i of e) {
              const e = new Set;
              this.collectIdentifierReferencesFromNode(i, e);
              for (const i of e) this.isLateDefinedEnvVar(i, t, r, o) && n.add(i)
            }
          }
          return n
        }

        isLateDefinedEnvVar(e, t, r, o) {
          return !(t.has(e) || !o.envVars.has(e) || !r.has(e) || this.isShadowedByFunctionOrParam(e, o))
        }

        emitLateDefinedVarInitialization(e, t) {
          if (0 === e.size) return;
          const r = new Set;
          for (const o of e) t.envVars.has(o) && r.add(o);
          if (0 !== r.size) {
            t.lateDefinedEnvVars || (t.lateDefinedEnvVars = new Set);
            for (const e of r) t.lateDefinedEnvVars.add(e), this.emitEnvVarInit(e, t)
          }
        }

        handleThisStorage(e, t, r) {
          var o, n;
          if (e) return !1;
          let i = !1, a = !1;
          for (const [, e] of r.nestedFunctions) if ((null === (o = e.capturedVars) || void 0 === o ? void 0 : o.includes(C.VM_SPECIAL_VARS.capturedThis)) && (i = !0), (null === (n = e.capturedVars) || void 0 === n ? void 0 : n.includes(C.VM_SPECIAL_VARS.capturedArguments)) && (a = !0), i && a) break;
          const s = [];
          if (i) {
            const e = r.constantPool.add(C.VM_SPECIAL_VARS.capturedThis);
            s.push({ op: v.VMOpCode.THIS }, { op: v.VMOpCode.STORE_TO_ENV, arg: e }, { op: v.VMOpCode.POP })
          }
          if (a) {
            const e = r.constantPool.add(C.VM_SPECIAL_VARS.capturedArguments);
            s.push({ op: v.VMOpCode.ARGUMENTS, arg: 0 }, {
              op: v.VMOpCode.STORE_TO_ENV,
              arg: e
            }, { op: v.VMOpCode.POP })
          }
          return s.length > 0 && (r.instructions.splice(t, 0, ...s), this.vmCompilerUtils.adjustJumpTargetsAfterInsertion(t, s.length, r), !0)
        }

        copyParametersToEnvironmentLate(e, t, r) {
          const o = [];
          for (const [e, n] of t.parameters) t.envVars.has(e) && !r.has(e) && o.push([e, n]);
          if (0 === o.length) return;
          const n = [];
          for (const [e, r] of o) {
            const o = t.constantPool.add(e);
            n.push({
              op: v.VMOpCode.LOAD_ARG,
              arg: r
            }), t.needsEnvRestoreAtEnd ? n.push({
              op: v.VMOpCode.STORE_TO_CURRENT_ENV,
              arg: o
            }) : n.push({ op: v.VMOpCode.STORE_TO_ENV, arg: o }), n.push({ op: v.VMOpCode.POP })
          }
          t.instructions.splice(e, 0, ...n), this.vmCompilerUtils.adjustJumpTargetsAfterInsertion(e, n.length, t)
        }

        mergeNestedFunctions(e, t) {
          const r = new Map;
          for (const [o] of e.nestedFunctions) {
            const e = t.nestedFunctions.size + r.size;
            r.set(o, e)
          }
          for (const [o, n] of e.nestedFunctions) {
            const e = r.get(o), i = n.constants.map((e, t) => {
              var o;
              return (null === (o = n.functionRefIndices) || void 0 === o ? void 0 : o.has(t)) && "number" == typeof e && r.has(e) ? r.get(e) : e
            });
            t.nestedFunctions.set(e, { ...n, constants: i })
          }
          return r
        }

        createNestedBytecode(e, t, r, o, n, i) {
          let a;
          i && (a = e.constantPool.add(i));
          const s = {
            id: e.nextBytecodeId++,
            constants: e.constantPool.getAll(),
            instructions: e.instructions,
            params: t,
            locals: e.localVariables.size,
            capturedVars: Array.from(e.capturedVars),
            functionRefIndices: e.functionRefIndices,
            isArrow: e.isArrowFunction,
            isAsync: o,
            isGenerator: n,
            functionNameIndex: a
          }, c = s.constants.map((e, t) => {
            var o;
            return (null === (o = s.functionRefIndices) || void 0 === o ? void 0 : o.has(t)) && "number" == typeof e && r.has(e) ? r.get(e) : e
          });
          return s.constants = c, s
        }

        propagateCapturedVariables(e, t) {
          for (const r of e.capturedVars) {
            const o = this.contextDeclaresVariable(r, e, !0), n = this.contextDeclaresVariable(r, t, !1);
            (!o || !n && t.declaredVariables) && (n ? t.envVars.has(r) || t.envVars.add(r) : (t.capturedVars.has(r) || (t.capturedVars.add(r), r === C.VM_SPECIAL_VARS.capturedThis && (t.capturedThis = !0), r === C.VM_SPECIAL_VARS.capturedArguments && (t.capturedArguments = !0)), t.parameters.has(r) && !t.parametersInTDZ.has(r) || t.envVars.has(r) || t.envVars.add(r)))
          }
        }

        contextDeclaresVariable(e, t, r) {
          var o;
          if (t.localVariables.has(e)) return !0;
          if (t.parameters.has(e) && !t.parametersInTDZ.has(e)) return !0;
          const n = e.split("$$")[0];
          return !!this.hasMatchingBaseNameVariable(n, t, r) || !(r || !(null === (o = t.declaredVariables) || void 0 === o ? void 0 : o.has(e)))
        }

        hasMatchingBaseNameVariable(e, t, r) {
          for (const o of t.localVariables.keys()) {
            const t = o.split("$$");
            if (t[0] === e) {
              if (r && (t.length > 1 ? parseInt(t[1], 10) : 0) > 1) continue;
              return !0
            }
          }
          for (const r of t.parameters.keys()) if (r.split("$$")[0] === e) return !0;
          return !1
        }

        hoistFunctionDeclarations(e, t) {
          var r;
          for (const o of e.body) if (O.NodeGuards.isFunctionDeclarationNode(o) && o.id) {
            const e = o.id.name;
            null === (r = t.dispatch) || void 0 === r || r.statement(o), t.hoistedFunctionDeclarations.add(e)
          }
        }

        collectAllDeclaredVariables(e) {
          const t = new Set, r = T.NodeFactory.programNode([]);
          if (O.NodeGuards.isFunctionDeclarationNode(e)) r.body.push(e); else {
            const t = T.NodeFactory.expressionStatementNode(e);
            r.body.push(t)
          }
          return this.scopeIdentifiersTraverser.traverseScopeIdentifiers(r, null, e => {
            t.add(e.variable.name)
          }), t
        }

        isShadowedByFunctionOrParam(e, t) {
          const r = e === t.functionName, o = t.parameters.has(e) && !t.parametersInTDZ.has(e);
          return r || o
        }

        emitEnvVarInit(e, t) {
          const r = this.vmCompilerUtils.createInstructionBuilder(t), o = t.constantPool.add(e);
          r.pushUndefined(), r.storeToCurrentEnv(o), r.pop()
        }
      };
      t.VMFunctionBytecodeCompiler = R, R.compoundOpMap = {
        "+=": v.VMOpCode.ADD,
        "-=": v.VMOpCode.SUB,
        "*=": v.VMOpCode.MUL,
        "/=": v.VMOpCode.DIV,
        "%=": v.VMOpCode.MOD,
        "**=": v.VMOpCode.EXPONENT,
        "<<=": v.VMOpCode.SHL,
        ">>=": v.VMOpCode.SHR,
        ">>>=": v.VMOpCode.USHR,
        "&=": v.VMOpCode.BIT_AND,
        "|=": v.VMOpCode.BIT_OR,
        "^=": v.VMOpCode.BIT_XOR
      }, t.VMFunctionBytecodeCompiler = R = n = u([(0, h.injectable)(), g(0, (0, h.inject)(I.ServiceIdentifiers.IVMCompilerUtils)), g(1, (0, h.inject)(I.ServiceIdentifiers.IVMVariableCollector)), g(2, (0, h.inject)(I.ServiceIdentifiers.IScopeIdentifiersTraverser)), g(3, (0, h.inject)(I.ServiceIdentifiers.IVMClosureAnalyzer)), g(4, (0, h.inject)(I.ServiceIdentifiers.IVMScopeManager)), m("design:paramtypes", ["function" == typeof (i = void 0 !== S.IVMCompilerUtils && S.IVMCompilerUtils) ? i : Object, "function" == typeof (a = void 0 !== b.IVMVariableCollector && b.IVMVariableCollector) ? a : Object, "function" == typeof (s = void 0 !== E.IScopeIdentifiersTraverser && E.IScopeIdentifiersTraverser) ? s : Object, "function" == typeof (c = void 0 !== _.IVMClosureAnalyzer && _.IVMClosureAnalyzer) ? c : Object, "function" == typeof (l = void 0 !== N.IVMScopeManager && N.IVMScopeManager) ? l : Object])], R)
    }, 31321: e => {
      e.exports = require("reflect-metadata")
    }, 31352: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringControlFlowStorage = void 0;
      const l = r(45337), d = r(31391), p = r(18741), u = r(76393), f = r(31142), m = r(8041);
      let g = class extends m.FunctionControlFlowStorage {
        constructor(e, t, r) {
          super(e, t, r)
        }

        initialize() {
          super.initialize(), this.storageId = this.identifierNamesGenerator.generateForGlobalScope()
        }
      };
      t.StringControlFlowStorage = g, t.StringControlFlowStorage = g = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), c(2, (0, l.inject)(d.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), s("design:paramtypes", ["function" == typeof (o = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== u.IOptions && u.IOptions) ? n : Object, "function" == typeof (i = void 0 !== p.TIdentifierNamesGeneratorFactory && p.TIdentifierNamesGeneratorFactory) ? i : Object])], g)
    }, 31391: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ServiceIdentifiers = void 0, function (e) {
        e.Factory__ICalleeDataExtractor = "Factory<ICalleeDataExtractor>", e.Factory__ICodeTransformer = "Factory<ICodeTransformer[]>", e.Factory__IControlFlowCustomNode = "Factory<IControlFlowCustomNode>", e.Factory__IControlFlowReplacer = "Factory<IControlFlowReplacer>", e.Factory__ICustomCodeHelper = "Factory<ICustomCodeHelper>", e.Factory__ICustomCodeHelperGroup = "Factory<ICustomCodeHelperGroup>", e.Factory__IDeadCodeInjectionCustomNode = "Factory<IDeadCodeInjectionCustomNode>", e.Factory__IIdentifierNamesGenerator = "Factory<IIdentifierNamesGenerator>", e.Factory__INodeGuard = "Factory<INodeGuard>", e.Factory__INodeTransformer = "Factory<INodeTransformer[]>", e.Factory__IObfuscationResult = "Factory<IObfuscationResult>", e.Factory__IObjectExpressionKeysTransformerCustomNode = "Factory<IObjectExpressionKeysTransformerCustomNode>", e.Factory__IObjectExpressionExtractor = "Factory<IObjectExpressionExtractor>", e.Factory__IStringArrayCustomNode = "Factory<IStringArrayCustomNode>", e.Factory__IStringArrayIndexNode = "Factory<IStringArrayIndexNode>", e.Factory__TControlFlowStorage = "Factory<TControlFlowStorage>", e.IArrayUtils = "IArrayUtils", e.ICalleeDataExtractor = "ICalleeDataExtractor", e.ICallsGraphAnalyzer = "ICallsGraphAnalyzer", e.ICodeTransformer = "ICodeTransformer", e.ICodeTransformerNamesGroupsBuilder = "ICodeTransformerNamesGroupsBuilder", e.ICodeTransformersRunner = "ICodeTransformersRunner", e.IControlFlowStorage = "IControlFlowStorage", e.ICryptUtils = "ICryptUtils", e.ICryptUtilsStringArray = "ICryptUtilsStringArray", e.ICustomCodeHelper = "ICustomCodeHelper", e.ICustomCodeHelperGroup = "ICustomCodeHelperGroup", e.IControlFlowReplacer = "IControlFlowReplacer", e.ICustomCodeHelperFormatter = "ICustomCodeHelperFormatter", e.ICustomCodeHelperObfuscator = "ICustomCodeHelperObfuscator", e.IEscapeSequenceEncoder = "IEscapeSequenceEncoder", e.IGlobalIdentifierNamesCacheStorage = "IGlobalIdentifierNamesCacheStorage", e.IIdentifierNamesGenerator = "IIdentifierNamesGenerator", e.IIdentifierReplacer = "IIdentifierReplacer", e.IJavaScriptObfuscator = "IJavaScriptObfuscator", e.ILevelledTopologicalSorter = "ILevelledTopologicalSorter", e.ILiteralNodesCacheStorage = "ILiteralNodesCacheStorage", e.ILogger = "ILogger", e.INodeGuard = "INodeGuard", e.INodeTransformer = "INodeTransformer", e.INodeTransformerNamesGroupsBuilder = "INodeTransformerNamesGroupsBuilder", e.INodeTransformersRunner = "INodeTransformersRunner", e.INumberNumericalExpressionAnalyzer = "INumberNumericalExpressionAnalyzer", e.IObfuscationResult = "IObfuscationResult", e.IOptions = "IOptions", e.IOptionsNormalizer = "IOptionsNormalizer", e.IPrevailingKindOfVariablesAnalyzer = "IPrevailingKindOfVariablesAnalyzer", e.IPropertyIdentifierNamesCacheStorage = "IPropertyIdentifierNamesCacheStorage", e.IObjectExpressionExtractor = "IObjectExpressionExtractor", e.IRandomGenerator = "IRandomGenerator", e.IRenamePropertiesReplacer = "IRenamePropertiesReplacer", e.IScopeIdentifiersTraverser = "IScopeIdentifiersTraverser", e.ISetUtils = "ISetUtils", e.ISourceCode = "ISourceCode", e.IScopeAnalyzer = "IScopeAnalyzer", e.IStringArrayIndexNode = "IStringArrayIndexNode", e.IStringArrayScopeCallsWrappersDataStorage = "IStringArrayScopeCallsWrappersDataStorage", e.IStringArrayStorage = "IStringArrayStorage", e.IStringArrayStorageAnalyzer = "IStringArrayStorageAnalyzer", e.IThroughIdentifierReplacer = "IThroughIdentifierReplacer", e.IVisitedLexicalScopeNodesStackStorage = "IVisitedLexicalScopeNodesStackStorage", e.IVMDestructuringBytecodeCompiler = "IVMDestructuringBytecodeCompiler", e.IVMExpressionBytecodeCompiler = "IVMExpressionBytecodeCompiler", e.IVMFunctionBytecodeCompiler = "IVMFunctionBytecodeCompiler", e.IVMClassBytecodeCompiler = "IVMClassBytecodeCompiler", e.IVMLiteralBytecodeCompiler = "IVMLiteralBytecodeCompiler", e.IVMParameterBytecodeCompiler = "IVMParameterBytecodeCompiler", e.IVMStatementBytecodeCompiler = "IVMStatementBytecodeCompiler", e.IVMLoopCompiler = "IVMLoopCompiler", e.IVMConditionalCompiler = "IVMConditionalCompiler", e.IVMExceptionCompiler = "IVMExceptionCompiler", e.IVMDeclarationCompiler = "IVMDeclarationCompiler", e.IVMOperatorCompiler = "IVMOperatorCompiler", e.IVMAssignmentCompiler = "IVMAssignmentCompiler", e.IVMCallCompiler = "IVMCallCompiler", e.IVMMemberAccessCompiler = "IVMMemberAccessCompiler", e.IVMBytecodeCompiler = "IVMBytecodeCompiler", e.IVMCompilerUtils = "IVMCompilerUtils", e.IVMVariableCollector = "IVMVariableCollector", e.IVMClosureAnalyzer = "IVMClosureAnalyzer", e.IVMGlobalStorageUtils = "IVMGlobalStorageUtils", e.IVMVariableResolver = "IVMVariableResolver", e.IVMScopeManager = "IVMScopeManager", e.IVMBytecodeStorage = "IVMBytecodeStorage", e.IVMDeadCodeInjector = "IVMDeadCodeInjector", e.IVMMacroOpOptimizer = "IVMMacroOpOptimizer", e.IVMFunctionSelector = "IVMFunctionSelector", e.IVMOpcodeMapStorage = "IVMOpcodeMapStorage", e.Newable__ICustomNode = "Newable<ICustomNode>", e.TCustomNodeGroupStorage = "TCustomNodeGroupStorage", e.TInputOptions = "TInputOptions"
      }(r || (t.ServiceIdentifiers = r = {}))
    }, 31424: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getMacroOpcodeTemplates = function () {
        return "\n                        // Macro Operations (fused instructions)\n\n                        case opMap[250]: { // MACRO_INC_LOCAL: local[arg]++\n                            // Fuses: LOAD_LOCAL, PUSH_CONST 1, ADD, STORE_LOCAL\n                            locals[arg] = locals[arg] + 1;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[251]: { // MACRO_DEC_LOCAL: local[arg]--\n                            // Fuses: LOAD_LOCAL, PUSH_CONST 1, SUB, STORE_LOCAL\n                            locals[arg] = locals[arg] - 1;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[252]: { // MACRO_ADD_LOCAL_CONST: push(local[localIdx] + const[constIdx])\n                            // Fuses: LOAD_LOCAL, PUSH_CONST, ADD\n                            // arg = (constIdx << 16) | localIdx\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroConstIdx = arg >>> 16;\n                            stack.push(locals[macroLocalIdx] + constants[macroConstIdx]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[253]: { // MACRO_SUB_LOCAL_CONST: push(local[localIdx] - const[constIdx])\n                            // Fuses: LOAD_LOCAL, PUSH_CONST, SUB\n                            // arg = (constIdx << 16) | localIdx\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroConstIdx = arg >>> 16;\n                            stack.push(locals[macroLocalIdx] - constants[macroConstIdx]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[254]: { // MACRO_MUL_LOCAL_CONST: push(local[localIdx] * const[constIdx])\n                            // Fuses: LOAD_LOCAL, PUSH_CONST, MUL\n                            // arg = (constIdx << 16) | localIdx\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroConstIdx = arg >>> 16;\n                            stack.push(locals[macroLocalIdx] * constants[macroConstIdx]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[255]: { // MACRO_LOAD_LOCAL_GET_PROP: push(local[localIdx][const[propIdx]])\n                            // Fuses: LOAD_LOCAL, GET_PROP\n                            // arg = (propIdx << 16) | localIdx\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroPropIdx = arg >>> 16;\n                            let macroObj = locals[macroLocalIdx];\n                            let macroProp = constants[macroPropIdx];\n                            stack.push(macroObj[macroProp]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[256]: { // MACRO_LT_LOCAL_CONST: push(local[localIdx] < const[constIdx])\n                            // Fuses: LOAD_LOCAL, PUSH_CONST, LT\n                            // arg = (constIdx << 16) | localIdx\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroConstIdx = arg >>> 16;\n                            stack.push(locals[macroLocalIdx] < constants[macroConstIdx]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[257]: { // MACRO_JUMP_IF_LOCAL_LT_CONST: if (local[localIdx] < const[constIdx]) jump\n                            // Fuses: LOAD_LOCAL, PUSH_CONST, LT, JUMP_IF_TRUE\n                            // arg = (constIdx << 16) | localIdx, target stored in jump targets\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroConstIdx = arg >>> 16;\n                            if (locals[macroLocalIdx] < constants[macroConstIdx]) {\n                                pc = decodeJump(jumpTargets[pc]);\n                            } else {\n                                pc++;\n                            }\n                            break;\n                        }\n\n                        case opMap[258]: { // MACRO_CALL_LOCAL_METHOD: local[localIdx][const[propIdx]](...args)\n                            // Fuses: LOAD_LOCAL, GET_PROP, CALL_METHOD\n                            // arg = (propIdx << 16) | localIdx\n                            let macroLocalIdx = arg & 0xFFFF;\n                            let macroPropIdx = arg >>> 16;\n                            let macroArgCount = stack.pop();\n                            let macroCallArgs = collectArgs(stack, macroArgCount);\n                            let macroCallObj = locals[macroLocalIdx];\n                            let macroCallProp = constants[macroPropIdx];\n                            let macroCallMethod = macroCallObj[macroCallProp];\n                            stack.push(macroCallMethod.apply(macroCallObj, macroCallArgs));\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[259]: { // MACRO_STORE_LOCAL_POP: store and discard\n                            // Fuses: STORE_LOCAL, POP\n                            locals[arg] = stack.pop();\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[260]: { // MACRO_INC_LOCAL_PRE: ++local[arg] (returns incremented value)\n                            // Fuses: LOAD_LOCAL, PUSH_CONST 1, ADD, DUP, STORE_LOCAL\n                            let macroIncVal = locals[arg] + 1;\n                            locals[arg] = macroIncVal;\n                            stack.push(macroIncVal);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[261]: { // MACRO_DEC_LOCAL_PRE: --local[arg] (returns decremented value)\n                            // Fuses: LOAD_LOCAL, PUSH_CONST 1, SUB, DUP, STORE_LOCAL\n                            let macroDecVal = locals[arg] - 1;\n                            locals[arg] = macroDecVal;\n                            stack.push(macroDecVal);\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 31514: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.EscapeSequenceTransformer = void 0;
      const l = r(45337), d = r(31391), p = r(45316), u = r(76393), f = r(31142), m = r(75716), g = r(92486),
        h = r(13245), y = r(27391), S = r(45261), N = r(93571), b = r(33056);
      let _ = class extends h.AbstractNodeTransformer {
        constructor(e, t, r) {
          super(e, t), this.runAfter = [g.NodeTransformer.CustomCodeHelpersTransformer], this.escapeSequenceEncoder = r
        }

        getVisitor(e) {
          return e === m.NodeTransformationStage.Finalizing ? {
            enter: (e, t) => {
              if (y.NodeGuards.isLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (!S.NodeLiteralUtils.isStringLiteralNode(e)) return e;
          const r = this.escapeSequenceEncoder.encode(e.value, this.options.unicodeEscapeSequence),
            o = N.NodeFactory.literalNode(r);
          return b.NodeUtils.parentizeNode(o, t), o
        }
      };
      t.EscapeSequenceTransformer = _, t.EscapeSequenceTransformer = _ = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), c(2, (0, l.inject)(d.ServiceIdentifiers.IEscapeSequenceEncoder)), s("design:paramtypes", ["function" == typeof (o = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== u.IOptions && u.IOptions) ? n : Object, "function" == typeof (i = void 0 !== p.IEscapeSequenceEncoder && p.IEscapeSequenceEncoder) ? i : Object])], _)
    }, 31659: e => {
      e.exports = require("@javascript-obfuscator/estraverse")
    }, 32111: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getStateMachineFunctionsTemplate = function () {
        return `\n            // ===== State Machine Functions =====\n            // State-dependent opcode resolution and stack encoding\n\n            // Number of VM states\n            let _SM_NUM_STATES = 8;\n\n            // Mixing constants (must match compile-time exactly)\n            let _SM_MULT1 = 0x9E3779B9;\n            let _SM_MULT2 = 0x85EBCA6B;\n            let _SM_MULT3 = 0xC2B2AE35;\n\n            // Opcode count (covers all VMOpCode values including macro-ops 250-261)\n            let _SM_OPCODE_COUNT = ${o.VM_OPCODE_COUNT};\n\n            // Mix bits of a 32-bit integer\n            function _smMixBits(h) {\n                h = h >>> 0;\n                h ^= h >>> 16;\n                h = Math.imul(h, _SM_MULT2) >>> 0;\n                h ^= h >>> 13;\n                h = Math.imul(h, _SM_MULT3) >>> 0;\n                h ^= h >>> 16;\n                return h >>> 0;\n            }\n\n            // Compute VM state based on position (pc)\n            // IMPORTANT: State is computed purely from seed and pc, NOT from execution history.\n            // This is critical because control flow can jump around, and we need\n            // the same state at a given pc regardless of how we got there.\n            function _smComputeState(seed, pc) {\n                let combined = seed ^ ((pc * _SM_MULT1) >>> 0);\n                return _smMixBits(combined) % _SM_NUM_STATES;\n            }\n\n            // Evolve stack encoding key\n            function _smEvolveStackKey(key, state, opcode, pc) {\n                let combined = key ^ ((state * _SM_MULT1) >>> 0);\n                combined = (combined ^ ((opcode * _SM_MULT2) >>> 0)) >>> 0;\n                combined = (combined ^ ((pc * _SM_MULT3) >>> 0)) >>> 0;\n                return _smMixBits(combined);\n            }\n\n            // Generate permutation using Fisher-Yates shuffle\n            function _smGeneratePermutation(seed, size) {\n                let arr = [];\n                for (let i = 0; i < size; i++) {\n                    arr[i] = i;\n                }\n                let s = seed;\n                for (let i = size - 1; i > 0; i--) {\n                    s = _smMixBits(s ^ i);\n                    let j = s % (i + 1);\n                    let tmp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = tmp;\n                }\n                return arr;\n            }\n\n            // Cache for derived state maps\n            let _smStateMapsCache = {};\n\n            // Get or create state maps from seed\n            function _smGetStateMaps(seed) {\n                if (_smStateMapsCache[seed]) {\n                    return _smStateMapsCache[seed];\n                }\n\n                let stateMaps = [];\n                for (let state = 0; state < _SM_NUM_STATES; state++) {\n                    let stateSeed = _smMixBits(seed ^ (state * _SM_MULT1));\n                    let permutation = _smGeneratePermutation(stateSeed, _SM_OPCODE_COUNT);\n\n                    // Create reverse lookup: physicalOpcode -> logicalOpcode\n                    let reverseMap = {};\n                    for (let i = 0; i < _SM_OPCODE_COUNT; i++) {\n                        reverseMap[permutation[i]] = i;\n                    }\n                    stateMaps.push(reverseMap);\n                }\n\n                _smStateMapsCache[seed] = stateMaps;\n                return stateMaps;\n            }\n\n            // Encode a numeric value for stack (only for numbers)\n            function _smEncodeValue(value, key) {\n                if (typeof value === 'number' && Number.isFinite(value) && Number.isInteger(value)) {\n                    // Only encode 32-bit integers\n                    if (value >= -2147483648 && value <= 2147483647) {\n                        return (value ^ key) | 0;\n                    }\n                }\n                return value;\n            }\n\n            // Decode a numeric value from stack\n            function _smDecodeValue(value, key) {\n                if (typeof value === 'number' && Number.isFinite(value) && Number.isInteger(value)) {\n                    if (value >= -2147483648 && value <= 2147483647) {\n                        return (value ^ key) | 0;\n                    }\n                }\n                return value;\n            }\n`
      }, t.getStateMachineInitTemplate = function () {
        return "\n                // State machine initialization (when vmStatefulOpcodes is enabled)\n                // State is computed from seed and pc for each instruction (position-based, not history-based)\n                let _smSeed = bc[{keySmSeed}] || 0;\n                let _smStateMaps = _smSeed ? _smGetStateMaps(_smSeed) : null;\n"
      }, t.getStackEncodingInitTemplate = function () {
        return "\n                // Stack encoding initialization (when vmStackEncoding is enabled)\n                // Override stack methods to transparently encode/decode numeric values\n                if (bc[{keySeKey}] !== undefined) {\n                    let _seKey = bc[{keySeKey}];\n                    let _origPush = stack.push.bind(stack);\n                    let _origPop = stack.pop.bind(stack);\n                    stack.push = function(v) {\n                        // Only encode 32-bit integers\n                        if (typeof v === 'number' && Number.isFinite(v) && Number.isInteger(v) && v >= -2147483648 && v <= 2147483647) {\n                            return _origPush((v ^ _seKey) | 0);\n                        }\n                        return _origPush(v);\n                    };\n                    stack.pop = function() {\n                        let v = _origPop();\n                        // Only decode 32-bit integers\n                        if (typeof v === 'number' && Number.isFinite(v) && Number.isInteger(v) && v >= -2147483648 && v <= 2147483647) {\n                            return (v ^ _seKey) | 0;\n                        }\n                        return v;\n                    };\n                }\n"
      }, t.getStatefulOpcodeResolutionTemplate = function () {
        return "\n                            // State-dependent opcode resolution\n                            if (_smStateMaps) {\n                                // Resolve physical opcode to logical opcode using current state\n                                logicalOp = _smStateMaps[_smState][logicalOp];\n                            }\n"
      }, t.getStateEvolutionTemplate = function () {
        return "\n                            // Evolve state machine state\n                            if (_smStateMaps) {\n                                _smState = _smEvolveState(_smState, logicalOp, pc - 1, _smPrevOpcode);\n                                _smPrevOpcode = logicalOp;\n                            }\n"
      }, t.getStackEncodingPushTemplate = function () {
        return "\n            // Encoded stack push\n            function _sePush(stack, value, _seKey, state, opcode, pc) {\n                let encodedValue = _smEncodeValue(value, _seKey);\n                stack.push(encodedValue);\n                return _smEvolveStackKey(_seKey, state, opcode, pc);\n            }\n"
      }, t.getStackEncodingPopTemplate = function () {
        return "\n            // Encoded stack pop\n            function _sePop(stack, _seKey, state, opcode, pc) {\n                let encodedValue = stack.pop();\n                let decodedValue = _smDecodeValue(encodedValue, _seKey);\n                return { value: decodedValue, newKey: _smEvolveStackKey(_seKey, state, opcode, pc) };\n            }\n"
      };
      const o = r(79240)
    }, 32121: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LOW_OBFUSCATION_PRESET = void 0;
      const o = r(82038), n = r(45887);
      t.LOW_OBFUSCATION_PRESET = Object.freeze({
        ...n.DEFAULT_PRESET,
        disableConsoleOutput: !0,
        optionsPreset: o.OptionsPreset.LowObfuscation,
        stringArrayRotate: !0,
        selfDefending: !0,
        simplify: !0,
        stringArrayCallsTransform: !1,
        stringArrayCallsTransformThreshold: 0,
        stringArrayShuffle: !0
      })
    }, 32238: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NumericalExpressionDataToNodeConverter = void 0;
      const o = r(93571), n = r(24660);

      class i {
        static convertIntegerNumberData(e, t) {
          return i.convertNumericalExpressionDataToNode(e, t)
        }

        static convertFloatNumberData(e, t, r) {
          const n = i.convertNumericalExpressionDataToNode(e, r);
          return o.NodeFactory.binaryExpressionNode("+", n, o.NodeFactory.literalNode(t))
        }

        static convertNumericalExpressionDataToNode(e, t, r = "+") {
          var o;
          const n = e.length, a = n > 1 ? e.slice(0, n - 1) : [e[0]], s = n > 1 ? e.slice(-1) : [];
          if (s.length) return i.convertPartsToBinaryExpression(r, a, s, t);
          const c = null !== (o = a[0]) && void 0 !== o ? o : null;
          return Array.isArray(c) ? i.convertNumericalExpressionDataToNode(c, t, "*") : i.convertPartOrNumberToLiteralNode(c, t)
        }

        static convertPartsToBinaryExpression(e, t, r, n) {
          const a = r[0];
          return Array.isArray(a) ? o.NodeFactory.binaryExpressionNode(e, i.convertNumericalExpressionDataToNode(t, n), i.convertNumericalExpressionDataToNode(a, n, "*")) : o.NodeFactory.binaryExpressionNode(e, i.convertNumericalExpressionDataToNode(t, n), this.convertPartOrNumberToLiteralNode(a, n))
        }

        static convertPartOrNumberToLiteralNode(e, t) {
          const r = Array.isArray(e) ? e[0] : e, o = n.NumberUtils.isPositive(r);
          return t(Math.abs(r), o)
        }
      }

      t.NumericalExpressionDataToNodeConverter = i
    }, 32385: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.GlobalVariableTemplate2 = function () {
        return "\n        const getGlobal = function () {\n            let globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        const that = getGlobal();\n    "
      }
    }, 32840: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallNode = void 0;
      const m = r(45337), g = r(31391), h = r(18741), y = r(46293), S = r(26906), N = r(39032), b = r(76393),
        _ = r(31142), v = r(28523), I = r(50164), O = r(43382), C = r(93571), E = r(33056), T = r(70475);
      let R = class extends O.AbstractStringArrayCallNode {
        constructor(e, t, r, o, n, i, a) {
          super(e, t, r, o, n, i, a)
        }

        initialize(e, t, r, o) {
          this.index = e, this.indexShiftAmount = t, this.stringArrayCallsWrapperData = r, this.decodeKey = o
        }

        getNodeStructure() {
          var e, t;
          const r = this.indexShiftAmount + this.stringArrayCallsWrapperData.index + this.index,
            o = this.getStringArrayIndexNode(r), n = this.decodeKey ? this.getRc4KeyLiteralNode(this.decodeKey) : null,
            i = this.arrayUtils.fillWithRange(this.stringArrayCallsWrapperData.parameterIndexesData ? this.options.stringArrayWrappersParametersMaxCount : O.AbstractStringArrayCallNode.stringArrayRootCallsWrapperParametersCount, () => this.getFakeStringArrayIndexNode(r));
          i.splice(null !== (t = null === (e = this.stringArrayCallsWrapperData.parameterIndexesData) || void 0 === e ? void 0 : e.valueIndexParameterIndex) && void 0 !== t ? t : 0, 1, o), this.stringArrayCallsWrapperData.parameterIndexesData ? i.splice(this.stringArrayCallsWrapperData.parameterIndexesData.decodeKeyParameterIndex, 1, null != n ? n : this.getFakeStringArrayIndexNode(r)) : n ? i.splice(1, 1, n) : i.splice(1, 1);
          const a = C.NodeFactory.expressionStatementNode(C.NodeFactory.callExpressionNode(C.NodeFactory.identifierNode(this.stringArrayCallsWrapperData.name), i));
          return E.NodeUtils.parentizeAst(a), [a]
        }

        getFakeStringArrayIndexNode(e) {
          return this.getStringArrayIndexNode(this.getFakeStringArrayIndex(e))
        }

        getFakeStringArrayIndex(e) {
          const t = this.stringArrayStorage.getLength() / 2, r = e - t, o = e + t;
          return this.randomGenerator.getRandomInteger(r, o)
        }
      };
      t.StringArrayCallNode = R, p([(0, I.initializable)(), u("design:type", Object)], R.prototype, "decodeKey", void 0), p([(0, I.initializable)(), u("design:type", Number)], R.prototype, "index", void 0), p([(0, I.initializable)(), u("design:type", Number)], R.prototype, "indexShiftAmount", void 0), p([(0, I.initializable)(), u("design:type", "function" == typeof (d = void 0 !== T.IStringArrayScopeCallsWrapperData && T.IStringArrayScopeCallsWrapperData) ? d : Object)], R.prototype, "stringArrayCallsWrapperData", void 0), t.StringArrayCallNode = R = p([(0, m.injectable)(), f(0, (0, m.inject)(g.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), f(1, (0, m.inject)(g.ServiceIdentifiers.Factory__IStringArrayIndexNode)), f(2, (0, m.inject)(g.ServiceIdentifiers.ICustomCodeHelperFormatter)), f(3, (0, m.inject)(g.ServiceIdentifiers.IStringArrayStorage)), f(4, (0, m.inject)(g.ServiceIdentifiers.IArrayUtils)), f(5, (0, m.inject)(g.ServiceIdentifiers.IRandomGenerator)), f(6, (0, m.inject)(g.ServiceIdentifiers.IOptions)), u("design:paramtypes", ["function" == typeof (o = void 0 !== h.TIdentifierNamesGeneratorFactory && h.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== y.TStringArrayIndexNodeFactory && y.TStringArrayIndexNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== N.ICustomCodeHelperFormatter && N.ICustomCodeHelperFormatter) ? i : Object, "function" == typeof (a = void 0 !== v.IStringArrayStorage && v.IStringArrayStorage) ? a : Object, "function" == typeof (s = void 0 !== S.IArrayUtils && S.IArrayUtils) ? s : Object, "function" == typeof (c = void 0 !== _.IRandomGenerator && _.IRandomGenerator) ? c : Object, "function" == typeof (l = void 0 !== b.IOptions && b.IOptions) ? l : Object])], R)
    }, 33056: function (e, t, r) {
      var o, n = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), a = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), a = 0; a < r.length; a++) "default" !== r[a] && n(t, e, r[a]);
        return i(t, e), t
      });
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeUtils = void 0;
      const s = a(r(65850)), c = a(r(31659)), l = r(51168), d = r(63989), p = r(27391), u = r(4592);

      class f {
        static addXVerbatimPropertyTo(e) {
          return e["x-verbatim-property"] = { content: e.raw, precedence: s.Precedence.Primary }, e
        }

        static clone(e) {
          return f.parentizeAst(f.cloneRecursive(e))
        }

        static convertCodeToStructure(e) {
          const t = d.ASTParserFacade.parse(e, { ecmaVersion: l.ecmaVersion, sourceType: "script" });
          return c.replace(t, { enter: (e, t) => (f.parentizeNode(e, t), p.NodeGuards.isLiteralNode(e) && f.addXVerbatimPropertyTo(e), u.NodeMetadata.set(e, { ignoredNode: !1 }), e) }), t.body
        }

        static convertStructureToCode(e) {
          return e.reduce((e, t) => e + s.generate(t, { sourceMapWithCode: !0 }).code, "")
        }

        static getUnaryExpressionArgumentNode(e) {
          return p.NodeGuards.isUnaryExpressionNode(e.argument) ? f.getUnaryExpressionArgumentNode(e.argument) : e.argument
        }

        static parentizeAst(e) {
          var t;
          const r = null !== (t = e.parentNode) && void 0 !== t ? t : null;
          return c.replace(e, { enter: f.parentizeNode }), r && (e.parentNode = r), e
        }

        static parentizeNode(e, t) {
          return e.parentNode = null != t ? t : e, e
        }

        static cloneRecursive(e) {
          if (null === e) return e;
          const t = {};
          return Object.keys(e).forEach(r => {
            var o;
            if ("parentNode" === r) return;
            const n = null !== (o = e[r]) && void 0 !== o ? o : null;
            let i;
            i = null === n || n instanceof RegExp ? n : n instanceof Array ? n.map(f.cloneRecursive) : "object" == typeof n ? f.cloneRecursive(n) : n, t[r] = i
          }), t
        }
      }

      t.NodeUtils = f
    }, 33636: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getRuntimeHelpersTemplate = function () {
        return `\n            // Helper: Collect arguments from stack with spread support\n            // Used by CALL, CALL_METHOD, NEW, SUPER_CALL opcodes\n            function collectArgs(stack, argCount) {\n                let args = [];\n                for (let i = 0; i < argCount; i++) {\n                    let val = stack.pop();\n                    if (val && typeof val === 'object' && val.__spread__ === true) {\n                        let spreadArr = val.value;\n                        if (Array.isArray(spreadArr)) {\n                            for (let j = spreadArr.length - 1; j >= 0; j--) {\n                                args.push(spreadArr[j]);\n                            }\n                        }\n                    } else {\n                        args.push(val);\n                    }\n                }\n                args.reverse();\n                return args;\n            }\n\n            // Debug protection: Timing-based anti-debug check\n            // If debugger slows down execution, corrupt internal state\n            // Only active when vmDebugProtection option is enabled (dbgEnabled placeholder)\n            //\n            // Uses very conservative thresholds to avoid false positives:\n            // - 5 second threshold: Normal execution takes < 1ms per 100 instructions\n            //   Even under extreme system load, 100 instructions don't take 5 seconds\n            // - Only debugger stepping (human clicking "step") causes 5+ second delays\n            // - 3 consecutive slow checks required for extra safety\n            //\n            // False positive analysis:\n            // - Normal execution: < 1ms per check  No trigger\n            // - Heavy CPU load: 10-100ms per check  No trigger\n            // - Extreme GC pause: 100-500ms  No trigger\n            // - System thrashing: 500ms-2s  No trigger\n            // - Debugger stepping: 1-10+ seconds  TRIGGER\n            let _dbgEnabled = {dbgEnabled};\n            let _dbgLastTime = 0;\n            let _dbgSlowCount = 0;\n            let _dbgCorrupted = false;\n            let _dbgThreshold = 5000; // 5 seconds - only debugger stepping takes this long\n            let _dbgConsecutiveRequired = 3; // 3 consecutive 5+ second delays = definitely debugging\n            function _checkDebug() {\n                if (!_dbgEnabled || _dbgCorrupted) return;\n                let now = Date.now();\n                if (_dbgLastTime === 0) {\n                    _dbgLastTime = now;\n                    return;\n                }\n                let delta = now - _dbgLastTime;\n                _dbgLastTime = now;\n                if (delta > _dbgThreshold) {\n                    _dbgSlowCount++;\n                    if (_dbgSlowCount >= _dbgConsecutiveRequired) {\n                        _dbgCorrupted = true;\n                        for (let k in {vmOpcodeMapName}) {\n                            {vmOpcodeMapName}[k] = ({vmOpcodeMapName}[k] + 1) & ${o.VM_OPCODE_MASK};\n                        }\n                    }\n                } else {\n                    _dbgSlowCount = 0;\n                }\n            }\n`
      };
      const o = r(79240)
    }, 35196: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 35826: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, n = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMOpcodeMapStorage = void 0;
      const i = r(45337), a = r(48720), s = r(25115), c = r(79240);
      let l = class extends a.MapStorage {
        constructor() {
          super(...arguments), this.opcodeRange = c.VM_OPCODE_COUNT
        }

        initialize() {
          super.initialize(), this.generateRandomizedMapping()
        }

        generateRandomizedMapping() {
          this.storage.clear();
          const e = Object.values(s.VMOpCode).filter(e => "number" == typeof e), t = [];
          for (let e = 0; e < this.opcodeRange; e++) t.push(e);
          for (let e = t.length - 1; e > 0; e--) {
            const r = Math.floor(this.randomGenerator.getMathRandom() * (e + 1));
            [t[e], t[r]] = [t[r], t[e]]
          }
          e.forEach((e, r) => {
            this.storage.set(e, t[r])
          })
        }

        getRandomizedOpcode(e) {
          const t = this.get(e);
          if (void 0 === t) throw new Error(`No randomized opcode found for logical opcode ${e}`);
          return t
        }

        getMappingObject() {
          const e = {};
          return this.storage.forEach((t, r) => {
            e[r] = t
          }), e
        }

        generateNewMapping() {
          const e = {}, t = Object.values(s.VMOpCode).filter(e => "number" == typeof e), r = [];
          for (let e = 0; e < this.opcodeRange; e++) r.push(e);
          for (let e = r.length - 1; e > 0; e--) {
            const t = Math.floor(this.randomGenerator.getMathRandom() * (e + 1));
            [r[e], r[t]] = [r[t], r[e]]
          }
          return t.forEach((t, o) => {
            e[t] = r[o]
          }), e
        }
      };
      t.VMOpcodeMapStorage = l, o([(0, i.postConstruct)(), n("design:type", Function), n("design:paramtypes", []), n("design:returntype", void 0)], l.prototype, "initialize", null), t.VMOpcodeMapStorage = l = o([(0, i.injectable)()], l)
    }, 36047: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getArrayOpcodeTemplates = function () {
        return "\n                        // Array Operations\n                        case opMap[90]: { // NEW_ARRAY\n                            stack.push([]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[91]: { // ARRAY_PUSH\n                            let value = stack.pop();\n                            let array = stack[stack.length - 1]; // Peek at array (don't pop)\n                            array.push(value);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[93]: { // SPREAD\n                            // Spread operator: marks an array/iterable to be spread in function call\n                            // Stack before: [iterable]\n                            // Stack after: [{ __spread__: true, value: iterable }]\n                            // The CALL/CALL_METHOD opcodes will detect this marker and spread the array\n                            let iterable = stack.pop();\n                            stack.push({ __spread__: true, value: iterable });\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[94]: { // ARRAY_SPREAD_PUSH\n                            // Array spread: pushes all elements from iterable into array\n                            // Stack before: [array, iterable]\n                            // Stack after: [array] (with elements from iterable pushed)\n                            let spreadIterable = stack.pop();\n                            let targetArray = stack[stack.length - 1]; // Peek at array (don't pop)\n                            // Use Array.prototype.push.apply for efficiency\n                            if (Array.isArray(spreadIterable)) {\n                                Array.prototype.push.apply(targetArray, spreadIterable);\n                            } else {\n                                // Handle other iterables (strings, sets, etc.)\n                                for (let spreadItem of spreadIterable) {\n                                    targetArray.push(spreadItem);\n                                }\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        // Type Operations\n                        case opMap[110]: { // TYPEOF\n                            stack.push(typeof stack.pop());\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[111]: { // INSTANCEOF\n                            let ctor = stack.pop();\n                            let obj = stack.pop();\n                            stack.push(obj instanceof ctor);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[112]: { // TYPEOF_GLOBAL\n                            // typeof on global variable - doesn't throw for undeclared\n                            let globalName112 = constants[arg];\n                            let globalObj112 = (typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : global));\n                            stack.push(typeof globalObj112[globalName112]);\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 36656: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), d = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), p = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, u = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && l(t, e, r[n]);
        return d(t, e), t
      }), f = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, m = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BlockStatementControlFlowTransformer = void 0;
      const g = r(45337), h = r(31391), y = u(r(31659)), S = r(46300), N = r(26906), b = r(76393), _ = r(31142),
        v = r(62059), I = r(75716), O = r(13245), C = r(27391), E = r(33056);
      let T = n = class extends O.AbstractNodeTransformer {
        constructor(e, t, r, o) {
          super(r, o), this.controlFlowCustomNodeFactory = e, this.arrayUtils = t
        }

        static isProhibitedStatementNode(e) {
          const t = C.NodeGuards.isBreakStatementNode(e) || C.NodeGuards.isContinueStatementNode(e),
            r = C.NodeGuards.isVariableDeclarationNode(e) && ("const" === e.kind || "let" === e.kind),
            o = C.NodeGuards.isClassDeclarationNode(e);
          return C.NodeGuards.isFunctionDeclarationNode(e) || t || r || o
        }

        static canTransformBlockStatementNode(e) {
          let t = !0;
          return y.traverse(e, {
            enter: e => {
              if (C.NodeGuards.isWhileStatementNode(e)) return y.VisitorOption.Skip;
              n.isProhibitedStatementNode(e) && (t = !1)
            }
          }), e.body.length <= 4 && (t = !1), t
        }

        getVisitor(e) {
          return this.options.controlFlowFlattening && e === I.NodeTransformationStage.ControlFlowFlattening ? {
            leave: (e, t) => {
              if (t && C.NodeGuards.isBlockStatementNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold || !n.canTransformBlockStatementNode(e)) return e;
          const r = e.body, o = this.arrayUtils.createWithRange(r.length), i = this.arrayUtils.shuffle(o),
            a = o.map(e => i.indexOf(e)),
            s = this.controlFlowCustomNodeFactory(v.ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);
          s.initialize(r, i, a);
          const c = s.getNode()[0];
          return E.NodeUtils.parentizeNode(c, t), c
        }
      };
      t.BlockStatementControlFlowTransformer = T, t.BlockStatementControlFlowTransformer = T = n = p([(0, g.injectable)(), m(0, (0, g.inject)(h.ServiceIdentifiers.Factory__IControlFlowCustomNode)), m(1, (0, g.inject)(h.ServiceIdentifiers.IArrayUtils)), m(2, (0, g.inject)(h.ServiceIdentifiers.IRandomGenerator)), m(3, (0, g.inject)(h.ServiceIdentifiers.IOptions)), f("design:paramtypes", ["function" == typeof (i = void 0 !== S.TControlFlowCustomNodeFactory && S.TControlFlowCustomNodeFactory) ? i : Object, "function" == typeof (a = void 0 !== N.IArrayUtils && N.IArrayUtils) ? a : Object, "function" == typeof (s = void 0 !== _.IRandomGenerator && _.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== b.IOptions && b.IOptions) ? c : Object])], T)
    }, 36869: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.numbersString = void 0, t.numbersString = "0123456789"
    }, 37526: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 37782: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VisitorDirection = void 0, function (e) {
        e.Enter = "enter", e.Leave = "leave"
      }(r || (t.VisitorDirection = r = {}))
    }, 38606: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.base64alphabetSwapped = void 0;
      const o = r(6088), n = r(55194), i = r(36869);
      t.base64alphabetSwapped = `${n.alphabetString}${o.alphabetStringUppercase}${i.numbersString}+/=`
    }, 38914: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 39032: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 39056: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NumberLiteralTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(92486), f = r(75716), m = r(13245),
        g = r(93571), h = r(27391), y = r(24660);
      let S = class extends m.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [u.NodeTransformer.NumberToNumericalExpressionTransformer], this.numberLiteralCache = new Map
        }

        getVisitor(e) {
          return e === f.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && h.NodeGuards.isLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if ("number" != typeof e.value && "bigint" != typeof e.value) return e;
          const r = e.value;
          let o;
          return this.numberLiteralCache.has(r) ? o = this.numberLiteralCache.get(r) : (o = y.NumberUtils.isCeil(r) ? y.NumberUtils.toHex(r) : String(r), this.numberLiteralCache.set(r, o)), g.NodeFactory.literalNode(r, o)
        }
      };
      t.NumberLiteralTransformer = S, t.NumberLiteralTransformer = S = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], S)
    }, 39079: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.Utils = void 0;

      class r {
        static buildVersionMessage(e, t) {
          return e && t ? `${e}_${new Date(parseInt(t, 10)).toISOString()}` : "unknown"
        }

        static extractDomainFrom(e) {
          let t;
          return t = e.includes("://") || 0 === e.indexOf("//") ? e.split("/")[2] : e.split("/")[0], t = t.split(":")[0], t
        }

        static getIdentifiersPrefixForMultipleSources(e, t) {
          return `${e || r.baseMultipleSourcesIdentifiersPrefix}${t}`
        }

        static makeEnum(e) {
          return Object.freeze({ ...e })
        }
      }

      t.Utils = r, r.baseMultipleSourcesIdentifiersPrefix = "a", r.hexadecimalPrefix = "0x"
    }, 39137: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.EvalCallExpressionTransformer = void 0;
      const l = r(45337), d = r(31391), p = r(76393), u = r(31142), f = r(92486), m = r(75716), g = r(13245),
        h = r(93571), y = r(27391), S = r(4592), N = r(33056), b = r(49804);
      let _ = o = class extends g.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [f.NodeTransformer.EscapeSequenceTransformer, f.NodeTransformer.ParentificationTransformer, f.NodeTransformer.VariablePreserveTransformer]
        }

        static extractEvalStringFromCallExpressionArgument(e) {
          return y.NodeGuards.isLiteralNode(e) ? o.extractEvalStringFromLiteralNode(e) : y.NodeGuards.isTemplateLiteralNode(e) ? o.extractEvalStringFromTemplateLiteralNode(e) : null
        }

        static extractEvalStringFromLiteralNode(e) {
          return "string" == typeof e.value ? e.value : null
        }

        static extractEvalStringFromTemplateLiteralNode(e) {
          var t;
          const r = e.quasis;
          return 1 !== r.length || e.expressions.length ? null : null !== (t = r[0].value.cooked) && void 0 !== t ? t : null
        }

        getVisitor(e) {
          switch (e) {
            case m.NodeTransformationStage.Preparing:
              return {
                enter: (e, t) => {
                  if (t) return this.transformNode(e, t)
                }
              };
            case m.NodeTransformationStage.Finalizing:
              return {
                leave: (e, t) => {
                  if (t) return this.restoreNode(e, t)
                }
              };
            default:
              return null
          }
        }

        transformNode(e, t) {
          if (!(t && y.NodeGuards.isCallExpressionNode(e) && y.NodeGuards.isIdentifierNode(e.callee) && "eval" === e.callee.name)) return e;
          const r = e.arguments[0];
          if (!r) return e;
          const n = o.extractEvalStringFromCallExpressionArgument(r);
          if (!n) return e;
          let i;
          try {
            i = N.NodeUtils.convertCodeToStructure(n)
          } catch (t) {
            return e
          }
          const a = h.NodeFactory.functionExpressionNode([], h.NodeFactory.blockStatementNode(i));
          return S.NodeMetadata.set(a, { evalHostNode: !0 }), N.NodeUtils.parentizeAst(a), N.NodeUtils.parentizeNode(a, t), a
        }

        restoreNode(e, t) {
          if (!this.isEvalRootAstHostNode(e)) return e;
          const r = e.body.body, o = N.NodeUtils.convertStructureToCode(r);
          return h.NodeFactory.callExpressionNode(h.NodeFactory.identifierNode("eval"), [h.NodeFactory.literalNode(b.StringUtils.escapeJsString(o))])
        }

        isEvalRootAstHostNode(e) {
          return S.NodeMetadata.isEvalHostNode(e)
        }
      };
      t.EvalCallExpressionTransformer = _, t.EvalCallExpressionTransformer = _ = o = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (n = void 0 !== u.IRandomGenerator && u.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== p.IOptions && p.IOptions) ? i : Object])], _)
    }, 40104: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.OptionsNormalizer = void 0;
      const i = r(45337), a = r(29775), s = r(18365), c = r(13802), l = r(98081), d = r(62270), p = r(48456),
        u = r(47876), f = r(900), m = r(44855), g = r(27404), h = r(18829), y = r(21274), S = r(12951), N = r(605),
        b = r(87906), _ = r(49016);
      let v = o = class {
        normalize(e) {
          let t = { ...e };
          for (const e of o.normalizerRules) t = e(t);
          return t
        }
      };
      t.OptionsNormalizer = v, v.normalizerRules = [a.ControlFlowFlatteningThresholdRule, s.DeadCodeInjectionRule, c.DeadCodeInjectionThresholdRule, l.DomainLockRedirectUrlRule, d.DomainLockRule, p.IdentifierNamesCacheRule, u.InputFileNameRule, f.SeedRule, m.SelfDefendingRule, g.SourceMapBaseUrlRule, h.SourceMapFileNameRule, y.SplitStringsChunkLengthRule, S.StringArrayRule, N.StringArrayCallsTransformThresholdRule, b.StringArrayEncodingRule, _.StringArrayWrappersChainedCallsRule], t.OptionsNormalizer = v = o = n([(0, i.injectable)()], v)
    }, 40275: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.generatorsModule = void 0;
      const o = r(45337), n = r(31391), i = r(76436), a = r(28057), s = r(61762), c = r(47351), l = r(9328);
      t.generatorsModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.IIdentifierNamesGenerator).to(a.DictionaryIdentifierNamesGenerator).inSingletonScope().whenTargetNamed(i.IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator), e(n.ServiceIdentifiers.IIdentifierNamesGenerator).to(s.HexadecimalIdentifierNamesGenerator).inSingletonScope().whenTargetNamed(i.IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator), e(n.ServiceIdentifiers.IIdentifierNamesGenerator).to(c.MangledIdentifierNamesGenerator).inSingletonScope().whenTargetNamed(i.IdentifierNamesGenerator.MangledIdentifierNamesGenerator), e(n.ServiceIdentifiers.IIdentifierNamesGenerator).to(l.MangledShuffledIdentifierNamesGenerator).inSingletonScope().whenTargetNamed(i.IdentifierNamesGenerator.MangledShuffledIdentifierNamesGenerator), e(n.ServiceIdentifiers.Factory__IIdentifierNamesGenerator).toFactory(function () {
          let e = null;
          return t => r => {
            if (e) return e;
            let o;
            switch (r.identifierNamesGenerator) {
              case i.IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator:
                o = t.container.getNamed(n.ServiceIdentifiers.IIdentifierNamesGenerator, i.IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator);
                break;
              case i.IdentifierNamesGenerator.MangledIdentifierNamesGenerator:
                o = t.container.getNamed(n.ServiceIdentifiers.IIdentifierNamesGenerator, i.IdentifierNamesGenerator.MangledIdentifierNamesGenerator);
                break;
              case i.IdentifierNamesGenerator.MangledShuffledIdentifierNamesGenerator:
                o = t.container.getNamed(n.ServiceIdentifiers.IIdentifierNamesGenerator, i.IdentifierNamesGenerator.MangledShuffledIdentifierNamesGenerator);
                break;
              case i.IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:
              default:
                o = t.container.getNamed(n.ServiceIdentifiers.IIdentifierNamesGenerator, i.IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator)
            }
            return e = o, o
          }
        }())
      })
    }, 40367: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringLiteralControlFlowStorageCallNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(50164),
        y = r(8053), S = r(93571), N = r(33056);
      let b = class extends y.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t) {
          this.controlFlowStorageName = e, this.controlFlowStorageKey = t
        }

        getNodeStructure() {
          const e = S.NodeFactory.expressionStatementNode(S.NodeFactory.memberExpressionNode(S.NodeFactory.identifierNode(this.controlFlowStorageName), S.NodeFactory.identifierNode(this.controlFlowStorageKey)));
          return N.NodeUtils.parentizeAst(e), [e]
        }
      };
      t.StringLiteralControlFlowStorageCallNode = b, s([(0, h.initializable)(), c("design:type", String)], b.prototype, "controlFlowStorageKey", void 0), s([(0, h.initializable)(), c("design:type", String)], b.prototype, "controlFlowStorageName", void 0), t.StringLiteralControlFlowStorageCallNode = b = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], b)
    }, 40768: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CallExpressionFunctionNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(50164),
        y = r(8053), S = r(93571), N = r(33056), b = r(27391);
      let _ = class extends y.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t) {
          this.expressionArguments = e, this.isChainExpressionParent = t
        }

        getNodeStructure() {
          const e = S.NodeFactory.identifierNode("callee"), t = [], r = [], o = this.expressionArguments.length;
          for (let e = 0; e < o; e++) {
            const n = this.expressionArguments[e], i = b.NodeGuards.isSpreadElementNode(n),
              a = S.NodeFactory.identifierNode(`param${e + 1}`);
            if (i) {
              if (t.push(S.NodeFactory.restElementNode(a)), r.push(S.NodeFactory.spreadElementNode(a)), e < o - 1) break
            } else t.push(a), r.push(a)
          }
          const n = S.NodeFactory.callExpressionNode(e, r, this.isChainExpressionParent),
            i = S.NodeFactory.expressionStatementNode(S.NodeFactory.functionExpressionNode([e, ...t], S.NodeFactory.blockStatementNode([S.NodeFactory.returnStatementNode(this.isChainExpressionParent ? S.NodeFactory.chainExpressionNode(n) : n)])));
          return N.NodeUtils.parentizeAst(i), [i]
        }
      };
      t.CallExpressionFunctionNode = _, s([(0, h.initializable)(), c("design:type", Array)], _.prototype, "expressionArguments", void 0), s([(0, h.initializable)(), c("design:type", Boolean)], _.prototype, "isChainExpressionParent", void 0), t.CallExpressionFunctionNode = _ = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], _)
    }, 41426: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SelfDefendingCodeHelperGroup = void 0;
      const p = r(45337), u = r(31391), f = r(58544), m = r(18741), g = r(76393), h = r(31142), y = r(50164),
        S = r(51875), N = r(75716), b = r(26455), _ = r(47250), v = r(75096);
      let I = class extends b.AbstractCustomCodeHelperGroup {
        constructor(e, t, r, o) {
          super(t, r, o), this.customCodeHelperFactory = e
        }

        appendOnPreparingStage(e, t) {
          var r;
          if (!this.options.selfDefending) return;
          const o = this.getRandomCallsGraphIndex(t.length),
            n = t.length ? _.NodeAppender.getOptimalBlockScope(t, o) : e,
            i = t.length ? _.NodeAppender.getOptimalBlockScope(t, o, 1) : e,
            a = null !== (r = v.NodeLexicalScopeUtils.getLexicalScope(n)) && void 0 !== r ? r : null,
            s = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext(),
            c = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext();
          this.appendCustomNodeIfExist(S.CustomCodeHelper.SelfDefending, e => {
            e.initialize(c, s), _.NodeAppender.prepend(n, e.getNode())
          }), this.appendCustomNodeIfExist(S.CustomCodeHelper.CallsControllerFunction, e => {
            e.initialize(N.NodeTransformationStage.Preparing, c), _.NodeAppender.prepend(i, e.getNode())
          })
        }

        initialize() {
          if (this.customCodeHelpers = new Map, !this.options.selfDefending) return;
          const e = this.customCodeHelperFactory(S.CustomCodeHelper.SelfDefending),
            t = this.customCodeHelperFactory(S.CustomCodeHelper.CallsControllerFunction);
          this.customCodeHelpers.set(S.CustomCodeHelper.SelfDefending, e), this.customCodeHelpers.set(S.CustomCodeHelper.CallsControllerFunction, t)
        }
      };
      t.SelfDefendingCodeHelperGroup = I, c([(0, y.initializable)(), l("design:type", "function" == typeof (s = "undefined" != typeof Map && Map) ? s : Object)], I.prototype, "customCodeHelpers", void 0), t.SelfDefendingCodeHelperGroup = I = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__ICustomCodeHelper)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TCustomCodeHelperFactory && f.TCustomCodeHelperFactory) ? o : Object, "function" == typeof (n = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== g.IOptions && g.IOptions) ? a : Object])], I)
    }, 41525: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 41818: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p, u, f = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, m = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, g = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayTransformer = void 0;
      const h = r(45337), y = r(31391), S = r(18741), N = r(62625), b = r(23303), _ = r(76393), v = r(31142),
        I = r(56012), O = r(28523), C = r(70858), E = r(52562), T = r(92486), R = r(75716), M = r(928), A = r(48344),
        F = r(13245), P = r(27391), D = r(45261), j = r(4592), x = r(33056);
      let V = o = class extends F.AbstractNodeTransformer {
        constructor(e, t, r, o, n, i, a, s, c) {
          super(e, t), this.runAfter = [T.NodeTransformer.StringArrayRotateFunctionTransformer], this.literalNodesCacheStorage = r, this.visitedLexicalScopeNodesStackStorage = o, this.stringArrayStorage = n, this.stringArrayScopeCallsWrappersDataStorage = i, this.stringArrayStorageAnalyzer = a, this.identifierNamesGenerator = s(t), this.stringArrayTransformerCustomNodeFactory = c
        }

        getVisitor(e) {
          return e === R.NodeTransformationStage.StringArray ? {
            enter: (e, t) => {
              if (P.NodeGuards.isProgramNode(e) && this.prepareNode(e), t && P.NodeGuards.isLiteralNode(e) && !j.NodeMetadata.isStringArrayCallLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        prepareNode(e) {
          this.options.stringArray && this.stringArrayStorageAnalyzer.analyze(e), this.options.stringArrayShuffle && this.stringArrayStorage.shuffleStorage(), this.options.stringArrayRotate && this.stringArrayStorage.rotateStorage()
        }

        transformNode(e, t) {
          if (!D.NodeLiteralUtils.isStringLiteralNode(e) || D.NodeLiteralUtils.isProhibitedLiteralNode(e, t)) return e;
          const r = e.value, o = this.stringArrayStorageAnalyzer.getItemDataForLiteralNode(e),
            n = this.literalNodesCacheStorage.buildKey(r, o);
          let i;
          if (this.literalNodesCacheStorage.shouldUseCachedValue(n, o)) {
            const e = this.literalNodesCacheStorage.get(n);
            i = x.NodeUtils.clone(e)
          } else i = o ? this.getStringArrayCallNode(o) : e, this.literalNodesCacheStorage.set(n, i);
          return x.NodeUtils.parentizeNode(i, t), i
        }

        getStringArrayCallNode(e) {
          const t = this.getStringArrayScopeCallsWrapperData(e), { decodeKey: r, index: o } = e,
            n = this.stringArrayTransformerCustomNodeFactory(M.StringArrayCustomNode.StringArrayCallNode);
          n.initialize(o, this.stringArrayStorage.getIndexShiftAmount(), t, r);
          const i = n.getNode()[0];
          if (!P.NodeGuards.isExpressionStatementNode(i)) throw new Error("`stringArrayCallCustomNode.getNode()[0]` should returns array with `ExpressionStatement` node");
          return i.expression
        }

        getStringArrayScopeCallsWrapperData(e) {
          return this.options.stringArrayWrappersCount ? this.getUpperStringArrayScopeCallsWrapperData(e) : this.getRootStringArrayScopeCallsWrapperData(e)
        }

        getRootStringArrayScopeCallsWrapperData(e) {
          const { encoding: t } = e;
          return { name: this.stringArrayStorage.getStorageCallsWrapperName(t), index: 0, parameterIndexesData: null }
        }

        getUpperStringArrayScopeCallsWrapperData(e) {
          var t, r, o;
          const { encoding: n } = e,
            i = null !== (t = this.visitedLexicalScopeNodesStackStorage.getLastElement()) && void 0 !== t ? t : null;
          if (!i) throw new Error("Cannot find current lexical scope body node");
          const a = null !== (o = null === (r = this.getAndUpdateStringArrayScopeCallsWrappersDataByEncoding(i, e)[n]) || void 0 === r ? void 0 : r.scopeCallsWrappersData) && void 0 !== o ? o : [];
          return this.randomGenerator.getRandomGenerator().pickone(a)
        }

        getAndUpdateStringArrayScopeCallsWrappersDataByEncoding(e, t) {
          var r, o, n;
          const { encoding: i } = t,
            a = null !== (r = this.stringArrayScopeCallsWrappersDataStorage.get(e)) && void 0 !== r ? r : {},
            s = null !== (n = null === (o = a[i]) || void 0 === o ? void 0 : o.scopeCallsWrappersData) && void 0 !== n ? n : [];
          if (s.length === this.options.stringArrayWrappersCount) return a;
          const c = P.NodeGuards.isProgramNode(e) ? this.identifierNamesGenerator.generateForGlobalScope() : this.identifierNamesGenerator.generateNext(),
            l = this.getStringArrayCallsWrapperShiftedIndex(),
            d = this.getStringArrayCallsWrapperParameterIndexesData();
          return a[i] = {
            encoding: i,
            scopeCallsWrappersData: [...s, { name: c, index: l, parameterIndexesData: d }]
          }, this.stringArrayScopeCallsWrappersDataStorage.set(e, a), a
        }

        getStringArrayCallsWrapperShiftedIndex() {
          return this.options.stringArrayWrappersType === A.StringArrayWrappersType.Function ? this.randomGenerator.getRandomInteger(o.minShiftedIndexValue, o.maxShiftedIndexValue) : 0
        }

        getStringArrayCallsWrapperParameterIndexesData() {
          if (this.options.stringArrayWrappersType !== A.StringArrayWrappersType.Function) return null;
          const e = this.options.stringArrayWrappersParametersMaxCount - 1,
            t = this.randomGenerator.getRandomInteger(0, e);
          return {
            valueIndexParameterIndex: t,
            decodeKeyParameterIndex: this.randomGenerator.getRandomIntegerExcluding(0, e, [t])
          }
        }
      };
      t.StringArrayTransformer = V, V.minShiftedIndexValue = -1e3, V.maxShiftedIndexValue = 1e3, t.StringArrayTransformer = V = o = f([(0, h.injectable)(), g(0, (0, h.inject)(y.ServiceIdentifiers.IRandomGenerator)), g(1, (0, h.inject)(y.ServiceIdentifiers.IOptions)), g(2, (0, h.inject)(y.ServiceIdentifiers.ILiteralNodesCacheStorage)), g(3, (0, h.inject)(y.ServiceIdentifiers.IVisitedLexicalScopeNodesStackStorage)), g(4, (0, h.inject)(y.ServiceIdentifiers.IStringArrayStorage)), g(5, (0, h.inject)(y.ServiceIdentifiers.IStringArrayScopeCallsWrappersDataStorage)), g(6, (0, h.inject)(y.ServiceIdentifiers.IStringArrayStorageAnalyzer)), g(7, (0, h.inject)(y.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), g(8, (0, h.inject)(y.ServiceIdentifiers.Factory__IStringArrayCustomNode)), m("design:paramtypes", ["function" == typeof (n = void 0 !== v.IRandomGenerator && v.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== _.IOptions && _.IOptions) ? i : Object, "function" == typeof (a = void 0 !== b.ILiteralNodesCacheStorage && b.ILiteralNodesCacheStorage) ? a : Object, "function" == typeof (s = void 0 !== E.IVisitedLexicalScopeNodesStackStorage && E.IVisitedLexicalScopeNodesStackStorage) ? s : Object, "function" == typeof (c = void 0 !== O.IStringArrayStorage && O.IStringArrayStorage) ? c : Object, "function" == typeof (l = void 0 !== I.IStringArrayScopeCallsWrappersDataStorage && I.IStringArrayScopeCallsWrappersDataStorage) ? l : Object, "function" == typeof (d = void 0 !== C.IStringArrayStorageAnalyzer && C.IStringArrayStorageAnalyzer) ? d : Object, "function" == typeof (p = void 0 !== S.TIdentifierNamesGeneratorFactory && S.TIdentifierNamesGeneratorFactory) ? p : Object, "function" == typeof (u = void 0 !== N.TStringArrayCustomNodeFactory && N.TStringArrayCustomNodeFactory) ? u : Object])], V)
    }, 42610: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ExpressionWithOperatorControlFlowReplacer = void 0;
      const d = r(45337), p = r(31391), u = r(46300), f = r(18741), m = r(76393), g = r(31142), h = r(62059),
        y = r(47074), S = r(27391);
      let N = class extends y.AbstractControlFlowReplacer {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        getControlFlowStorageCallNode(e, t, r, o) {
          const n = this.controlFlowCustomNodeFactory(h.ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);
          n.initialize(e, t, r, o);
          const i = n.getNode()[0];
          if (!i || !S.NodeGuards.isExpressionStatementNode(i)) throw new Error("`controlFlowStorageCallCustomNode.getNode()[0]` should returns array with `ExpressionStatement` node");
          return i.expression
        }
      };
      t.ExpressionWithOperatorControlFlowReplacer = N, t.ExpressionWithOperatorControlFlowReplacer = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IControlFlowCustomNode)), l(1, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TControlFlowCustomNodeFactory && u.TControlFlowCustomNodeFactory) ? o : Object, "function" == typeof (n = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 42748: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringLiteralControlFlowReplacer = void 0;
      const p = r(45337), u = r(31391), f = r(46300), m = r(18741), g = r(76393), h = r(31142), y = r(62059),
        S = r(47074), N = r(27391), b = r(45261);
      let _ = o = class extends S.AbstractControlFlowReplacer {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        replace(e, t, r) {
          if (N.NodeGuards.isPropertyNode(t) && t.key === e) return e;
          if (!b.NodeLiteralUtils.isStringLiteralNode(e) || e.value.length < 3) return e;
          const n = e.value, i = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.LiteralNode);
          i.initialize(e);
          const a = this.insertCustomNodeToControlFlowStorage(i, r, n, o.usingExistingIdentifierChance);
          return this.getControlFlowStorageCallNode(r.getStorageId(), a)
        }

        getControlFlowStorageCallNode(e, t) {
          const r = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);
          r.initialize(e, t);
          const o = r.getNode()[0];
          if (!o || !N.NodeGuards.isExpressionStatementNode(o)) throw new Error("`controlFlowStorageCallCustomNode.getNode()[0]` should returns array with `ExpressionStatement` node");
          return o.expression
        }
      };
      t.StringLiteralControlFlowReplacer = _, _.usingExistingIdentifierChance = 1, t.StringLiteralControlFlowReplacer = _ = o = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IControlFlowCustomNode)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (n = void 0 !== f.TControlFlowCustomNodeFactory && f.TControlFlowCustomNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? i : Object, "function" == typeof (a = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== g.IOptions && g.IOptions) ? s : Object])], _)
    }, 42782: e => {
      e.exports = require("string-template")
    }, 43243: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeStatementUtils = void 0;
      const o = r(27391);

      class n {
        static getParentNodeWithStatements(e) {
          return n.getParentNodesWithStatementsRecursive(e, 1)[0]
        }

        static getParentNodesWithStatements(e) {
          return n.getParentNodesWithStatementsRecursive(e)
        }

        static getNextSiblingStatement(e) {
          return n.getSiblingStatementByOffset(e, 1)
        }

        static getPreviousSiblingStatement(e) {
          return n.getSiblingStatementByOffset(e, -1)
        }

        static getRootStatementOfNode(e) {
          if (o.NodeGuards.isProgramNode(e)) throw new Error("Unable to find root statement for `Program` node");
          const t = e.parentNode;
          if (!t) throw new ReferenceError("`parentNode` property of given node is `undefined`");
          return o.NodeGuards.isNodeWithStatements(t) ? e : n.getRootStatementOfNode(t)
        }

        static getScopeOfNode(e) {
          const t = e.parentNode;
          if (!t) throw new ReferenceError("`parentNode` property of given node is `undefined`");
          return o.NodeGuards.isNodeWithStatements(t) ? t : n.getScopeOfNode(t)
        }

        static getParentNodesWithStatementsRecursive(e, t = 1 / 0, r = [], i = 0) {
          if (r.length >= t) return r;
          const a = e.parentNode;
          if (!a) throw new ReferenceError("`parentNode` property of given node is `undefined`");
          return (o.NodeGuards.isProgramNode(e) || o.NodeGuards.isNodeWithLexicalScopeStatements(e, a) && i > 0) && r.push(e), e !== a ? n.getParentNodesWithStatementsRecursive(a, t, r, ++i) : r
        }

        static getSiblingStatementByOffset(e, t) {
          const r = n.getScopeOfNode(e), i = o.NodeGuards.isSwitchCaseNode(r) ? r.consequent : r.body, a = i.indexOf(e);
          return i[a + t] || null
        }
      }

      t.NodeStatementUtils = n
    }, 43296: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SourceCode = void 0, t.SourceCode = class {
        constructor(e, t) {
          this.sourceCode = e, this.sourceMap = t
        }

        getSourceCode() {
          return this.sourceCode
        }

        getSourceMap() {
          return this.sourceMap
        }

        toString() {
          return this.sourceCode
        }
      }
    }, 43382: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractStringArrayCallNode = void 0;
      const m = r(45337), g = r(31391), h = r(18741), y = r(46293), S = r(39032), N = r(76393), b = r(31142),
        _ = r(28523), v = r(51110), I = r(6062), O = r(8053), C = r(93571), E = r(4592), T = r(33056), R = r(26906);
      let M = o = class extends O.AbstractCustomNode {
        constructor(e, t, r, o, n, i, a) {
          super(e, r, i, a), this.stringArrayIndexNodeFactory = t, this.stringArrayStorage = o, this.arrayUtils = n
        }

        getStringArrayIndexNode(e) {
          var t;
          const r = e >= 0, n = Math.abs(e),
            i = this.randomGenerator.getRandomGenerator().pickone(this.options.stringArrayIndexesType),
            a = null !== (t = o.stringArrayIndexNodesMap.get(i)) && void 0 !== t ? t : null;
          if (!a) throw new Error("Invalid string array index node name");
          const s = this.stringArrayIndexNodeFactory(a).getNode(n);
          E.NodeMetadata.set(s, { stringArrayCallLiteralNode: !0 });
          const c = r ? s : C.NodeFactory.unaryExpressionNode("-", s);
          return T.NodeUtils.parentizeAst(c), c
        }

        getRc4KeyLiteralNode(e) {
          const t = C.NodeFactory.literalNode(e);
          return E.NodeMetadata.set(t, { stringArrayCallLiteralNode: !0 }), t
        }
      };
      t.AbstractStringArrayCallNode = M, M.stringArrayRootCallsWrapperParametersCount = 2, M.stringArrayIndexNodesMap = new Map([[v.StringArrayIndexesType.HexadecimalNumber, I.StringArrayIndexNode.StringArrayHexadecimalNumberIndexNode], [v.StringArrayIndexesType.HexadecimalNumericString, I.StringArrayIndexNode.StringArrayHexadecimalNumericStringIndexNode]]), t.AbstractStringArrayCallNode = M = o = p([(0, m.injectable)(), f(0, (0, m.inject)(g.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), f(1, (0, m.inject)(g.ServiceIdentifiers.Factory__IStringArrayIndexNode)), f(2, (0, m.inject)(g.ServiceIdentifiers.ICustomCodeHelperFormatter)), f(3, (0, m.inject)(g.ServiceIdentifiers.IStringArrayStorage)), f(4, (0, m.inject)(g.ServiceIdentifiers.IArrayUtils)), f(5, (0, m.inject)(g.ServiceIdentifiers.IRandomGenerator)), f(6, (0, m.inject)(g.ServiceIdentifiers.IOptions)), u("design:paramtypes", ["function" == typeof (n = void 0 !== h.TIdentifierNamesGeneratorFactory && h.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== y.TStringArrayIndexNodeFactory && y.TStringArrayIndexNodeFactory) ? i : Object, "function" == typeof (a = void 0 !== S.ICustomCodeHelperFormatter && S.ICustomCodeHelperFormatter) ? a : Object, "function" == typeof (s = void 0 !== _.IStringArrayStorage && _.IStringArrayStorage) ? s : Object, "function" == typeof (c = void 0 !== R.IArrayUtils && R.IArrayUtils) ? c : Object, "function" == typeof (l = void 0 !== b.IRandomGenerator && b.IRandomGenerator) ? l : Object, "function" == typeof (d = void 0 !== N.IOptions && N.IOptions) ? d : Object])], M)
    }, 43636: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMVariableResolver = void 0;
      const n = r(45337), i = r(25560), a = r(59805);
      let s = class {
        resolve(e, t, r = !1) {
          var o;
          let { localIndex: n, scopedKey: a, depth: s } = this.findBlockScopedVariable(e, t);
          if (void 0 !== n && void 0 !== s && s > 0) {
            if (this.checkTDZShadowsLocal(e, s, t)) return { location: i.VariableLocation.TDZ, index: 0, name: e };
            const { isEnv: r, isPerIterationVar: o } = this.checkBlockScopedEnvStatus(e, a, t);
            if (r) {
              const r = this.checkShadowsInSameEnv(e, s, a, t), n = !o && (s > 1 || r) && a ? a : e,
                c = t.constantPool.add(n);
              return { location: i.VariableLocation.Environment, index: c, name: e }
            }
            return { location: i.VariableLocation.Local, index: n, scopedKey: a, name: e }
          }
          const c = t.parameters.get(e);
          if (void 0 !== c && t.parametersInTDZ.has(e)) return { location: i.VariableLocation.TDZ, index: c, name: e };
          if (void 0 !== c && !t.envVars.has(e)) return { location: i.VariableLocation.Parameter, index: c, name: e };
          if (void 0 === n && (n = t.localVariables.get(e)), void 0 !== n) {
            if (!this.shouldSkipLocalForEnv(e, a, t)) return this.checkTDZShadowsLocal(e, s, t) || this.checkPlainLocalShadowedByTDZ(e, s, t) ? {
              location: i.VariableLocation.TDZ,
              index: 0,
              name: e
            } : { location: i.VariableLocation.Local, index: n, name: e };
            n = void 0
          }
          if (this.checkUndeclaredInTDZ(e, t)) return { location: i.VariableLocation.TDZ, index: 0, name: e };
          if (this.isEnvVariable(e, t)) {
            const r = this.resolveEnvKeyFromParentContexts(e, t), o = t.constantPool.add(r);
            return { location: i.VariableLocation.Environment, index: o, name: e }
          }
          const l = this.isTopLevelVariable(e, t);
          if (l && !t.parentContext) {
            const r = t.constantPool.add(e);
            return { location: i.VariableLocation.Global, index: r, name: e }
          }
          const d = this.isVariableInParentScope(e, t);
          if (d.found && d.inTDZ) {
            const r = t.constantPool.add(e);
            return { location: i.VariableLocation.TDZ, index: r, name: e }
          }
          if (d.found && d.context) {
            const n = d.context, a = n.parameters.has(e) && !n.parametersInTDZ.has(e);
            if ((null !== (o = r || d.isForwardRef) && void 0 !== o ? o : n.envVars.has(e) || n.capturedVars.has(e)) && (n.capturedVars.add(e), a || n.envVars.add(e)), l) {
              const r = t.constantPool.add(e);
              return { location: i.VariableLocation.Global, index: r, name: e }
            }
            const s = t.constantPool.add(e);
            return { location: i.VariableLocation.Environment, index: s, name: e }
          }
          const p = t.constantPool.add(e);
          return { location: i.VariableLocation.Global, index: p, name: e }
        }

        isEnvVariable(e, t) {
          let r = t;
          for (; r;) {
            if (r.envVars.has(e)) return !0;
            r = r.parentContext
          }
          return !1
        }

        findBlockScopedVariable(e, t) {
          for (let r = t.blockScopeDepth; r >= 0; r--) {
            const o = (0, a.getScopedVariableName)(e, r);
            if (t.activeBlockScopes && !t.activeBlockScopes.has(o)) continue;
            const n = t.localVariables.get(o);
            if (void 0 !== n) return { localIndex: n, scopedKey: o, depth: r }
          }
          return {}
        }

        checkBlockScopedEnvStatus(e, t, r) {
          var o, n, i, a;
          const s = void 0 !== t && r.envVars.has(t), c = r.envVars.has(e),
            l = null !== (n = null === (o = r.perIterationLoopVars) || void 0 === o ? void 0 : o.has(e)) && void 0 !== n && n,
            d = void 0 !== t && null !== (a = null === (i = r.perIterationVarScopedKeys) || void 0 === i ? void 0 : i.has(t)) && void 0 !== a && a,
            p = l && void 0 !== t && !d;
          return { isEnv: s || c && !p || l && !p, isPerIterationVar: l && !p }
        }

        checkShadowsInSameEnv(e, t, r, o) {
          if (1 !== t || 1 !== o.envDepth || !r) return !1;
          const n = (0, a.getScopedVariableName)(e, 0);
          return (o.variableScopes.has(n) || o.variableScopes.has(e)) && o.envVars.has(e)
        }

        shouldSkipLocalForEnv(e, t, r) {
          var o, n, i, a;
          return !r.hoistedFunctionDeclarations.has(e) && (!(null !== (n = null === (o = r.destructuredParameterNames) || void 0 === o ? void 0 : o.has(e)) && void 0 !== n && n || void 0 !== t && null !== (a = null === (i = r.destructuredParameterNames) || void 0 === i ? void 0 : i.has(t)) && void 0 !== a && a) && e !== r.functionName && r.envVars.has(e))
        }

        checkTDZShadowsLocal(e, t, r) {
          return !(void 0 === t || t >= r.blockScopeDepth || !r.localVariablesInTDZ.has(e) || this.isPerIterationBypassingTDZ(e, r))
        }

        checkPlainLocalShadowedByTDZ(e, t, r) {
          return void 0 === t && !!r.localVariablesInTDZ.has(e) && !this.isPerIterationBypassingTDZ(e, r)
        }

        isPerIterationBypassingTDZ(e, t) {
          var r, o;
          return t.envVars.has(e) && null !== (o = null === (r = t.perIterationLoopVars) || void 0 === r ? void 0 : r.has(e)) && void 0 !== o && o
        }

        checkUndeclaredInTDZ(e, t) {
          return !!t.localVariablesInTDZ.has(e) && !this.isPerIterationBypassingTDZ(e, t)
        }

        resolveEnvKeyFromParentContexts(e, t) {
          var r, o;
          const n = e;
          let i = t.parentContext;
          for (; i;) {
            if (i.localVariables.has(e)) return e;
            const t = Math.max(i.blockScopeDepth, 10);
            let n = 0;
            for (let r = t; r >= 1; r--) i.localVariables.has((0, a.getScopedVariableName)(e, r)) && n++;
            const s = n > 1;
            for (let n = t; n >= 2; n--) {
              const t = (0, a.getScopedVariableName)(e, n);
              if ((!(s && n > i.blockScopeDepth && i.activeBlockScopes) || i.activeBlockScopes.has(t)) && i.localVariables.has(t)) return null !== (o = null === (r = i.perIterationLoopVars) || void 0 === r ? void 0 : r.has(e)) && void 0 !== o && o || n <= 1 ? e : t
            }
            i = i.parentContext
          }
          return n
        }

        isTopLevelVariable(e, t) {
          var r;
          let o = t;
          for (; o;) {
            if (null === (r = o.topLevelVariables) || void 0 === r ? void 0 : r.has(e)) return !0;
            o = o.parentContext
          }
          return !1
        }

        isVariableInParentScope(e, t) {
          var r;
          let o = t.parentContext;
          for (; o;) {
            if (o.functionName && e === o.functionName) return { found: !0, context: o, isForwardRef: !1 };
            if (o.parameters.has(e)) return o.parametersInTDZ.has(e) ? {
              found: !0,
              context: o,
              isForwardRef: !1,
              inTDZ: !0
            } : { found: !0, context: o, isForwardRef: !1 };
            if (o.localVariables.has(e)) return { found: !0, context: o, isForwardRef: !1 };
            for (let t = o.blockScopeDepth; t >= 0; t--) {
              const r = (0, a.getScopedVariableName)(e, t);
              if (o.localVariables.has(r)) return { found: !0, context: o, isForwardRef: !1 }
            }
            if ((null === (r = o.declaredVariables) || void 0 === r ? void 0 : r.has(e)) && !o.parametersInTDZ.has(e)) return {
              found: !0,
              context: o,
              isForwardRef: !0
            };
            o = o.parentContext
          }
          return { found: !1 }
        }
      };
      t.VMVariableResolver = s, t.VMVariableResolver = s = o([(0, n.injectable)()], s)
    }, 43830: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayScopeCallsWrapperTransformer = void 0;
      const u = r(45337), f = r(31391), m = r(62625), g = r(76393), h = r(31142), y = r(56012), S = r(28523),
        N = r(52562), b = r(92486), _ = r(75716), v = r(928), I = r(48344), O = r(13245), C = r(47250), E = r(27391);
      let T = class extends O.AbstractNodeTransformer {
        constructor(e, t, r, o, n, i) {
          super(e, t), this.runAfter = [b.NodeTransformer.StringArrayRotateFunctionTransformer], this.visitedLexicalScopeNodesStackStorage = r, this.stringArrayStorage = o, this.stringArrayScopeCallsWrappersDataStorage = n, this.stringArrayTransformerCustomNodeFactory = i
        }

        getVisitor(e) {
          return this.options.stringArrayWrappersCount && e === _.NodeTransformationStage.StringArray ? {
            enter: (e, t) => {
              t && E.NodeGuards.isNodeWithLexicalScopeStatements(e, t) && this.onLexicalScopeNodeEnter(e)
            }, leave: (e, t) => {
              if (t && E.NodeGuards.isNodeWithLexicalScopeStatements(e, t)) return this.onLexicalScopeNodeLeave(), this.transformNode(e)
            }
          } : null
        }

        transformNode(e) {
          var t;
          const r = null !== (t = this.stringArrayScopeCallsWrappersDataStorage.get(e)) && void 0 !== t ? t : null;
          if (!r) return e;
          const o = Object.values(r);
          for (const t of o) {
            if (!t) continue;
            const { scopeCallsWrappersData: r } = t;
            for (let o = r.length - 1; o >= 0; o--) {
              const n = r[o], i = this.getUpperStringArrayCallsWrapperData(t);
              this.getAndAppendStringArrayScopeCallsWrapperNode(e, n, i)
            }
          }
          return e
        }

        getRootStringArrayCallsWrapperData(e) {
          const { encoding: t } = e;
          return { name: this.stringArrayStorage.getStorageCallsWrapperName(t), index: 0, parameterIndexesData: null }
        }

        getUpperStringArrayCallsWrapperData(e) {
          var t, r, o, n;
          const { encoding: i } = e, a = this.getRootStringArrayCallsWrapperData(e);
          if (!this.options.stringArrayWrappersChainedCalls) return a;
          const s = null !== (t = this.visitedLexicalScopeNodesStackStorage.getLastElement()) && void 0 !== t ? t : null;
          if (!s) return a;
          const c = null !== (r = this.stringArrayScopeCallsWrappersDataStorage.get(s)) && void 0 !== r ? r : null,
            l = null !== (n = null === (o = null == c ? void 0 : c[i]) || void 0 === o ? void 0 : o.scopeCallsWrappersData) && void 0 !== n ? n : null;
          return (null == l ? void 0 : l.length) ? this.randomGenerator.getRandomGenerator().pickone(l) : a
        }

        getAndAppendStringArrayScopeCallsWrapperNode(e, t, r) {
          let o;
          switch (this.options.stringArrayWrappersType) {
            case I.StringArrayWrappersType.Function: {
              const n = this.randomGenerator.getRandomInteger(0, e.body.length - 1);
              o = this.getStringArrayScopeCallsWrapperFunctionNode(t, r), C.NodeAppender.insertAtIndex(e, o, n);
              break
            }
            case I.StringArrayWrappersType.Variable:
            default:
              o = this.getStringArrayScopeCallsWrapperVariableNode(t, r), C.NodeAppender.prepend(e, o)
          }
        }

        getStringArrayScopeCallsWrapperVariableNode(e, t) {
          const r = this.stringArrayTransformerCustomNodeFactory(v.StringArrayCustomNode.StringArrayScopeCallsWrapperVariableNode);
          return r.initialize(e, t), r.getNode()
        }

        getStringArrayScopeCallsWrapperFunctionNode(e, t) {
          const r = this.stringArrayTransformerCustomNodeFactory(v.StringArrayCustomNode.StringArrayScopeCallsWrapperFunctionNode);
          return r.initialize(e, t), r.getNode()
        }

        onLexicalScopeNodeEnter(e) {
          this.visitedLexicalScopeNodesStackStorage.push(e)
        }

        onLexicalScopeNodeLeave() {
          this.visitedLexicalScopeNodesStackStorage.pop()
        }
      };
      t.StringArrayScopeCallsWrapperTransformer = T, t.StringArrayScopeCallsWrapperTransformer = T = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.IOptions)), p(2, (0, u.inject)(f.ServiceIdentifiers.IVisitedLexicalScopeNodesStackStorage)), p(3, (0, u.inject)(f.ServiceIdentifiers.IStringArrayStorage)), p(4, (0, u.inject)(f.ServiceIdentifiers.IStringArrayScopeCallsWrappersDataStorage)), p(5, (0, u.inject)(f.ServiceIdentifiers.Factory__IStringArrayCustomNode)), d("design:paramtypes", ["function" == typeof (o = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== g.IOptions && g.IOptions) ? n : Object, "function" == typeof (i = void 0 !== N.IVisitedLexicalScopeNodesStackStorage && N.IVisitedLexicalScopeNodesStackStorage) ? i : Object, "function" == typeof (a = void 0 !== S.IStringArrayStorage && S.IStringArrayStorage) ? a : Object, "function" == typeof (s = void 0 !== y.IStringArrayScopeCallsWrappersDataStorage && y.IStringArrayScopeCallsWrappersDataStorage) ? s : Object, "function" == typeof (c = void 0 !== m.TStringArrayCustomNodeFactory && m.TStringArrayCustomNodeFactory) ? c : Object])], T)
    }, 43853: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.HIGH_OBFUSCATION_PRESET = void 0;
      const o = r(82038), n = r(20965), i = r(84640);
      t.HIGH_OBFUSCATION_PRESET = Object.freeze({
        ...i.MEDIUM_OBFUSCATION_PRESET,
        controlFlowFlatteningThreshold: 1,
        deadCodeInjectionThreshold: 1,
        debugProtection: !0,
        debugProtectionInterval: 4e3,
        optionsPreset: o.OptionsPreset.HighObfuscation,
        splitStringsChunkLength: 5,
        stringArrayCallsTransformThreshold: 1,
        stringArrayEncoding: [n.StringArrayEncoding.Rc4],
        stringArrayWrappersCount: 5,
        stringArrayWrappersParametersMaxCount: 5,
        stringArrayThreshold: 1
      })
    }, 43908: e => {
      e.exports = require("eslint-scope")
    }, 44166: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MetadataTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(92486), f = r(75716), m = r(13245),
        g = r(27391), h = r(4592);
      let y = class extends m.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [u.NodeTransformer.ParentificationTransformer, u.NodeTransformer.VariablePreserveTransformer]
        }

        getVisitor(e) {
          return e === f.NodeTransformationStage.Preparing ? { enter: (e, t) => this.transformNode(e, t) } : null
        }

        transformNode(e, t) {
          return h.NodeMetadata.set(e, { ignoredNode: !1 }), g.NodeGuards.isLiteralNode(e) && h.NodeMetadata.set(e, { stringArrayCallLiteralNode: !1 }), e
        }
      };
      t.MetadataTransformer = y, t.MetadataTransformer = y = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], y)
    }, 44319: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getIndirectDispatchTemplate = function (e = !1) {
        return `\n                            // Indirect dispatch via handler array with randomized indices\n                            // _h = handler array, _hm = opcode-to-handler mapping\n                            // Handler indices are shuffled per-build for additional obfuscation\n                            if (typeof _h === 'undefined') {\n                                var _vmDone = false;\n                                var _vmReturnValue;\n                                var _h = [];  // Handler array (sparse, indexed by shuffled values)\n                                var _hm = {}; // Opcode to handler index mapping\n\n                                // Generate shuffled handler indices at runtime\n                                // This ensures each execution has different handler layout\n                                var _opcodes = [];\n                                for (var _k in opMap) { if (opMap.hasOwnProperty(_k)) _opcodes.push(parseInt(_k)); }\n                                var _shuffled = _opcodes.slice();\n                                for (var _i = _shuffled.length - 1; _i > 0; _i--) {\n                                    var _j = Math.floor(Math.random() * (_i + 1));\n                                    var _t = _shuffled[_i]; _shuffled[_i] = _shuffled[_j]; _shuffled[_j] = _t;\n                                }\n                                // Build mapping: opcode -> shuffled handler index\n                                for (var _i = 0; _i < _opcodes.length; _i++) {\n                                    _hm[opMap[_opcodes[_i]]] = _shuffled[_i];\n                                }\n\n                                // Single dispatch function that uses switch internally\n                                // The indirection is: op -> _hm[op] -> _h[_hm[op]]\n                                var _dispatch = function(_op, _arg) {\n                                    var arg = _arg;\n                                    switch(_op) {\n                                        ${(0, o.getAllOpcodeCasesForIndirectDispatch)(e)}\n                                    }\n                                };\n\n                                // Populate handler array at shuffled indices\n                                // Each "handler" is a closure that calls dispatch with the original opcode\n                                for (var _k in opMap) {\n                                    if (opMap.hasOwnProperty(_k)) {\n                                        (function(physicalOp) {\n                                            _h[_hm[physicalOp]] = function(_arg) { _dispatch(physicalOp, _arg); };\n                                        })(opMap[_k]);\n                                    }\n                                }\n                            }\n                            // Dispatch through handler array with mapped index\n                            _h[_hm[op]](arg);\n                            if (_vmDone) { _vmDone = false; return _vmReturnValue; }\n    `
      };
      const o = r(59641)
    }, 44375: function (e, t, r) {
      var o, n, i, a, s = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), c = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && s(t, e, r[n]);
        return c(t, e), t
      }), p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SplitStringTransformer = void 0;
      const f = r(45337), m = r(31391), g = d(r(31659)), h = d(r(73921)), y = r(76393), S = r(31142), N = r(92486),
        b = r(75716), _ = r(13245), v = r(93571), I = r(27391), O = r(45261), C = r(33056);
      let E = n = class extends _.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [N.NodeTransformer.ObjectExpressionKeysTransformer, N.NodeTransformer.TemplateLiteralTransformer]
        }

        static chunkString(e, t, r) {
          const o = Math.ceil(t / r), n = [];
          let i = 0;
          for (let t = 0; t < o; ++t, i += r) n[t] = h.substr(e, i, r);
          return n
        }

        getVisitor(e) {
          return this.options.splitStrings && e === b.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && I.NodeGuards.isLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (O.NodeLiteralUtils.isProhibitedLiteralNode(e, t)) return e;
          const r = this.transformLiteralNodeByChunkLength(e, n.firstPassChunkLength), o = g.replace(r, {
            enter: (e, t) => {
              if (I.NodeGuards.isLiteralNode(e)) return this.transformLiteralNodeByChunkLength(e, this.options.splitStringsChunkLength)
            }
          });
          return C.NodeUtils.parentizeNode(o, t), C.NodeUtils.parentizeAst(o), o
        }

        transformLiteralNodeByChunkLength(e, t) {
          if (!O.NodeLiteralUtils.isStringLiteralNode(e)) return e;
          const r = h.length(e.value);
          if (t >= r) return e;
          const o = n.chunkString(e.value, r, t);
          return this.transformStringChunksToBinaryExpressionNode(o)
        }

        transformStringChunksToBinaryExpressionNode(e) {
          const t = e.shift(), r = e.shift();
          if (!t || !r) throw new Error("First and second chunks values should not be empty");
          const o = v.NodeFactory.binaryExpressionNode("+", v.NodeFactory.literalNode(t), v.NodeFactory.literalNode(r));
          return e.reduce((e, t) => {
            const r = v.NodeFactory.literalNode(t);
            return v.NodeFactory.binaryExpressionNode("+", e, r)
          }, o)
        }
      };
      t.SplitStringTransformer = E, E.firstPassChunkLength = 1e3, t.SplitStringTransformer = E = n = l([(0, f.injectable)(), u(0, (0, f.inject)(m.ServiceIdentifiers.IRandomGenerator)), u(1, (0, f.inject)(m.ServiceIdentifiers.IOptions)), p("design:paramtypes", ["function" == typeof (i = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== y.IOptions && y.IOptions) ? a : Object])], E)
    }, 44539: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ForceTransformStringObfuscatingGuard = void 0;
      const s = r(45337), c = r(76393), l = r(62467), d = r(31391), p = r(27391);
      let u = class {
        constructor(e) {
          this.options = e
        }

        check(e) {
          return this.options.forceTransformStrings.length && p.NodeGuards.isLiteralNode(e) && "string" == typeof e.value && this.isForceTransformString(e.value) ? l.ObfuscatingGuardResult.ForceTransform : l.ObfuscatingGuardResult.Transform
        }

        isForceTransformString(e) {
          return this.options.forceTransformStrings.some(t => null !== new RegExp(t, "g").exec(e))
        }
      };
      t.ForceTransformStringObfuscatingGuard = u, t.ForceTransformStringObfuscatingGuard = u = n([(0, s.injectable)(), a(0, (0, s.inject)(d.ServiceIdentifiers.IOptions)), i("design:paramtypes", ["function" == typeof (o = void 0 !== c.IOptions && c.IOptions) ? o : Object])], u)
    }, 44637: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 44847: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VariableDeclarationsMergeTransformer = void 0;
      const u = r(45337), f = r(31391), m = l(r(31659)), g = r(76393), h = r(31142), y = r(75716), S = r(13245),
        N = r(27391), b = r(43243);
      let _ = class extends S.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === y.NodeTransformationStage.Simplifying ? {
            leave: (e, t) => {
              if (t && N.NodeGuards.isVariableDeclarationNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (!N.NodeGuards.isNodeWithStatements(t)) return e;
          const r = b.NodeStatementUtils.getPreviousSiblingStatement(e);
          return r && N.NodeGuards.isVariableDeclarationNode(r) ? e.kind !== r.kind ? e : (r.declarations.push(...e.declarations), m.VisitorOption.Remove) : e
        }
      };
      t.VariableDeclarationsMergeTransformer = _, t.VariableDeclarationsMergeTransformer = _ = c([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (n = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== g.IOptions && g.IOptions) ? i : Object])], _)
    }, 44855: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SelfDefendingRule = void 0, t.SelfDefendingRule = e => (e.selfDefending && (e = {
        ...e,
        compact: !0,
        selfDefending: !0
      }), e)
    }, 44966: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 45045: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayStorage = void 0;
      const u = r(45337), f = r(31391), m = r(18741), g = r(26906), h = r(90211), y = r(76393), S = r(31142),
        N = r(20965), b = r(48720);
      let _ = o = class extends b.MapStorage {
        constructor(e, t, r, n, i) {
          super(r, n), this.rc4EncodedValuesSourcesCache = new Map, this.indexShiftAmount = 0, this.rotationAmount = 0, this.stringArrayStorageCallsWrapperNamesMap = new Map, this.identifierNamesGenerator = e(n), this.arrayUtils = t, this.cryptUtilsStringArray = i, this.rc4Keys = this.randomGenerator.getRandomGenerator().n(() => this.randomGenerator.getRandomGenerator().string({ length: o.rc4KeyLength }), o.rc4KeysCount)
        }

        initialize() {
          super.initialize(), this.indexShiftAmount = this.options.stringArrayIndexShift ? this.randomGenerator.getRandomInteger(o.minimumIndexShiftAmount, o.maximumIndexShiftAmount) : 0, this.rotationAmount = this.options.stringArrayRotate ? this.randomGenerator.getRandomInteger(o.minimumRotationAmount, o.maximumRotationAmount) : 0
        }

        get(e) {
          return this.getOrSetIfDoesNotExist(e)
        }

        getIndexShiftAmount() {
          return this.indexShiftAmount
        }

        getRotationAmount() {
          return this.rotationAmount
        }

        getStorageName() {
          return this.getStorageId()
        }

        getStorageId() {
          return this.stringArrayStorageName || (this.stringArrayStorageName = this.identifierNamesGenerator.generateForGlobalScope(o.stringArrayFunctionNameLength)), this.stringArrayStorageName
        }

        getStorageCallsWrapperName(e) {
          var t;
          const r = null !== (t = this.stringArrayStorageCallsWrapperNamesMap.get(e)) && void 0 !== t ? t : null;
          if (r) return r;
          const n = this.identifierNamesGenerator.generateForGlobalScope(o.stringArrayFunctionNameLength);
          return this.stringArrayStorageCallsWrapperNamesMap.set(e, n), n
        }

        rotateStorage() {
          this.getLength() && (this.storage = new Map(this.arrayUtils.rotate(Array.from(this.storage.entries()), this.rotationAmount)))
        }

        shuffleStorage() {
          this.storage = new Map(this.arrayUtils.shuffle(Array.from(this.storage.entries())).map(([e, t], r) => (t.index = r, [e, t])).sort(([, e], [, t]) => e.index - t.index))
        }

        getOrSetIfDoesNotExist(e) {
          const { encodedValue: t, encoding: r, decodeKey: o } = this.getEncodedValue(e), n = `${t}-${r}`,
            i = this.storage.get(n);
          if (i) return i;
          const a = { encodedValue: t, encoding: r, decodeKey: o, value: e, index: this.getLength() };
          return this.storage.set(n, a), a
        }

        getEncodedValue(e) {
          var t;
          const r = this.options.stringArrayEncoding.length ? this.randomGenerator.getRandomGenerator().pickone(this.options.stringArrayEncoding) : null;
          if (!r) throw new Error("`stringArrayEncoding` option array is empty");
          switch (r) {
            case N.StringArrayEncoding.Rc4: {
              const o = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys),
                n = this.cryptUtilsStringArray.btoa(this.cryptUtilsStringArray.rc4(e, o)),
                i = null !== (t = this.rc4EncodedValuesSourcesCache.get(n)) && void 0 !== t ? t : [];
              let a = i.length;
              return (!a || !i.includes(e)) && (i.push(e), a++), this.rc4EncodedValuesSourcesCache.set(n, i), a > 1 ? this.getEncodedValue(e) : {
                encodedValue: n,
                encoding: r,
                decodeKey: o
              }
            }
            case N.StringArrayEncoding.Base64: {
              const t = null;
              return { encodedValue: this.cryptUtilsStringArray.btoa(e), encoding: r, decodeKey: t }
            }
            default:
              return { encodedValue: e, encoding: r, decodeKey: null }
          }
        }
      };
      t.StringArrayStorage = _, _.minimumRotationAmount = 100, _.maximumRotationAmount = 500, _.minimumIndexShiftAmount = 100, _.maximumIndexShiftAmount = 500, _.rc4KeyLength = 4, _.rc4KeysCount = 50, _.stringArrayFunctionNameLength = 4, l([(0, u.postConstruct)(), d("design:type", Function), d("design:paramtypes", []), d("design:returntype", void 0)], _.prototype, "initialize", null), t.StringArrayStorage = _ = o = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.IArrayUtils)), p(2, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(3, (0, u.inject)(f.ServiceIdentifiers.IOptions)), p(4, (0, u.inject)(f.ServiceIdentifiers.ICryptUtilsStringArray)), d("design:paramtypes", ["function" == typeof (n = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== g.IArrayUtils && g.IArrayUtils) ? i : Object, "function" == typeof (a = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== y.IOptions && y.IOptions) ? s : Object, "function" == typeof (c = void 0 !== h.ICryptUtilsStringArray && h.ICryptUtilsStringArray) ? c : Object])], _)
    }, 45261: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeLiteralUtils = void 0;
      const o = r(27391);
      t.NodeLiteralUtils = class {
        static isNumberLiteralNode(e) {
          return "number" == typeof e.value
        }

        static isStringLiteralNode(e) {
          return "string" == typeof e.value
        }

        static isProhibitedLiteralNode(e, t) {
          return !(!o.NodeGuards.isPropertyNode(t) || t.computed || t.key !== e) || !!o.NodeGuards.isImportDeclarationNode(t) || !(!o.NodeGuards.isExportAllDeclarationNode(t) && !o.NodeGuards.isExportNamedDeclarationNode(t))
        }
      }
    }, 45316: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 45337: e => {
      e.exports = require("inversify")
    }, 45432: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 45562: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getIteratorOpcodeTemplates = function () {
        return "\n                        // Iterator Operations\n                        case opMap[127]: { // GET_ITERATOR\n                            // Get iterator from iterable using Symbol.iterator\n                            // Stack: [iterable] -> [iterator]\n                            let iterableForIterator = stack.pop();\n                            if (iterableForIterator == null) {\n                                throw new TypeError('Cannot iterate over ' + iterableForIterator);\n                            }\n                            let iteratorMethod = iterableForIterator[Symbol.iterator];\n                            if (typeof iteratorMethod !== 'function') {\n                                throw new TypeError('Object is not iterable');\n                            }\n                            stack.push(iteratorMethod.call(iterableForIterator));\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[123]: { // ITERATOR_NEXT\n                            // Call iterator.next() to get next value\n                            // Stack: [iterator] -> [result]\n                            let iteratorForNext = stack.pop();\n                            let nextResult = iteratorForNext.next();\n                            stack.push(nextResult);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[128]: { // ITERATOR_DONE\n                            // Check if iterator result is done\n                            // Stack: [result] -> [done] (boolean)\n                            let iterResult = stack.pop();\n                            stack.push(!!iterResult.done);\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 45887: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DEFAULT_PRESET = void 0;
      const o = r(76436), n = r(98151), i = r(82038), a = r(68289), s = r(64858), c = r(57088), l = r(51110),
        d = r(20965), p = r(48344), u = r(84133);
      t.DEFAULT_PRESET = Object.freeze({
        compact: !0,
        config: "",
        controlFlowFlattening: !1,
        controlFlowFlatteningThreshold: .75,
        deadCodeInjection: !1,
        deadCodeInjectionThreshold: .4,
        debugProtection: !1,
        debugProtectionInterval: 0,
        disableConsoleOutput: !1,
        domainLock: [],
        domainLockRedirectUrl: "about:blank",
        exclude: [],
        forceTransformStrings: [],
        identifierNamesCache: null,
        identifierNamesGenerator: o.IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,
        identifiersPrefix: "",
        identifiersDictionary: [],
        ignoreImports: !1,
        inputFileName: "",
        log: !1,
        numbersToExpressions: !1,
        optionsPreset: i.OptionsPreset.Default,
        renameGlobals: !1,
        renameProperties: !1,
        renamePropertiesMode: a.RenamePropertiesMode.Safe,
        reservedNames: [],
        reservedStrings: [],
        stringArrayRotate: !0,
        seed: 0,
        selfDefending: !1,
        stringArrayShuffle: !0,
        simplify: !0,
        sourceMap: !1,
        sourceMapBaseUrl: "",
        sourceMapFileName: "",
        sourceMapMode: s.SourceMapMode.Separate,
        sourceMapSourcesMode: c.SourceMapSourcesMode.SourcesContent,
        splitStrings: !1,
        splitStringsChunkLength: 10,
        stringArray: !0,
        stringArrayCallsTransform: !1,
        stringArrayCallsTransformThreshold: .5,
        stringArrayEncoding: [d.StringArrayEncoding.None],
        stringArrayIndexesType: [l.StringArrayIndexesType.HexadecimalNumber],
        stringArrayIndexShift: !0,
        stringArrayWrappersChainedCalls: !0,
        stringArrayWrappersCount: 1,
        stringArrayWrappersParametersMaxCount: 2,
        stringArrayWrappersType: p.StringArrayWrappersType.Variable,
        stringArrayThreshold: .75,
        target: n.ObfuscationTarget.Browser,
        transformObjectKeys: !1,
        unicodeEscapeSequence: !1,
        vmObfuscation: !1,
        vmObfuscationThreshold: .5,
        vmTargetFunctions: [],
        vmExcludeFunctions: [],
        vmOpcodeShuffle: !1,
        vmBytecodeEncoding: !1,
        vmBytecodeArrayEncoding: !1,
        vmJumpsEncoding: !1,
        vmDecoyOpcodes: !1,
        vmDeadCodeInjection: !1,
        vmSplitDispatcher: !1,
        vmMacroOps: !1,
        vmDebugProtection: !1,
        vmRuntimeOpcodeDerivation: !1,
        vmStatefulOpcodes: !1,
        vmStackEncoding: !1,
        vmRandomizeKeys: !1,
        vmIndirectDispatch: !1,
        vmBytecodeFormat: u.VMBytecodeFormat.Binary
      })
    }, 46188: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 46237: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getObjectOpcodeTemplates = function () {
        return "\n                        // Object/Property Operations\n                        case opMap[70]: { // GET_PROP\n                            let obj = stack.pop();\n                            let prop = constants[arg];\n                            // Validate object to provide meaningful error instead of exposing VM internals\n                            if (obj === null || obj === undefined) {\n                                throw new TypeError(\"Cannot read property '\" + prop + \"' of \" + obj);\n                            }\n                            stack.push(obj[prop]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[71]: { // SET_PROP\n                            let val = stack.pop();\n                            let obj = stack.pop();\n                            let prop = constants[arg];\n                            // Validate object to provide meaningful error instead of exposing VM internals\n                            if (obj === null || obj === undefined) {\n                                throw new TypeError(\"Cannot set property '\" + prop + \"' of \" + obj);\n                            }\n                            obj[prop] = val;\n                            stack.push(val);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[72]: { // GET_COMPUTED\n                            let prop = stack.pop();\n                            let obj = stack.pop();\n                            // Validate object to provide meaningful error instead of exposing VM internals\n                            if (obj === null || obj === undefined) {\n                                throw new TypeError(\"Cannot read property '\" + prop + \"' of \" + obj);\n                            }\n                            stack.push(obj[prop]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[73]: { // SET_COMPUTED\n                            // Stack before: [obj, key, value]\n                            // Stack after: [value]\n                            let val = stack.pop();   // Pop value\n                            let prop = stack.pop();  // Pop key\n                            let obj = stack.pop();   // Pop object\n                            // Validate object to provide meaningful error instead of exposing VM internals\n                            if (obj === null || obj === undefined) {\n                                throw new TypeError(\"Cannot set property '\" + prop + \"' of \" + obj);\n                            }\n                            obj[prop] = val;\n                            stack.push(val);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[74]: { // DELETE_PROP\n                            let prop;\n                            let obj;\n                            if (arg !== undefined) {\n                                // Named property: obj.prop - get property name from constants\n                                obj = stack.pop();\n                                prop = constants[arg];\n                            } else {\n                                // Computed property: obj[key] - get property from stack\n                                prop = stack.pop();\n                                obj = stack.pop();\n                            }\n                            let result = delete obj[prop];\n                            stack.push(result);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[75]: { // GET_GLOBAL\n                            let name = constants[arg];\n                            let value;\n                            let globalObj = (typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : global));\n\n                            // Use 'in' operator instead of hasOwnProperty for better performance\n                            if (name in {vmGlobalsName}) {\n                                // Check VM globals first (for obfuscator-created globals)\n                                value = {vmGlobalsName}[name];\n                            } else if ({vmModuleVarsName} && name in {vmModuleVarsName}) {\n                                // Check module-scoped variables (require, module, exports, __filename, __dirname)\n                                value = {vmModuleVarsName}[name];\n                            } else if (name in globalObj) {\n                                // BUG FIX #589: Only access global if it actually exists\n                                // Fall back to actual global object\n                                value = globalObj[name];\n                            } else {\n                                // BUG FIX #589: Throw ReferenceError for undefined variables\n                                // In JavaScript, accessing an undeclared variable throws ReferenceError\n                                throw new ReferenceError(name + ' is not defined');\n                            }\n                            stack.push(value);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[76]: { // SET_GLOBAL\n                            let val = stack.pop();\n                            let name = constants[arg];\n                            // Update in the appropriate location:\n                            // - If it exists in module vars (module, exports, etc.), update there\n                            // - Otherwise update in VM globals\n                            if ({vmModuleVarsName} && name in {vmModuleVarsName}) {\n                                {vmModuleVarsName}[name] = val;\n                            } else {\n                                {vmGlobalsName}[name] = val;\n                            }\n                            stack.push(val);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[77]: { // NEW_OBJECT\n                            stack.push({});\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[78]: { // GET_OPTIONAL\n                            let obj = stack.pop();\n                            let prop = constants[arg];\n                            // Optional chaining: if obj is null/undefined, return undefined\n                            if (obj === null || obj === undefined) {\n                                stack.push(undefined);\n                            } else {\n                                stack.push(obj[prop]);\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[79]: { // IN\n                            // 'in' operator: checks if property exists in object\n                            // Stack before: [property, object]\n                            // Stack after: [boolean]\n                            let inObj = stack.pop();\n                            let inProp = stack.pop();\n                            stack.push(inProp in inObj);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[81]: { // OBJECT_SPREAD\n                            // Object spread: merge properties from source to target\n                            // Stack before: [target, source]\n                            // Stack after: [target] (with properties from source merged)\n                            let spreadSource = stack.pop();\n                            let spreadTarget = stack[stack.length - 1]; // Peek at target (don't pop)\n                            // Use Object.assign to merge properties\n                            if (spreadSource !== null && spreadSource !== undefined) {\n                                Object.assign(spreadTarget, spreadSource);\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[82]: { // GET_COMPUTED_OPTIONAL\n                            // Optional chaining with computed property: obj?.[expr]\n                            // Stack before: [object, property]\n                            // Stack after: [value or undefined]\n                            let optProp = stack.pop();\n                            let optObj = stack.pop();\n                            // If object is null/undefined, return undefined\n                            if (optObj === null || optObj === undefined) {\n                                stack.push(undefined);\n                            } else {\n                                stack.push(optObj[optProp]);\n                            }\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 46293: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 46300: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 46331: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VM_MEDIUM_OBFUSCATION_PRESET = t.VM_MEDIUM_OBFUSCATION_PRESET_VM_OPTIONS = void 0;
      const o = r(82038), n = r(6335), i = r(76436), a = r(84133);
      t.VM_MEDIUM_OBFUSCATION_PRESET_VM_OPTIONS = {
        vmObfuscation: !0,
        vmObfuscationThreshold: 1,
        vmOpcodeShuffle: !0,
        vmBytecodeEncoding: !0,
        vmBytecodeArrayEncoding: !0,
        vmJumpsEncoding: !0,
        vmDecoyOpcodes: !0,
        vmDeadCodeInjection: !0,
        vmSplitDispatcher: !0,
        vmMacroOps: !0,
        vmDebugProtection: !1,
        vmRuntimeOpcodeDerivation: !0,
        vmStatefulOpcodes: !0,
        vmStackEncoding: !0,
        vmRandomizeKeys: !0,
        vmIndirectDispatch: !0,
        vmBytecodeFormat: a.VMBytecodeFormat.Binary
      }, t.VM_MEDIUM_OBFUSCATION_PRESET = Object.freeze({
        ...n.NO_ADDITIONAL_NODES_PRESET, ...t.VM_MEDIUM_OBFUSCATION_PRESET_VM_OPTIONS,
        optionsPreset: o.OptionsPreset.VMMediumObfuscation,
        compact: !0,
        simplify: !0,
        identifierNamesGenerator: i.IdentifierNamesGenerator.MangledShuffledIdentifierNamesGenerator
      })
    }, 46391: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LevelledTopologicalSorter = void 0;
      const n = r(45337);
      let i = class {
        constructor() {
          this.graph = new Map
        }

        add(e, t = null) {
          return null !== t ? this.link(e, t) : this.register(e)
        }

        sort() {
          const e = Array.from(this.graph.keys()), t = [], r = {};
          for (const o of e) void 0 === r[o] && this.visit(t, r, o);
          return t
        }

        sortByGroups() {
          this.sort();
          const e = [];
          for (; this.hasNodes();) {
            const t = this.findRootNodes();
            e.push(t);
            for (const e of t) this.delete(e)
          }
          return e
        }

        delete(e) {
          if (this.getPrecedents(e).length) throw new Error(`Unable to remove non-root node: ${e}`);
          this.graph.delete(e);
          const t = Array.from(this.graph.values());
          for (const r of t) for (let t = r.length - 1; t >= 0; t -= 1) r[t] === e && r.splice(t, 1)
        }

        findRootNodes() {
          const e = Array.from(this.graph.keys()), t = [];
          for (const r of e) this.hasPrecedents(r) || t.push(r);
          return t
        }

        getPrecedents(e) {
          const t = this.graph.get(e);
          if (!t) throw new Error(`Unknown node: ${e}`);
          return t
        }

        hasNodes() {
          return this.graph.size > 0
        }

        hasPrecedents(e) {
          return this.getPrecedents(e).length > 0
        }

        link(e, t) {
          this.register(e), this.register(t);
          const r = this.graph.get(t);
          return r && !r.includes(e) && r.push(e), this
        }

        register(e) {
          return this.graph.has(e) || this.graph.set(e, []), this
        }

        visit(e, t, r) {
          const o = t[r];
          if ("visiting" === o) throw new Error(`Detected cycle involving node: ${r}`);
          if (o) return;
          t[r] = "visiting";
          const n = this.getPrecedents(r);
          for (const r of n) this.visit(e, t, r);
          t[r] = "ok", e.push(r)
        }
      };
      t.LevelledTopologicalSorter = i, t.LevelledTopologicalSorter = i = o([(0, n.injectable)()], i)
    }, 46725: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 47074: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractControlFlowReplacer = void 0;
      const d = r(45337), p = r(31391), u = r(46300), f = r(18741), m = r(76393), g = r(31142);
      let h = class {
        constructor(e, t, r, o) {
          this.replacerDataByControlFlowStorageId = new Map, this.controlFlowCustomNodeFactory = e, this.identifierNamesGenerator = t(o), this.randomGenerator = r, this.options = o
        }

        generateStorageKey(e) {
          const t = this.randomGenerator.getRandomString(5);
          return e.has(t) ? this.generateStorageKey(e) : t
        }

        insertCustomNodeToControlFlowStorage(e, t, r, o) {
          var n, i;
          const a = t.getStorageId(),
            s = null !== (n = this.replacerDataByControlFlowStorageId.get(a)) && void 0 !== n ? n : new Map,
            c = null !== (i = s.get(r)) && void 0 !== i ? i : [];
          if (this.randomGenerator.getMathRandom() < o && c.length) return this.randomGenerator.getRandomGenerator().pickone(c);
          const l = this.generateStorageKey(t);
          return c.push(l), s.set(r, c), this.replacerDataByControlFlowStorageId.set(a, s), t.set(l, e), l
        }
      };
      t.AbstractControlFlowReplacer = h, t.AbstractControlFlowReplacer = h = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IControlFlowCustomNode)), l(1, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TControlFlowCustomNodeFactory && u.TControlFlowCustomNodeFactory) ? o : Object, "function" == typeof (n = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], h)
    }, 47129: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BinaryExpressionFunctionNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(8053),
        y = r(93571), S = r(33056);
      let N = class extends h.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e) {
          this.operator = e
        }

        getNodeStructure() {
          const e = y.NodeFactory.expressionStatementNode(y.NodeFactory.functionExpressionNode([y.NodeFactory.identifierNode("x"), y.NodeFactory.identifierNode("y")], y.NodeFactory.blockStatementNode([y.NodeFactory.returnStatementNode(y.NodeFactory.binaryExpressionNode(this.operator, y.NodeFactory.identifierNode("x"), y.NodeFactory.identifierNode("y")))])));
          return S.NodeUtils.parentizeAst(e), [e]
        }
      };
      t.BinaryExpressionFunctionNode = N, t.BinaryExpressionFunctionNode = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 47250: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeAppender = void 0;
      const o = r(27391);

      class n {
        static append(e, t) {
          t = n.parentizeScopeStatementsBeforeAppend(e, t);
          const r = n.getScopeStatements(e).concat(t);
          n.setScopeStatements(e, r)
        }

        static appendToOptimalBlockScope(e, t, r, o = 0) {
          const i = e.length ? n.getOptimalBlockScope(e, o) : t;
          n.prepend(i, r)
        }

        static getOptimalBlockScope(e, t, r = 1 / 0) {
          const o = e[t];
          if (r <= 0) throw new Error("Invalid `deep` argument value. Value should be bigger then 0.");
          return r > 1 && o.callsGraph.length ? n.getOptimalBlockScope(o.callsGraph, 0, --r) : o.callee
        }

        static getScopeStatements(e) {
          return o.NodeGuards.isSwitchCaseNode(e) ? e.consequent : e.body
        }

        static insertBefore(e, t, r) {
          const o = n.getScopeStatements(e).indexOf(r);
          n.insertAtIndex(e, t, o)
        }

        static insertAfter(e, t, r) {
          const o = n.getScopeStatements(e).indexOf(r);
          n.insertAtIndex(e, t, o + 1)
        }

        static insertAtIndex(e, t, r) {
          t = n.parentizeScopeStatementsBeforeAppend(e, t), n.setScopeStatements(e, [...n.getScopeStatements(e).slice(0, r), ...t, ...n.getScopeStatements(e).slice(r)])
        }

        static prepend(e, t) {
          const r = (t = n.parentizeScopeStatementsBeforeAppend(e, t)).concat(n.getScopeStatements(e));
          n.setScopeStatements(e, r)
        }

        static remove(e, t) {
          const r = n.getScopeStatements(e), o = r.indexOf(t);
          if (-1 === o) return;
          const i = [...r];
          i.splice(o, 1), n.setScopeStatements(e, i)
        }

        static parentizeScopeStatementsBeforeAppend(e, t) {
          return t.forEach(t => {
            t.parentNode = e
          }), t
        }

        static setScopeStatements(e, t) {
          o.NodeGuards.isSwitchCaseNode(e) ? e.consequent = t : e.body = t
        }
      }

      t.NodeAppender = n
    }, 47351: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MangledIdentifierNamesGenerator = void 0;
      const d = r(45337), p = r(31391), u = r(76393), f = r(31142), m = r(82797), g = r(55194), h = r(6088),
        y = r(36869), S = r(98811), N = r(10419), b = r(75096);
      let _ = o = class extends N.AbstractIdentifierNamesGenerator {
        constructor(e, t, r) {
          super(e, t), this.lastMangledName = o.initMangledNameCharacter, this.lastMangledNameForScopeMap = new WeakMap, this.lastMangledNameForLabelMap = new Map, this.setUtils = r
        }

        generateNext(e) {
          const t = this.generateNewMangledName(this.lastMangledName);
          return this.updatePreviousMangledName(t), this.preserveName(t), t
        }

        generateForGlobalScope(e) {
          const t = this.options.identifiersPrefix ? `${this.options.identifiersPrefix}` : "",
            r = this.generateNewMangledName(this.lastMangledName, e => {
              const r = `${t}${e}`;
              return this.isValidIdentifierName(r)
            }), o = `${t}${r}`;
          return this.updatePreviousMangledName(r), this.preserveName(o), o
        }

        generateForLexicalScope(e, t) {
          const r = [e, ...b.NodeLexicalScopeUtils.getLexicalScopes(e)], o = this.getLastMangledNameForScopes(r),
            n = this.generateNewMangledName(o, e => this.isValidIdentifierNameInLexicalScopes(e, r));
          return this.lastMangledNameForScopeMap.set(e, n), this.updatePreviousMangledName(n), this.preserveNameForLexicalScope(n, e), n
        }

        generateForLabel(e, t) {
          const r = this.getLastMangledNameForLabel(e), o = this.generateNewMangledName(r);
          return this.updatePreviousMangledNameForLabel(o, e, r), o
        }

        isIncrementedMangledName(e, t) {
          if (e === t) return !1;
          const r = e.length, o = t.length;
          if (r !== o) return r > o;
          const n = this.getNameSequence();
          for (let o = 0; o < r; o++) {
            const r = e[o], i = t[o];
            if (r !== i) return n.indexOf(r) > n.indexOf(i)
          }
          throw new Error("Something goes wrong during comparison of mangled names")
        }

        isValidIdentifierName(e) {
          return super.isValidIdentifierName(e) && !o.reservedNamesSet.has(e)
        }

        getNameSequence() {
          return o.nameSequence
        }

        updatePreviousMangledName(e) {
          this.isIncrementedMangledName(e, this.lastMangledName) && (this.lastMangledName = e)
        }

        updatePreviousMangledNameForLabel(e, t, r) {
          this.isIncrementedMangledName(e, r) && this.lastMangledNameForLabelMap.set(t, e)
        }

        generateNewMangledName(e, t) {
          var r;
          const n = (e, t = 0) => {
            if (t > o.maxRegenerationAttempts) {
              const e = this.setUtils.getLastElement(this.preservedNamesSet);
              if (e) return this.generateNewMangledName(e)
            }
            const r = this.getNameSequence(), n = r.length, i = e.length, a = e => "0".repeat(e);
            let s = i - 1;
            do {
              const t = e[s], o = r.indexOf(t);
              if (o !== n - 1) return e.slice(0, s) + r[o + 1] + a(i - (s + 1));
              --s
            } while (s >= 0);
            return `${r[y.numbersString.length]}${a(i)}`
          };
          let i, a = e;
          do {
            a = n(a), i = null !== (r = null == t ? void 0 : t(a)) && void 0 !== r ? r : this.isValidIdentifierName(a)
          } while (!i);
          return a
        }

        getLastMangledNameForScopes(e) {
          var t;
          for (const r of e) {
            const e = null !== (t = this.lastMangledNameForScopeMap.get(r)) && void 0 !== t ? t : null;
            if (e) return e
          }
          return o.initMangledNameCharacter
        }

        getLastMangledNameForLabel(e) {
          var t;
          const r = null !== (t = this.lastMangledNameForLabelMap.get(e)) && void 0 !== t ? t : null;
          return null != r ? r : o.initMangledNameCharacter
        }
      };
      t.MangledIdentifierNamesGenerator = _, _.maxRegenerationAttempts = 20, _.initMangledNameCharacter = "9", _.nameSequence = [...`${y.numbersString}${g.alphabetString}${h.alphabetStringUppercase}`.split("")], _.reservedNamesSet = new Set(S.reservedIdentifierNames), t.MangledIdentifierNamesGenerator = _ = o = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.IOptions)), l(2, (0, d.inject)(p.ServiceIdentifiers.ISetUtils)), c("design:paramtypes", ["function" == typeof (n = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== u.IOptions && u.IOptions) ? i : Object, "function" == typeof (a = void 0 !== m.ISetUtils && m.ISetUtils) ? a : Object])], _)
    }, 47788: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionFunctionIntervalTemplate = function () {
        return "\n        (function () {\n            {globalVariableTemplate}\n    \n            that.setInterval({debugProtectionFunctionName}, {debugProtectionInterval});\n        })();\n    "
      }
    }, 47876: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.InputFileNameRule = void 0;
      const o = r(52849);
      t.InputFileNameRule = e => {
        let { inputFileName: t } = e;
        return t && (t = t.replace(/^\/+/, "").split(o.StringSeparator.Dot).slice(0, -1).join(o.StringSeparator.Dot) || t, e = {
          ...e,
          inputFileName: `${t}.js`
        }), e
      }
    }, 48222: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractCustomCodeHelper = void 0;
      const u = r(45337), f = r(31391), m = r(18741), g = r(39032), h = r(25714), y = r(76393), S = r(31142),
        N = r(7536), b = r(32385), _ = r(98151), v = r(14698), I = r(54494);
      let O = o = class {
        constructor(e, t, r, o, n) {
          this.cachedNode = null, this.identifierNamesGenerator = e(n), this.customCodeHelperFormatter = t, this.customCodeHelperObfuscator = r, this.randomGenerator = o, this.options = n
        }

        getNode() {
          if (!this.cachedNode) {
            const e = this.getCodeHelperTemplate();
            this.cachedNode = this.customCodeHelperFormatter.formatStructure(this.getNodeStructure(e))
          }
          return this.cachedNode
        }

        getGlobalVariableTemplate() {
          switch (this.options.target) {
            case _.ObfuscationTarget.BrowserNoEval:
              return (0, v.GlobalVariableNoEvalTemplate)();
            case _.ObfuscationTarget.ServiceWorker:
              return (0, I.GlobalVariableServiceWorkerTemplate)();
            default:
              return this.randomGenerator.getRandomGenerator().pickone(o.globalVariableTemplateFunctions)
          }
        }

        getCodeHelperTemplate() {
          return ""
        }
      };
      t.AbstractCustomCodeHelper = O, O.globalVariableTemplateFunctions = [(0, N.GlobalVariableTemplate1)(), (0, b.GlobalVariableTemplate2)()], t.AbstractCustomCodeHelper = O = o = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperFormatter)), p(2, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperObfuscator)), p(3, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(4, (0, u.inject)(f.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (n = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperFormatter && g.ICustomCodeHelperFormatter) ? i : Object, "function" == typeof (a = void 0 !== h.ICustomCodeHelperObfuscator && h.ICustomCodeHelperObfuscator) ? a : Object, "function" == typeof (s = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== y.IOptions && y.IOptions) ? c : Object])], O)
    }, 48344: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayWrappersType = void 0;
      const o = r(39079);
      t.StringArrayWrappersType = o.Utils.makeEnum({ Variable: "variable", Function: "function" })
    }, 48456: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IdentifierNamesCacheRule = void 0, t.IdentifierNamesCacheRule = e => {
        let t = e.identifierNamesCache;
        return t && !t.globalIdentifiers && (t = {
          ...t,
          globalIdentifiers: {}
        }), t && !t.propertyIdentifiers && (t = { ...t, propertyIdentifiers: {} }), { ...e, identifierNamesCache: t }
      }
    }, 48708: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeTransformerNamesGroupsBuilder = void 0;
      const n = r(45337), i = r(87652);
      let a = class extends i.AbstractTransformerNamesGroupsBuilder {
      };
      t.CodeTransformerNamesGroupsBuilder = a, t.CodeTransformerNamesGroupsBuilder = a = o([(0, n.injectable)()], a)
    }, 48720: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MapStorage = void 0;
      const l = r(45337), d = r(31391), p = r(76393), u = r(31142), f = r(50164);
      let m = class {
        constructor(e, t) {
          this.randomGenerator = e, this.options = t
        }

        initialize() {
          this.storage = new Map, this.storageId = this.randomGenerator.getRandomString(6)
        }

        get(e) {
          return this.storage.get(e)
        }

        getOrThrow(e) {
          const t = this.get(e);
          if (!t) throw new Error(`No value found in map storage with key \`${e}\``);
          return t
        }

        getKeyOf(e) {
          for (const [t, r] of this.storage) if (e === r) return t;
          return null
        }

        getLength() {
          return this.storage.size
        }

        getStorage() {
          return this.storage
        }

        getStorageAsDictionary() {
          return Object.fromEntries(this.storage)
        }

        getStorageId() {
          return this.storageId
        }

        has(e) {
          return this.storage.has(e)
        }

        mergeWith(e, t = !1) {
          this.storage = new Map([...this.storage, ...e.getStorage()]), t && (this.storageId = e.getStorageId())
        }

        set(e, t) {
          this.storage.set(e, t)
        }
      };
      t.MapStorage = m, a([(0, f.initializable)(), s("design:type", String)], m.prototype, "storageId", void 0), a([(0, f.initializable)(), s("design:type", "function" == typeof (i = "undefined" != typeof Map && Map) ? i : Object)], m.prototype, "storage", void 0), a([(0, l.postConstruct)(), s("design:type", Function), s("design:paramtypes", []), s("design:returntype", void 0)], m.prototype, "initialize", null), t.MapStorage = m = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (o = void 0 !== u.IRandomGenerator && u.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== p.IOptions && p.IOptions) ? n : Object])], m)
    }, 49016: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayWrappersChainedCallsRule = void 0, t.StringArrayWrappersChainedCallsRule = e => (0 === e.stringArrayWrappersCount && (e = {
        ...e,
        stringArrayWrappersChainedCalls: !1,
        stringArrayWrappersCount: 0
      }), e)
    }, 49703: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 49804: function (e, t, r) {
      var o = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringUtils = void 0;
      const n = o(r(97897));
      t.StringUtils = class {
        static escapeJsString(e) {
          return (0, n.default)(e)
        }
      }
    }, 49991: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 50164: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.initializable = function () {
        return (e, t) => {
          const d = e[c];
          if (!d || "function" != typeof d) throw new Error(`\`${c}\` method with initialization logic not found. \`@${r}\` decorator requires \`${c}\` method`);
          return l(n, !1, e), l(i, new Set, e), l(a, new Set, e), function (e) {
            const t = Object.getOwnPropertyNames(e), r = new Set([c, s]);
            t.forEach(t => {
              var s;
              const l = Reflect.getMetadata(i, e), d = Reflect.getMetadata(a, e);
              if (r.has(t) || l.has(t) || d.has(t)) return;
              if ("function" != typeof e[t]) return;
              const p = null !== (s = Object.getOwnPropertyDescriptor(e, t)) && void 0 !== s ? s : o, u = p.value;
              Object.defineProperty(e, t, {
                ...p, value() {
                  if (!Reflect.getMetadata(n, this)) throw new Error(`Class should be initialized with \`${c}()\` method`);
                  return u.apply(this, arguments)
                }
              }), d.add(t)
            })
          }(e), function (e, t) {
            var r;
            const i = null !== (r = Object.getOwnPropertyDescriptor(e, c)) && void 0 !== r ? r : o, a = i.value;
            Object.defineProperty(e, c, {
              ...i, value: function () {
                Reflect.defineMetadata(n, !0, this);
                const e = a.apply(this, arguments);
                return this[t], e
              }
            })
          }(e, t), function (e, t) {
            var r;
            Reflect.getMetadata(i, e).add(t);
            const n = `_${t.toString()}`,
              a = null !== (r = Object.getOwnPropertyDescriptor(e, n)) && void 0 !== r ? r : o;
            return Object.defineProperty(e, t, {
              ...a, get: function () {
                if (void 0 === this[n]) throw new Error(`Property \`${t.toString()}\` is not initialized! Initialize it first!`);
                return this[n]
              }, set: function (e) {
                this[n] = e
              }
            }), a
          }(e, t)
        }
      };
      const r = "initializable", o = { configurable: !0, enumerable: !0 }, n = "_initialized",
        i = "_initializablePropertiesSet", a = "_wrappedMethodsSet", s = "constructor", c = "initialize";

      function l(e, t, r) {
        Reflect.hasMetadata(e, r) || Reflect.defineMetadata(e, t, r)
      }
    }, 50474: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ExportSpecifierTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(13245), m = r(27391),
        g = r(33056);
      let h = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && m.NodeGuards.isExportSpecifierNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          return e.local.name === e.exported.name && (e.exported = g.NodeUtils.clone(e.local)), e
        }
      };
      t.ExportSpecifierTransformer = h, t.ExportSpecifierTransformer = h = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], h)
    }, 50523: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 50704: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.stringArrayTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(19691), s = r(43830), c = r(41818);
      t.stringArrayTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(a.StringArrayRotateFunctionTransformer).whenTargetNamed(i.NodeTransformer.StringArrayRotateFunctionTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(s.StringArrayScopeCallsWrapperTransformer).whenTargetNamed(i.NodeTransformer.StringArrayScopeCallsWrapperTransformer), e(n.ServiceIdentifiers.INodeTransformer).to(c.StringArrayTransformer).whenTargetNamed(i.NodeTransformer.StringArrayTransformer)
      })
    }, 51069: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BinaryExpressionControlFlowReplacer = void 0;
      const p = r(45337), u = r(31391), f = r(46300), m = r(18741), g = r(76393), h = r(31142), y = r(62059),
        S = r(42610);
      let N = o = class extends S.ExpressionWithOperatorControlFlowReplacer {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        replace(e, t, r) {
          const n = e.operator,
            i = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.BinaryExpressionFunctionNode);
          i.initialize(n);
          const a = this.insertCustomNodeToControlFlowStorage(i, r, n, o.usingExistingIdentifierChance);
          return this.getControlFlowStorageCallNode(r.getStorageId(), a, e.left, e.right)
        }
      };
      t.BinaryExpressionControlFlowReplacer = N, N.usingExistingIdentifierChance = .5, t.BinaryExpressionControlFlowReplacer = N = o = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IControlFlowCustomNode)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (n = void 0 !== f.TControlFlowCustomNodeFactory && f.TControlFlowCustomNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? i : Object, "function" == typeof (a = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== g.IOptions && g.IOptions) ? s : Object])], N)
    }, 51110: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayIndexesType = void 0;
      const o = r(39079);
      t.StringArrayIndexesType = o.Utils.makeEnum({
        HexadecimalNumber: "hexadecimal-number",
        HexadecimalNumericString: "hexadecimal-numeric-string"
      })
    }, 51168: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ecmaVersion = void 0, t.ecmaVersion = 13
    }, 51234: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObfuscatingGuardsTransformer = void 0;
      const d = r(45337), p = r(31391), u = r(35196), f = r(76393), m = r(31142), g = r(92486), h = r(75716),
        y = r(22056), S = r(62467), N = r(13245), b = r(27391), _ = r(4592);
      let v = o = class extends N.AbstractNodeTransformer {
        constructor(e, t, r) {
          super(t, r), this.runAfter = [g.NodeTransformer.ParentificationTransformer, g.NodeTransformer.VariablePreserveTransformer], this.obfuscatingGuards = o.obfuscatingGuardsList.map(e)
        }

        getVisitor(e) {
          return e === h.NodeTransformationStage.Preparing ? { enter: (e, t) => this.transformNode(e, t) } : null
        }

        transformNode(e, t) {
          const r = this.obfuscatingGuards.map(t => t.check(e));
          return this.setNodeMetadata(e, r), e
        }

        setNodeMetadata(e, t) {
          let r = !1, o = !1;
          t.every(e => e === S.ObfuscatingGuardResult.Transform) || (r = t.includes(S.ObfuscatingGuardResult.ForceTransform), o = !r && t.includes(S.ObfuscatingGuardResult.Ignore)), _.NodeMetadata.set(e, {
            forceTransformNode: r && !b.NodeGuards.isProgramNode(e),
            ignoredNode: o && !b.NodeGuards.isProgramNode(e)
          })
        }
      };
      t.ObfuscatingGuardsTransformer = v, v.obfuscatingGuardsList = [y.ObfuscatingGuard.BlackListObfuscatingGuard, y.ObfuscatingGuard.ConditionalCommentObfuscatingGuard, y.ObfuscatingGuard.ForceTransformStringObfuscatingGuard, y.ObfuscatingGuard.IgnoredImportObfuscatingGuard, y.ObfuscatingGuard.ImportMetaObfuscationGuard, y.ObfuscatingGuard.ReservedStringObfuscatingGuard], t.ObfuscatingGuardsTransformer = v = o = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__INodeGuard)), l(1, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(2, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (n = void 0 !== u.TObfuscatingGuardFactory && u.TObfuscatingGuardFactory) ? n : Object, "function" == typeof (i = void 0 !== m.IRandomGenerator && m.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== f.IOptions && f.IOptions) ? a : Object])], v)
    }, 51254: function (e, t, r) {
      var o, n, i = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), a = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && i(t, e, r[n]);
        return a(t, e), t
      });
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ScopeAnalyzer = void 0;
      const l = r(45337), d = c(r(43908)), p = c(r(31659)), u = r(19261), f = r(51168), m = r(27391);
      let g = n = class {
        constructor() {
          this.scopeManager = null
        }

        static attachMissingRanges(e) {
          p.replace(e, {
            enter: (e, t) => {
              var r, o, i, a;
              return e.range || (e.range = [null !== (o = null === (r = null == t ? void 0 : t.range) || void 0 === r ? void 0 : r[0]) && void 0 !== o ? o : n.emptyRangeValue, null !== (a = null === (i = null == t ? void 0 : t.range) || void 0 === i ? void 0 : i[1]) && void 0 !== a ? a : n.emptyRangeValue]), e
            }
          })
        }

        static isRootNode(e) {
          return m.NodeGuards.isProgramNode(e) || e.parentNode === e
        }

        analyze(e) {
          const t = n.sourceTypes.length;
          n.attachMissingRanges(e);
          for (let r = 0; r < t; r++) try {
            return void (this.scopeManager = d.analyze(e, { ...n.eslintScopeOptions, sourceType: n.sourceTypes[r] }))
          } catch (e) {
            if (r < t - 1) continue;
            throw new Error(e)
          }
          throw new Error("Scope analyzing error")
        }

        acquireScope(e) {
          if (!this.scopeManager) throw new Error("Scope manager is not defined");
          const t = this.scopeManager.acquire(e, n.isRootNode(e));
          if (!t) throw new Error("Cannot acquire scope for node");
          return this.sanitizeScopes(t), t
        }

        analyzeMutableCaptures() {
          if (!this.scopeManager) throw new Error("Scope manager is not defined. Call analyze() first.");
          const e = new Map;
          return this.walkScopes(this.scopeManager.globalScope, t => {
            for (const r of t.variables) {
              const o = r.name;
              if (e.has(o)) continue;
              const n = [], i = [];
              for (const e of r.references) {
                const r = e.from;
                r && this.isChildFunctionScope(r, t) && (n.includes(r) || n.push(r), e.isWrite() && (i.includes(r) || i.push(r)))
              }
              n.length > 0 && i.length > 0 && e.set(o, {
                name: o,
                declaredInScope: t,
                capturedByScopes: n,
                mutatedInScopes: i
              })
            }
          }), e
        }

        sanitizeScopes(e) {
          e.childScopes.forEach(e => {
            if ("class" === e.type && e.upper) {
              if (!e.variables.length) return;
              const t = e.variables[0],
                r = e.upper.variables.find(e => t.defs.some(e => "ClassName" === e.type) && e.name === t.name);
              null == r || r.references.push(...e.variables[0].references)
            }
          });
          for (const t of e.childScopes) this.sanitizeScopes(t)
        }

        walkScopes(e, t) {
          t(e);
          for (const r of e.childScopes) this.walkScopes(r, t)
        }

        isChildScope(e, t) {
          let r = e.upper;
          for (; r;) {
            if (r === t) return !0;
            r = r.upper
          }
          return !1
        }

        isChildFunctionScope(e, t) {
          if ("function" === e.type && this.isChildScope(e, t)) return !0;
          let r = e.upper;
          for (; r && r !== t;) {
            if ("function" === r.type) return !0;
            r = r.upper
          }
          return !1
        }
      };
      t.ScopeAnalyzer = g, g.eslintScopeOptions = {
        ecmaVersion: f.ecmaVersion,
        childVisitorKeys: u.KEYS,
        optimistic: !0
      }, g.sourceTypes = ["script", "module"], g.emptyRangeValue = 0, t.ScopeAnalyzer = g = n = s([(0, l.injectable)()], g)
    }, 51353: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 51841: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.deriveOpcodeTable = u, t.generateSeedOpcodeMapping = function (e, t, r) {
        const o = e();
        return { seed: o, opcodeMap: u(o, t, r) }
      };
      const o = r(79240), n = 2246822507, i = 3266489909, a = 16, s = 13, c = 16, l = 2654435769;

      function d(e) {
        return e >>>= 0, e ^= e >>> a, e = Math.imul(e, n) >>> 0, e ^= e >>> s, e = Math.imul(e, i) >>> 0, (e ^= e >>> c) >>> 0
      }

      function p(e, t) {
        let r = (e ^ t * l) >>> 0;
        return r = (r ^ r >>> 11) >>> 0, r = Math.imul(r, 461845907) >>> 0, r = (r ^ r >>> 15) >>> 0, d(r)
      }

      function u(e, t, r) {
        let n = e ^ t * l >>> 0;
        n = (n ^ 668265261 * r >>> 0) >>> 0, n = d(n);
        const i = [];
        for (let e = 0; e < o.VM_OPCODE_COUNT; e++) i[e] = e;
        for (let e = o.VM_OPCODE_COUNT - 1; e > 0; e--) {
          const t = p(n, e) % (e + 1), r = i[e];
          i[e] = i[t], i[t] = r
        }
        const a = {};
        for (let e = 0; e < o.VM_OPCODE_COUNT; e++) a[e] = i[e];
        return a
      }
    }, 51875: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomCodeHelper = void 0, function (e) {
        e.CallsControllerFunction = "CallsControllerFunction", e.ConsoleOutputDisable = "ConsoleOutputDisable", e.DebugProtectionFunctionCall = "DebugProtectionFunctionCall", e.DebugProtectionFunctionInterval = "DebugProtectionFunctionInterval", e.DebugProtectionFunction = "DebugProtectionFunction", e.DomainLock = "DomainLock", e.SelfDefending = "SelfDefending", e.StringArray = "StringArray", e.StringArrayCallsWrapper = "StringArrayCallsWrapper", e.StringArrayCallsWrapperBase64 = "StringArrayCallsWrapperBase64", e.StringArrayCallsWrapperRc4 = "StringArrayCallsWrapperRc4", e.StringArrayRotateFunction = "StringArrayRotateFunction", e.VMRuntime = "VMRuntime"
      }(r || (t.CustomCodeHelper = r = {}))
    }, 51981: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 });
      const o = r(61801);
      e.exports = o.JavaScriptObfuscator
    }, 52100: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomCodeHelperGroup = void 0, function (e) {
        e.ConsoleOutput = "ConsoleOutput", e.DebugProtection = "DebugProtection", e.DomainLock = "DomainLock", e.SelfDefending = "SelfDefending", e.StringArray = "StringArray", e.VM = "VM"
      }(r || (t.CustomCodeHelperGroup = r = {}))
    }, 52240: function (e, t, r) {
      var o, n = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), a = 0; a < r.length; a++) "default" !== r[a] && n(t, e, r[a]);
        return i(t, e), t
      });
      Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionDeclarationCalleeDataExtractor = void 0;
      const c = r(45337), l = s(r(31659)), d = r(75476), p = r(27391), u = r(43243);
      let f = class extends d.AbstractCalleeDataExtractor {
        extract(e, t) {
          if (!p.NodeGuards.isIdentifierNode(t)) return null;
          const r = this.getCalleeBlockStatement(u.NodeStatementUtils.getParentNodeWithStatements(e[0]), t.name);
          return r ? { callee: r, name: t.name } : null
        }

        getCalleeBlockStatement(e, t) {
          let r = null;
          return l.traverse(e, {
            enter: e => {
              if (p.NodeGuards.isFunctionDeclarationNode(e) && e.id.name === t) return r = e.body, l.VisitorOption.Break
            }
          }), r
        }
      };
      t.FunctionDeclarationCalleeDataExtractor = f, t.FunctionDeclarationCalleeDataExtractor = f = a([(0, c.injectable)()], f)
    }, 52263: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.TemplateLiteralTransformer = void 0;
      const l = r(45337), d = r(31391), p = r(76393), u = r(31142), f = r(75716), m = r(13245), g = r(93571),
        h = r(27391), y = r(33056);
      let S = o = class extends m.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        static isLiteralNodeWithStringValue(e) {
          return !!e && h.NodeGuards.isLiteralNode(e) && "string" == typeof e.value
        }

        getVisitor(e) {
          return e === f.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && h.NodeGuards.isTemplateLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          return h.NodeGuards.isTaggedTemplateExpressionNode(t) ? e : this.transformTemplateLiteralNode(e, t)
        }

        transformTemplateLiteralNode(e, t) {
          const r = e.expressions;
          let n, i = [];
          if (e.quasis.forEach(e => {
            if (void 0 === e.value.cooked || null === e.value.cooked) return;
            i.push(g.NodeFactory.literalNode(e.value.cooked));
            const t = r.shift();
            t && i.push(t)
          }), i = i.filter(e => !(h.NodeGuards.isLiteralNode(e) && "" === e.value)), o.isLiteralNodeWithStringValue(i[0]) || o.isLiteralNodeWithStringValue(i[1]) || i.unshift(g.NodeFactory.literalNode("")), i.length > 1) {
            let e = g.NodeFactory.binaryExpressionNode("+", i.shift(), i.shift());
            i.forEach(t => {
              e = g.NodeFactory.binaryExpressionNode("+", e, t)
            }), n = e
          } else n = i[0];
          return y.NodeUtils.parentizeAst(n), y.NodeUtils.parentizeNode(n, t), n
        }
      };
      t.TemplateLiteralTransformer = S, t.TemplateLiteralTransformer = S = o = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (n = void 0 !== u.IRandomGenerator && u.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== p.IOptions && p.IOptions) ? i : Object])], S)
    }, 52309: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 52562: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 52849: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringSeparator = void 0, function (e) {
        e.Comma = ",", e.Dot = ".", e.VerticalLine = "|"
      }(r || (t.StringSeparator = r = {}))
    }, 53684: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeTransformerNamesGroupsBuilder = void 0;
      const n = r(45337), i = r(87652);
      let a = class extends i.AbstractTransformerNamesGroupsBuilder {
      };
      t.NodeTransformerNamesGroupsBuilder = a, t.NodeTransformerNamesGroupsBuilder = a = o([(0, n.injectable)()], a)
    }, 53758: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 53856: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ClassFieldTransformer = void 0;
      const l = r(45337), d = r(31391), p = r(76393), u = r(31142), f = r(75716), m = r(13245), g = r(93571),
        h = r(27391);
      let y = o = class extends m.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === f.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && (h.NodeGuards.isMethodDefinitionNode(e) || h.NodeGuards.isPropertyDefinitionNode(e))) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          return h.NodeGuards.isIdentifierNode(e.key) ? this.replaceIdentifierKey(e, e.key) : h.NodeGuards.isLiteralNode(e.key) ? this.replaceLiteralKey(e, e.key) : e
        }

        replaceIdentifierKey(e, t) {
          return o.ignoredNames.includes(t.name) || e.computed || (e.computed = !0, e.key = g.NodeFactory.literalNode(t.name)), e
        }

        replaceLiteralKey(e, t) {
          return "string" != typeof t.value || o.ignoredNames.includes(t.value) || e.computed || (e.computed = !0), e
        }
      };
      t.ClassFieldTransformer = y, y.ignoredNames = ["constructor"], t.ClassFieldTransformer = y = o = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (n = void 0 !== u.IRandomGenerator && u.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== p.IOptions && p.IOptions) ? i : Object])], y)
    }, 54494: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.GlobalVariableServiceWorkerTemplate = function () {
        return "const that = typeof global === 'object' ? global : this;"
      }
    }, 54651: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMClassBytecodeCompiler = void 0;
      const s = r(45337), c = r(20924), l = r(31391), d = r(27391), p = r(93571), u = r(25115), f = r(59805);
      let m = class {
        constructor(e) {
          this.vmCompilerUtils = e
        }

        compileClassDeclaration(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          if (this.compileClassCommon(e, t), e.id) {
            const i = e.id.name;
            if (null === (r = t.topLevelVariables) || void 0 === r ? void 0 : r.has(i)) n.storeGlobalByName(i); else {
              const e = (0, f.getScopedVariableName)(i, t.blockScopeDepth),
                r = this.vmCompilerUtils.getNextLocalIndex(t);
              if (t.localVariables.set(e, r), t.variableScopes.set(e, {
                depth: t.blockScopeDepth,
                index: r
              }), null === (o = t.activeBlockScopes) || void 0 === o || o.add(e), t.envVars.has(i)) {
                const r = t.blockScopeDepth > 1 ? e : i, o = t.constantPool.add(r);
                n.storeToCurrentEnv(o)
              } else {
                const e = this.vmCompilerUtils.getActualLocalIndex(r, t);
                n.storeLocal(e)
              }
            }
          }
        }

        compileClassExpression(e, t) {
          const r = this.vmCompilerUtils.createInstructionBuilder(t);
          let o, n;
          if (e.id) {
            const r = e.id.name;
            o = `__classExpr_${r}_${t.nextBytecodeId++}__`, n = t.classExpressionNameAliases, t.classExpressionNameAliases = new Map(n), t.classExpressionNameAliases.set(r, o), t.envVars.add(o)
          }
          if (this.compileClassCommon(e, t), void 0 !== n ? t.classExpressionNameAliases = n : o && (t.classExpressionNameAliases = void 0), e.id) {
            const n = e.id.name;
            if (o) {
              const e = t.constantPool.add(o);
              r.dup(), r.storeToCurrentEnv(e)
            } else if (this.vmCompilerUtils.isEnvVariable(n, t)) {
              const e = t.constantPool.add(n);
              r.dup(), r.storeToEnv(e)
            } else {
              if (!t.localVariables.has(n)) {
                const e = t.localVariables.size;
                t.localVariables.set(n, e)
              }
              const e = t.localVariables.get(n), o = this.vmCompilerUtils.getActualLocalIndex(e, t);
              r.dup(), r.storeLocal(o)
            }
          }
        }

        compileClassCommon(e, t) {
          var r, o, n, i, a, s, c, l, f, m, g, h, y, S, N, b;
          const _ = this.vmCompilerUtils.createInstructionBuilder(t),
            v = e.body.body.find(e => d.NodeGuards.isMethodDefinitionNode(e) && "constructor" === e.kind),
            I = e.body.body.filter(e => d.NodeGuards.isPropertyDefinitionNode(e) && !e.static && !!e.value);
          if (v && d.NodeGuards.isFunctionExpressionNode(v.value)) {
            const o = this.injectInstanceFieldsIntoConstructor(v.value, I, Boolean(e.superClass));
            null === (r = t.dispatch) || void 0 === r || r.expression(o)
          } else if (I.length > 0) {
            const r = this.createConstructorWithInstanceFields(I, Boolean(e.superClass));
            null === (o = t.dispatch) || void 0 === o || o.expression(r)
          } else if (e.superClass) {
            const e = this.createConstructorWithInstanceFields([], !0);
            null === (n = t.dispatch) || void 0 === n || n.expression(e)
          } else _.pushUndefined();
          if (e.id) {
            const r = t.constantPool.add(e.id.name);
            _.loadConstByIndex(r)
          } else _.pushNull();
          const O = e.superClass ? 1 : 0;
          _.emitRaw({
            op: u.VMOpCode.NEW_CLASS,
            arg: O
          }), e.superClass && (null === (i = t.dispatch) || void 0 === i || i.expression(e.superClass), _.dup(), _.storeGlobalByName("__$$super$$__"), _.pop(), _.emitRaw({
            op: u.VMOpCode.CLASS_EXTENDS,
            arg: 0
          }));
          const C = e.body.body.some(e => d.NodeGuards.isStaticBlockNode(e)),
            E = e.body.body.some(e => d.NodeGuards.isPropertyDefinitionNode(e) && e.static && e.value);
          if (e.id && (C || E)) {
            const r = e.id.name;
            _.dup();
            const o = null === (a = t.classExpressionNameAliases) || void 0 === a ? void 0 : a.get(r);
            if (o) {
              const e = t.constantPool.add(o);
              _.storeToCurrentEnv(e)
            } else if (t.envVars.has(r)) {
              const e = t.constantPool.add(r);
              _.storeToCurrentEnv(e)
            } else {
              if (!t.localVariables.has(r)) {
                const e = Math.max(-1, ...Array.from(t.localVariables.values())) + 1;
                t.localVariables.set(r, e)
              }
              const e = t.localVariables.get(r), o = this.vmCompilerUtils.getActualLocalIndex(e, t);
              _.storeLocal(o)
            }
          }
          for (const r of e.body.body) {
            if (d.NodeGuards.isStaticBlockNode(r)) {
              _.dup();
              const e = p.NodeFactory.functionExpressionNode([], p.NodeFactory.blockStatementNode(r.body));
              null === (s = t.dispatch) || void 0 === s || s.expression(e), _.loadConst(0), _.callMethod(0), _.pop();
              continue
            }
            if (d.NodeGuards.isPropertyDefinitionNode(r)) {
              if (r.static && r.value) if (_.dup(), null === (c = t.dispatch) || void 0 === c || c.expression(r.value), r.computed) _.pop(), _.pop(); else {
                const e = this.getPropertyName(r);
                if (!e) {
                  _.pop(), _.pop();
                  continue
                }
                const o = t.constantPool.add(e);
                _.setProperty(o), _.pop()
              }
            } else if (d.NodeGuards.isMethodDefinitionNode(r) && "constructor" !== r.kind) if ("get" !== r.kind) {
              if ("set" !== r.kind) {
                if (d.NodeGuards.isFunctionExpressionNode(r.value)) if (r.computed) {
                  null === (S = t.dispatch) || void 0 === S || S.expression(r.key), null === (N = t.dispatch) || void 0 === N || N.expression(r.value);
                  const e = r.static ? u.VMOpCode.DEFINE_STATIC_METHOD_COMPUTED : u.VMOpCode.DEFINE_METHOD_COMPUTED;
                  _.emitRaw({ op: e })
                } else {
                  const e = this.getMethodName(r);
                  if (e) {
                    null === (b = t.dispatch) || void 0 === b || b.expression(r.value);
                    const o = t.constantPool.add(e),
                      n = r.static ? u.VMOpCode.DEFINE_STATIC_METHOD : u.VMOpCode.DEFINE_METHOD;
                    _.emitRaw({ op: n, arg: o })
                  }
                }
              } else if (d.NodeGuards.isFunctionExpressionNode(r.value)) if (r.computed) {
                null === (g = t.dispatch) || void 0 === g || g.expression(r.key), null === (h = t.dispatch) || void 0 === h || h.expression(r.value);
                const e = r.static ? u.VMOpCode.DEFINE_STATIC_SETTER_COMPUTED : u.VMOpCode.DEFINE_SETTER_COMPUTED;
                _.emitRaw({ op: e })
              } else {
                const e = this.getMethodName(r);
                if (e) {
                  null === (y = t.dispatch) || void 0 === y || y.expression(r.value);
                  const o = t.constantPool.add(e),
                    n = r.static ? u.VMOpCode.DEFINE_STATIC_SETTER : u.VMOpCode.DEFINE_SETTER;
                  _.emitRaw({ op: n, arg: o })
                }
              }
            } else if (d.NodeGuards.isFunctionExpressionNode(r.value)) if (r.computed) {
              null === (l = t.dispatch) || void 0 === l || l.expression(r.key), null === (f = t.dispatch) || void 0 === f || f.expression(r.value);
              const e = r.static ? u.VMOpCode.DEFINE_STATIC_GETTER_COMPUTED : u.VMOpCode.DEFINE_GETTER_COMPUTED;
              _.emitRaw({ op: e })
            } else {
              const e = this.getMethodName(r);
              if (e) {
                null === (m = t.dispatch) || void 0 === m || m.expression(r.value);
                const o = t.constantPool.add(e),
                  n = r.static ? u.VMOpCode.DEFINE_STATIC_GETTER : u.VMOpCode.DEFINE_GETTER;
                _.emitRaw({ op: n, arg: o })
              }
            }
          }
        }

        getMemberName(e) {
          const t = e.key;
          return d.NodeGuards.isIdentifierNode(t) && !e.computed ? t.name : d.NodeGuards.isLiteralNode(t) && "string" == typeof t.value ? t.value : null
        }

        getMethodName(e) {
          return this.getMemberName(e)
        }

        getPropertyName(e) {
          return this.getMemberName(e)
        }

        createFieldInitStatements(e) {
          return e.map(e => {
            if (!e.value || e.computed) return null;
            const t = this.getPropertyName(e);
            return t ? p.NodeFactory.expressionStatementNode(p.NodeFactory.assignmentExpressionNode("=", p.NodeFactory.memberExpressionNode(p.NodeFactory.thisExpressionNode(), p.NodeFactory.identifierNode(t)), e.value)) : null
          }).filter(e => null !== e)
        }

        injectInstanceFieldsIntoConstructor(e, t, r) {
          if (0 === t.length) return e;
          const o = this.createFieldInitStatements(t);
          if (0 === o.length) return e;
          const n = e.body.body;
          let i;
          if (r) {
            const e = n.findIndex(e => d.NodeGuards.isExpressionStatementNode(e) && d.NodeGuards.isCallExpressionNode(e.expression) && d.NodeGuards.isSuperNode(e.expression.callee));
            i = -1 !== e ? [...n.slice(0, e + 1), ...o, ...n.slice(e + 1)] : [...o, ...n]
          } else i = [...o, ...n];
          return { ...e, body: { ...e.body, body: i } }
        }

        createConstructorWithInstanceFields(e, t) {
          const r = this.createFieldInitStatements(e);
          let o;
          return o = t ? [p.NodeFactory.expressionStatementNode(p.NodeFactory.callExpressionNode(p.NodeFactory.superNode(), [p.NodeFactory.spreadElementNode(p.NodeFactory.identifierNode("arguments"))])), ...r] : r, p.NodeFactory.functionExpressionNode([], p.NodeFactory.blockStatementNode(o))
        }
      };
      t.VMClassBytecodeCompiler = m, t.VMClassBytecodeCompiler = m = n([(0, s.injectable)(), a(0, (0, s.inject)(l.ServiceIdentifiers.IVMCompilerUtils)), i("design:paramtypes", ["function" == typeof (o = void 0 !== c.IVMCompilerUtils && c.IVMCompilerUtils) ? o : Object])], m)
    }, 54867: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallsWrapperCodeHelper = void 0;
      const u = r(45337), f = r(31391), m = r(18741), g = r(39032), h = r(25714), y = r(45316), S = r(76393),
        N = r(31142), b = r(50164), _ = r(7754), v = r(85406), I = r(48222), O = r(33056);
      let C = class extends I.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n, i) {
          super(e, t, r, o, n), this.escapeSequenceEncoder = i
        }

        initialize(e, t, r) {
          this.stringArrayFunctionName = e, this.stringArrayCallsWrapperName = t, this.indexShiftAmount = r, this.stringArrayCacheName = this.randomGenerator.getRandomString(6)
        }

        getNodeStructure(e) {
          return O.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          const e = this.getDecodeStringArrayTemplate(), t = [`^${this.stringArrayFunctionName}$`];
          return this.customCodeHelperObfuscator.obfuscateTemplate(this.customCodeHelperFormatter.formatTemplate((0, v.StringArrayCallsWrapperTemplate)(), {
            decodeCodeHelperTemplate: e,
            stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,
            stringArrayFunctionName: this.stringArrayFunctionName,
            indexShiftAmount: this.indexShiftAmount
          }), { reservedNames: t })
        }

        getDecodeStringArrayTemplate() {
          return ""
        }

        getSelfDefendingTemplate() {
          return this.options.selfDefending ? this.customCodeHelperFormatter.formatTemplate((0, _.SelfDefendingTemplate)(this.randomGenerator, this.escapeSequenceEncoder), { stringArrayCallsWrapperName: this.stringArrayCallsWrapperName }) : ""
        }
      };
      t.StringArrayCallsWrapperCodeHelper = C, l([(0, b.initializable)(), d("design:type", Number)], C.prototype, "indexShiftAmount", void 0), l([(0, b.initializable)(), d("design:type", String)], C.prototype, "stringArrayCallsWrapperName", void 0), l([(0, b.initializable)(), d("design:type", String)], C.prototype, "stringArrayFunctionName", void 0), l([(0, b.initializable)(), d("design:type", String)], C.prototype, "stringArrayCacheName", void 0), t.StringArrayCallsWrapperCodeHelper = C = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperFormatter)), p(2, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperObfuscator)), p(3, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(4, (0, u.inject)(f.ServiceIdentifiers.IOptions)), p(5, (0, u.inject)(f.ServiceIdentifiers.IEscapeSequenceEncoder)), d("design:paramtypes", ["function" == typeof (o = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== g.ICustomCodeHelperFormatter && g.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== h.ICustomCodeHelperObfuscator && h.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== N.IRandomGenerator && N.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== S.IOptions && S.IOptions) ? s : Object, "function" == typeof (c = void 0 !== y.IEscapeSequenceEncoder && y.IEscapeSequenceEncoder) ? c : Object])], C)
    }, 54960: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ThroughIdentifierReplacer = void 0;
      const c = r(45337), l = r(31391), d = r(10808), p = r(76393), u = r(93571);
      let f = class {
        constructor(e, t) {
          this.identifierNamesCacheStorage = e, this.options = t
        }

        replace(e) {
          var t;
          const r = e.name,
            o = this.options.identifierNamesCache && !this.isReservedName(r) && null !== (t = this.identifierNamesCacheStorage.get(r)) && void 0 !== t ? t : r;
          return u.NodeFactory.identifierNode(o)
        }

        isReservedName(e) {
          return !!this.options.reservedNames.length && this.options.reservedNames.some(t => null !== new RegExp(t, "g").exec(e))
        }
      };
      t.ThroughIdentifierReplacer = f, t.ThroughIdentifierReplacer = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IGlobalIdentifierNamesCacheStorage)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== d.IGlobalIdentifierNamesCacheStorage && d.IGlobalIdentifierNamesCacheStorage) ? o : Object, "function" == typeof (n = void 0 !== p.IOptions && p.IOptions) ? n : Object])], f)
    }, 54966: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMCallCompiler = void 0;
      const a = r(45337), s = r(20924), c = r(31391), l = r(27391), d = r(25115);
      let p = class {
        compileCallExpression(e, t) {
          "CallExpression" === e.type && e.optional ? this.compileOptionalCall(e, t) : l.NodeGuards.isMemberExpressionNode(e.callee) ? this.compileMethodCall(e, t) : this.compileFunctionCall(e, t)
        }

        compileNewExpression(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          l.NodeGuards.isSuperNode(e.callee) ? o.pushUndefined() : (null === (r = t.dispatch) || void 0 === r || r.expression(e.callee), this.emitCallArguments(e.arguments, t), o.loadConst(e.arguments.length), o.callNew(e.arguments.length))
        }

        containsAssignmentExpression(e) {
          return !!l.NodeGuards.isAssignmentExpressionNode(e) || !(!l.NodeGuards.isMemberExpressionNode(e) || l.NodeGuards.isSuperNode(e.object)) && this.containsAssignmentExpression(e.object)
        }

        compileMethodCall(e, t) {
          var r, o, n, i, a;
          const s = this.vmCompilerUtils.createInstructionBuilder(t), c = e.callee;
          if (l.NodeGuards.isSuperNode(c.object)) {
            if (this.emitCallArguments(e.arguments, t), s.this(), s.dup(), c.computed) null === (r = t.dispatch) || void 0 === r || r.expression(c.property); else if (l.NodeGuards.isIdentifierNode(c.property)) {
              const e = t.constantPool.add(c.property.name);
              s.loadConstByIndex(e)
            }
            return s.emitRaw({
              op: d.VMOpCode.GET_SUPER_PROP,
              arg: 0
            }), s.loadConst(e.arguments.length), void s.callMethod(e.arguments.length)
          }
          if (this.containsAssignmentExpression(c.object)) {
            if (null === (i = t.dispatch) || void 0 === i || i.expression(c.object), s.dup(), c.computed) null === (a = t.dispatch) || void 0 === a || a.expression(c.property), s.getComputed(); else if (l.NodeGuards.isIdentifierNode(c.property)) {
              const e = t.constantPool.add(c.property.name);
              s.getPropertyByName(e)
            }
            if (e.arguments.length > 0) {
              const r = Math.max(t.localVariables.size, t.maxLocals), o = t.parameters.size + r,
                n = t.parameters.size + r + 1;
              t.maxLocals = r + 2, s.storeLocal(o), s.storeLocal(n), this.emitCallArguments(e.arguments, t), s.loadLocal(n), s.loadLocal(o)
            }
            s.loadConst(e.arguments.length), s.callMethod(e.arguments.length)
          } else {
            if (this.emitCallArguments(e.arguments, t), null === (o = t.dispatch) || void 0 === o || o.expression(c.object), s.dup(), c.computed) null === (n = t.dispatch) || void 0 === n || n.expression(c.property), s.getComputed(); else if (l.NodeGuards.isIdentifierNode(c.property)) {
              const e = t.constantPool.add(c.property.name);
              s.getPropertyByName(e)
            }
            s.loadConst(e.arguments.length), s.callMethod(e.arguments.length)
          }
        }

        compileFunctionCall(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          if (l.NodeGuards.isSuperNode(e.callee)) return o.loadGlobalByName("__$$constructor$$__"), o.getProp("__$$super$$__"), this.emitCallArguments(e.arguments, t), o.loadConst(e.arguments.length), void o.emitRaw({
            op: d.VMOpCode.SUPER_CALL,
            arg: 0
          });
          this.emitCallArguments(e.arguments, t), null === (r = t.dispatch) || void 0 === r || r.expression(e.callee), o.loadConst(e.arguments.length), o.call(e.arguments.length)
        }

        compileOptionalCall(e, t) {
          var r, o, n;
          const i = this.vmCompilerUtils.createInstructionBuilder(t);
          if (l.NodeGuards.isMemberExpressionNode(e.callee)) {
            const n = e.callee;
            if (this.emitCallArguments(e.arguments, t), "Super" === n.object.type) return void i.pushUndefined();
            if (null === (r = t.dispatch) || void 0 === r || r.expression(n.object), i.dup(), n.computed) {
              if ("PrivateIdentifier" === n.property.type) return void i.pushUndefined();
              null === (o = t.dispatch) || void 0 === o || o.expression(n.property), n.optional ? i.getComputedOptional() : i.getComputed()
            } else if (l.NodeGuards.isIdentifierNode(n.property)) {
              const e = t.constantPool.add(n.property.name),
                r = n.optional ? d.VMOpCode.GET_OPTIONAL : d.VMOpCode.GET_PROP;
              i.emitRaw({ op: r, arg: e })
            }
            this.emitOptionalCallWithFallback(e.arguments.length, !0, 1, t)
          } else {
            if (this.emitCallArguments(e.arguments, t), "Super" === e.callee.type) return void i.pushUndefined();
            null === (n = t.dispatch) || void 0 === n || n.expression(e.callee), this.emitOptionalCallWithFallback(e.arguments.length, !1, 0, t)
          }
        }

        emitCallArguments(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          for (const i of e) l.NodeGuards.isSpreadElementNode(i) ? (null === (r = t.dispatch) || void 0 === r || r.expression(i.argument), n.spread()) : null === (o = t.dispatch) || void 0 === o || o.expression(i)
        }

        emitOptionalCallWithFallback(e, t, r, o) {
          const n = this.vmCompilerUtils.createInstructionBuilder(o);
          n.dup(), n.pushUndefined(), n.strictEqual();
          const i = n.jumpIfTrue();
          n.loadConst(e), t ? n.callMethod(e) : n.call(e);
          const a = n.jump();
          i.patchToHere(), n.pop();
          for (let e = 0; e < r; e++) n.pop();
          for (let t = 0; t < e; t++) n.pop();
          n.pushUndefined(), a.patchToHere()
        }
      };
      t.VMCallCompiler = p, n([(0, a.inject)(c.ServiceIdentifiers.IVMCompilerUtils), i("design:type", "function" == typeof (o = void 0 !== s.IVMCompilerUtils && s.IVMCompilerUtils) ? o : Object)], p.prototype, "vmCompilerUtils", void 0), t.VMCallCompiler = p = n([(0, a.injectable)()], p)
    }, 55054: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionKeysTransformerCustomNode = void 0, function (e) {
        e.ObjectExpressionVariableDeclarationHostNode = "ObjectExpressionVariableDeclarationHostNode"
      }(r || (t.ObjectExpressionKeysTransformerCustomNode = r = {}))
    }, 55066: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallControlFlowReplacer = void 0;
      const p = r(45337), u = r(31391), f = r(46300), m = r(18741), g = r(76393), h = r(31142), y = r(62059),
        S = r(47074), N = r(27391), b = r(45261), _ = r(4592);
      let v = o = class extends S.AbstractControlFlowReplacer {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        replace(e, t, r) {
          if (!_.NodeMetadata.isStringArrayCallLiteralNode(e) || !b.NodeLiteralUtils.isNumberLiteralNode(e) && !b.NodeLiteralUtils.isStringLiteralNode(e)) return e;
          const n = e.value, i = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.LiteralNode);
          i.initialize(e);
          const a = this.insertCustomNodeToControlFlowStorage(i, r, n, o.usingExistingIdentifierChance);
          return this.getControlFlowStorageCallNode(r.getStorageId(), a)
        }

        generateStorageKey(e) {
          const t = this.identifierNamesGenerator.generateForLabel(e.getStorageId());
          return e.has(t) ? this.generateStorageKey(e) : t
        }

        getControlFlowStorageCallNode(e, t) {
          const r = this.controlFlowCustomNodeFactory(y.ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);
          r.initialize(e, t);
          const o = r.getNode()[0];
          if (!o || !N.NodeGuards.isExpressionStatementNode(o)) throw new Error("`controlFlowStorageCallCustomNode.getNode()[0]` should returns array with `ExpressionStatement` node");
          return o.expression
        }
      };
      t.StringArrayCallControlFlowReplacer = v, v.usingExistingIdentifierChance = .5, t.StringArrayCallControlFlowReplacer = v = o = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IControlFlowCustomNode)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (n = void 0 !== f.TControlFlowCustomNodeFactory && f.TControlFlowCustomNodeFactory) ? n : Object, "function" == typeof (i = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? i : Object, "function" == typeof (a = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== g.IOptions && g.IOptions) ? s : Object])], v)
    }, 55194: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.alphabetString = void 0, t.alphabetString = "abcdefghijklmnopqrstuvwxyz"
    }, 55208: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.RenamePropertiesTransformer = void 0;
      const d = r(45337), p = r(31391), u = r(19714), f = r(76393), m = r(31142), g = r(75716), h = r(68289),
        y = r(13245), S = r(27391), N = r(45261), b = r(4592);
      let _ = o = class extends y.AbstractNodeTransformer {
        constructor(e, t, r) {
          super(t, r), this.renamePropertiesReplacer = e
        }

        static isValidPropertyNode(e, t) {
          return !S.NodeGuards.isIdentifierNode(t) || !e.computed
        }

        getVisitor(e) {
          switch (e) {
            case g.NodeTransformationStage.Preparing:
              return {
                enter: (e, t) => {
                  t && this.prepareNode(e, t)
                }
              };
            case g.NodeTransformationStage.RenameProperties:
              return {
                enter: (e, t) => {
                  if (t) return this.transformNode(e, t)
                }
              };
            default:
              return null
          }
        }

        prepareNode(e, t) {
          S.NodeGuards.isPropertyNode(t) && t.key === e || S.NodeGuards.isMemberExpressionNode(t) && t.property === e || S.NodeGuards.isMethodDefinitionNode(t) && t.key === e || S.NodeGuards.isPropertyDefinitionNode(t) && t.key === e ? b.NodeMetadata.set(e, { propertyKeyToRenameNode: !0 }) : this.options.renamePropertiesMode === h.RenamePropertiesMode.Safe && this.analyzeAutoExcludedPropertyNames(e, t)
        }

        transformNode(e, t) {
          if (!S.NodeGuards.isIdentifierNode(e) && !S.NodeGuards.isLiteralNode(e)) return e;
          if (!b.NodeMetadata.isPropertyKeyToRenameNode(e)) return e;
          const r = S.NodeGuards.isPropertyNode(t);
          return (r || S.NodeGuards.isPropertyDefinitionNode(t) || S.NodeGuards.isMemberExpressionNode(t) || S.NodeGuards.isMethodDefinitionNode(t)) && !o.isValidPropertyNode(t, e) ? e : (r && (t.shorthand = !1), this.renamePropertiesReplacer.replace(e))
        }

        analyzeAutoExcludedPropertyNames(e, t) {
          S.NodeGuards.isLiteralNode(e) && N.NodeLiteralUtils.isStringLiteralNode(e) && this.renamePropertiesReplacer.excludePropertyName(e.value)
        }
      };
      t.RenamePropertiesTransformer = _, t.RenamePropertiesTransformer = _ = o = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.IRenamePropertiesReplacer)), l(1, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(2, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (n = void 0 !== u.IRenamePropertiesReplacer && u.IRenamePropertiesReplacer) ? n : Object, "function" == typeof (i = void 0 !== m.IRandomGenerator && m.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== f.IOptions && f.IOptions) ? a : Object])], _)
    }, 55253: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      }, c = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.Logger = void 0;
      const l = r(45337), d = r(31391), p = c(r(96895)), u = r(76393), f = r(85183);
      let m = o = class {
        constructor(e) {
          this.options = e
        }

        static log(e, t, r, o) {
          const n = e(`\n${t} ${r}`);
          console.log(n, null != o ? o : "")
        }

        info(e, t) {
          this.options.log && o.log(o.colorInfo, f.LoggingPrefix.Base, e, t)
        }

        success(e, t) {
          this.options.log && o.log(o.colorSuccess, f.LoggingPrefix.Base, e, t)
        }

        warn(e, t) {
          this.options.log && o.log(o.colorWarn, f.LoggingPrefix.Base, e, t)
        }
      };
      t.Logger = m, m.colorInfo = p.default.cyan, m.colorSuccess = p.default.green, m.colorWarn = p.default.yellow, t.Logger = m = o = i([(0, l.injectable)(), s(0, (0, l.inject)(d.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (n = void 0 !== u.IOptions && u.IOptions) ? n : Object])], m)
    }, 55668: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 55842: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomCodeHelperObfuscator = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(6335), f = r(61801);
      let m = class {
        constructor(e, t) {
          this.randomGenerator = e, this.options = t
        }

        obfuscateTemplate(e, t = {}) {
          return f.JavaScriptObfuscator.obfuscate(e, {
            ...u.NO_ADDITIONAL_NODES_PRESET,
            identifierNamesGenerator: this.options.identifierNamesGenerator,
            identifiersDictionary: this.options.identifiersDictionary,
            numbersToExpressions: this.options.numbersToExpressions,
            simplify: this.options.simplify,
            seed: this.randomGenerator.getRawSeed(), ...t
          }).getObfuscatedCode()
        }
      };
      t.CustomCodeHelperObfuscator = m, t.CustomCodeHelperObfuscator = m = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], m)
    }, 55866: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SelfDefendingTemplate = function () {
        return "\n        const {selfDefendingFunctionName} = {callControllerFunctionName}(this, function () {\n            return {selfDefendingFunctionName}\n                .toString()\n                .search('(((.+)+)+)+$')\n                .toString()\n                .constructor({selfDefendingFunctionName})\n                .search('(((.+)+)+)+$');\n        });\n        \n        {selfDefendingFunctionName}();\n    "
      }
    }, 56012: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 56651: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCodeHelper = void 0;
      const u = r(45337), f = r(31391), m = r(18741), g = r(39032), h = r(25714), y = r(76393), S = r(31142),
        N = r(28523), b = r(50164), _ = r(69904), v = r(48222), I = r(33056), O = r(49804);
      let C = class extends v.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t) {
          this.stringArrayStorage = e, this.stringArrayFunctionName = t
        }

        getNodeStructure(e) {
          return I.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          const e = this.identifierNamesGenerator.generateNext();
          return this.customCodeHelperFormatter.formatTemplate((0, _.StringArrayTemplate)(), {
            stringArrayFunctionName: this.stringArrayFunctionName,
            stringArrayName: e,
            stringArrayStorageItems: this.getEncodedStringArrayStorageItems()
          })
        }

        getEncodedStringArrayStorageItems() {
          return Array.from(this.stringArrayStorage.getStorage().values()).map(e => `'${O.StringUtils.escapeJsString(e.encodedValue)}'`).toString()
        }
      };
      t.StringArrayCodeHelper = C, l([(0, b.initializable)(), d("design:type", "function" == typeof (c = void 0 !== N.IStringArrayStorage && N.IStringArrayStorage) ? c : Object)], C.prototype, "stringArrayStorage", void 0), l([(0, b.initializable)(), d("design:type", String)], C.prototype, "stringArrayFunctionName", void 0), t.StringArrayCodeHelper = C = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperFormatter)), p(2, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperObfuscator)), p(3, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(4, (0, u.inject)(f.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (o = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== g.ICustomCodeHelperFormatter && g.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== h.ICustomCodeHelperObfuscator && h.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== y.IOptions && y.IOptions) ? s : Object])], C)
    }, 56653: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CallExpressionControlFlowStorageCallNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(50164),
        y = r(8053), S = r(93571), N = r(33056);
      let b = class extends y.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t, r, o) {
          this.controlFlowStorageName = e, this.controlFlowStorageKey = t, this.callee = r, this.expressionArguments = o
        }

        getNodeStructure() {
          const e = S.NodeFactory.expressionStatementNode(S.NodeFactory.callExpressionNode(S.NodeFactory.memberExpressionNode(S.NodeFactory.identifierNode(this.controlFlowStorageName), S.NodeFactory.identifierNode(this.controlFlowStorageKey)), [this.callee, ...this.expressionArguments]));
          return N.NodeUtils.parentizeAst(e), [e]
        }
      };
      t.CallExpressionControlFlowStorageCallNode = b, s([(0, h.initializable)(), c("design:type", Object)], b.prototype, "callee", void 0), s([(0, h.initializable)(), c("design:type", String)], b.prototype, "controlFlowStorageKey", void 0), s([(0, h.initializable)(), c("design:type", String)], b.prototype, "controlFlowStorageName", void 0), s([(0, h.initializable)(), c("design:type", Array)], b.prototype, "expressionArguments", void 0), t.CallExpressionControlFlowStorageCallNode = b = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], b)
    }, 56684: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMConditionalCompiler = void 0;
      const s = r(45337), c = r(20924), l = r(94487), d = r(31391), p = r(25115), u = r(27391);
      let f = class {
        compileIfStatement(e, t) {
          var r, o, n;
          null === (r = t.dispatch) || void 0 === r || r.expression(e.test);
          const i = this.vmCompilerUtils.emitConditionalJump(p.VMOpCode.JUMP_IF_FALSE, t);
          if (null === (o = t.dispatch) || void 0 === o || o.statement(e.consequent), e.alternate) {
            const r = this.vmCompilerUtils.emitConditionalJump(p.VMOpCode.JUMP, t);
            this.vmCompilerUtils.patchJump(i, t), null === (n = t.dispatch) || void 0 === n || n.statement(e.alternate), this.vmCompilerUtils.patchJump(r, t)
          } else this.vmCompilerUtils.patchJump(i, t)
        }

        compileSwitchStatement(e, t) {
          var r;
          null === (r = t.dispatch) || void 0 === r || r.expression(e.discriminant);
          const {
            localIndex: o,
            actualIndex: n
          } = this.vmCompilerUtils.createTempLocal(`__switch_temp_${t.localVariables.size}`, t);
          this.vmCompilerUtils.createInstructionBuilder(t).storeLocal(n);
          const i = [], a = [], {
              defaultCaseIndex: s,
              defaultJumpIndex: c
            } = this.compileSwitchCaseComparisons(e.cases, o, a, t), l = this.compileSwitchCaseBodies(e.cases, i, t),
            d = t.instructions.length;
          this.patchSwitchJumpTargets(a, i, s, c, l, d, t)
        }

        compileSwitchCaseComparisons(e, t, r, o) {
          var n;
          const i = this.vmCompilerUtils.createInstructionBuilder(o);
          let a = -1;
          for (let s = 0; s < e.length; s++) {
            const c = e[s];
            if (null === c.test) {
              a = s;
              continue
            }
            const l = this.vmCompilerUtils.getActualLocalIndex(t, o);
            i.loadLocal(l), null === (n = o.dispatch) || void 0 === n || n.expression(c.test), i.strictEqual();
            const d = i.jumpIfTrue();
            r.push(d.getIndex()), d.patchTo(-1)
          }
          const s = i.jump(), c = s.getIndex();
          return s.patchTo(-1), { defaultCaseIndex: a, defaultJumpIndex: c }
        }

        compileSwitchCaseBodies(e, t, r) {
          var o;
          const n = r.instructions.length;
          r.breakTargets.push(n), r.breakEnvDepths.push(r.envDepth);
          const i = this.scanSwitchCasesForLexicalDeclarations(e);
          i.size > 0 && this.scopeManager.enterLocalsTDZ(r, [...i]);
          const a = this.vmCompilerUtils.createInstructionBuilder(r);
          for (const e of i) r.envVars.has(e) && a.declareTDZ(e);
          for (let n = 0; n < e.length; n++) {
            const i = e[n];
            t[n] = r.instructions.length;
            for (const e of i.consequent) null === (o = r.dispatch) || void 0 === o || o.statement(e)
          }
          return r.breakTargets.pop(), r.breakEnvDepths.pop(), n
        }

        scanSwitchCasesForLexicalDeclarations(e) {
          const t = new Set;
          for (const r of e) for (const e of r.consequent) if (u.NodeGuards.isVariableDeclarationNode(e) && ("let" === e.kind || "const" === e.kind)) for (const r of e.declarations) if (u.NodeGuards.isIdentifierNode(r.id)) t.add(r.id.name); else if (u.NodeGuards.isArrayPatternNode(r.id) || u.NodeGuards.isObjectPatternNode(r.id)) for (const e of this.vmCompilerUtils.extractIdentifiersFromPattern(r.id)) t.add(e);
          return t
        }

        patchSwitchJumpTargets(e, t, r, o, n, i, a) {
          for (let o = 0; o < e.length; o++) {
            const n = e[o];
            let i = o;
            -1 !== r && o >= r && i++, a.instructions[n].target = t[i]
          }
          a.instructions[o].target = -1 !== r ? t[r] : i, this.vmCompilerUtils.patchJumpTargets(n, i, n, i, a)
        }
      };
      t.VMConditionalCompiler = f, i([(0, s.inject)(d.ServiceIdentifiers.IVMCompilerUtils), a("design:type", "function" == typeof (o = void 0 !== c.IVMCompilerUtils && c.IVMCompilerUtils) ? o : Object)], f.prototype, "vmCompilerUtils", void 0), i([(0, s.inject)(d.ServiceIdentifiers.IVMScopeManager), a("design:type", "function" == typeof (n = void 0 !== l.IVMScopeManager && l.IVMScopeManager) ? n : Object)], f.prototype, "scopeManager", void 0), t.VMConditionalCompiler = f = i([(0, s.injectable)()], f)
    }, 56831: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ConsoleOutputDisableCodeHelper = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(39032), g = r(25714), h = r(76393), y = r(31142),
        S = r(11688), N = r(50164), b = r(48222), _ = r(33056);
      let v = class extends b.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t) {
          this.callsControllerFunctionName = e, this.consoleOutputDisableFunctionName = t
        }

        getNodeStructure(e) {
          return _.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          return this.customCodeHelperFormatter.formatTemplate((0, S.ConsoleOutputDisableTemplate)(), {
            callControllerFunctionName: this.callsControllerFunctionName,
            consoleLogDisableFunctionName: this.consoleOutputDisableFunctionName,
            globalVariableTemplate: this.getGlobalVariableTemplate()
          })
        }
      };
      t.ConsoleOutputDisableCodeHelper = v, c([(0, N.initializable)(), l("design:type", String)], v.prototype, "callsControllerFunctionName", void 0), c([(0, N.initializable)(), l("design:type", String)], v.prototype, "consoleOutputDisableFunctionName", void 0), t.ConsoleOutputDisableCodeHelper = v = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperObfuscator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== h.IOptions && h.IOptions) ? s : Object])], v)
    }, 56869: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 57088: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SourceMapSourcesMode = void 0;
      const o = r(39079);
      t.SourceMapSourcesMode = o.Utils.makeEnum({ Sources: "sources", SourcesContent: "sources-content" })
    }, 57524: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.customNodesModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(62059), s = r(29154), c = r(55054), l = r(928),
        d = r(47129), p = r(677), u = r(68431), f = r(56653), m = r(40768), g = r(12731), h = r(2993), y = r(92037),
        S = r(6587), N = r(32840), b = r(66339), _ = r(16748), v = r(6062), I = r(1322), O = r(2566), C = r(40367),
        E = r(68351);
      t.customNodesModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(d.BinaryExpressionFunctionNode).whenTargetNamed(a.ControlFlowCustomNode.BinaryExpressionFunctionNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(p.BlockStatementControlFlowFlatteningNode).whenTargetNamed(a.ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(f.CallExpressionControlFlowStorageCallNode).whenTargetNamed(a.ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(m.CallExpressionFunctionNode).whenTargetNamed(a.ControlFlowCustomNode.CallExpressionFunctionNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(g.ControlFlowStorageNode).whenTargetNamed(a.ControlFlowCustomNode.ControlFlowStorageNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(h.ExpressionWithOperatorControlFlowStorageCallNode).whenTargetNamed(a.ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(E.LiteralNode).whenTargetNamed(a.ControlFlowCustomNode.LiteralNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(y.LogicalExpressionFunctionNode).whenTargetNamed(a.ControlFlowCustomNode.LogicalExpressionFunctionNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(C.StringLiteralControlFlowStorageCallNode).whenTargetNamed(a.ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(u.BlockStatementDeadCodeInjectionNode).whenTargetNamed(s.DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(S.ObjectExpressionVariableDeclarationHostNode).whenTargetNamed(c.ObjectExpressionKeysTransformerCustomNode.ObjectExpressionVariableDeclarationHostNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(N.StringArrayCallNode).whenTargetNamed(l.StringArrayCustomNode.StringArrayCallNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(I.StringArrayScopeCallsWrapperFunctionNode).whenTargetNamed(l.StringArrayCustomNode.StringArrayScopeCallsWrapperFunctionNode), e(i.ServiceIdentifiers.Newable__ICustomNode).toConstructor(O.StringArrayScopeCallsWrapperVariableNode).whenTargetNamed(l.StringArrayCustomNode.StringArrayScopeCallsWrapperVariableNode), e(i.ServiceIdentifiers.IStringArrayIndexNode).to(b.StringArrayHexadecimalNumberIndexNode).inSingletonScope().whenTargetNamed(v.StringArrayIndexNode.StringArrayHexadecimalNumberIndexNode), e(i.ServiceIdentifiers.IStringArrayIndexNode).to(_.StringArrayHexadecimalNumericStringIndexNode).inSingletonScope().whenTargetNamed(v.StringArrayIndexNode.StringArrayHexadecimalNumericStringIndexNode), e(i.ServiceIdentifiers.Factory__IControlFlowCustomNode).toFactory(o.InversifyContainerFacade.getConstructorFactory(i.ServiceIdentifiers.Newable__ICustomNode, i.ServiceIdentifiers.Factory__IIdentifierNamesGenerator, i.ServiceIdentifiers.ICustomCodeHelperFormatter, i.ServiceIdentifiers.IRandomGenerator, i.ServiceIdentifiers.IOptions)), e(i.ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode).toFactory(o.InversifyContainerFacade.getConstructorFactory(i.ServiceIdentifiers.Newable__ICustomNode, i.ServiceIdentifiers.Factory__IIdentifierNamesGenerator, i.ServiceIdentifiers.ICustomCodeHelperFormatter, i.ServiceIdentifiers.IRandomGenerator, i.ServiceIdentifiers.IOptions)), e(i.ServiceIdentifiers.Factory__IObjectExpressionKeysTransformerCustomNode).toFactory(o.InversifyContainerFacade.getConstructorFactory(i.ServiceIdentifiers.Newable__ICustomNode, i.ServiceIdentifiers.Factory__IIdentifierNamesGenerator, i.ServiceIdentifiers.ICustomCodeHelperFormatter, i.ServiceIdentifiers.IRandomGenerator, i.ServiceIdentifiers.IOptions)), e(i.ServiceIdentifiers.Factory__IStringArrayCustomNode).toFactory(o.InversifyContainerFacade.getConstructorFactory(i.ServiceIdentifiers.Newable__ICustomNode, i.ServiceIdentifiers.Factory__IIdentifierNamesGenerator, i.ServiceIdentifiers.Factory__IStringArrayIndexNode, i.ServiceIdentifiers.ICustomCodeHelperFormatter, i.ServiceIdentifiers.IStringArrayStorage, i.ServiceIdentifiers.IArrayUtils, i.ServiceIdentifiers.IRandomGenerator, i.ServiceIdentifiers.IOptions)), e(i.ServiceIdentifiers.Factory__IStringArrayIndexNode).toFactory(o.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.IStringArrayIndexNode))
      })
    }, 57798: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 57809: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 58188: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SingleCallControllerTemplate = function () {
        return "\n        const {callControllerFunctionName} = (function(){\n            let firstCall = true;\n            \n            return function (context, fn){\n                const rfn = firstCall ? function(){\n                    if(fn){\n                        const res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    "
      }
    }, 58544: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 59228: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NumberNumericalExpressionAnalyzer = void 0;
      const c = r(45337), l = r(31142), d = r(31391), p = r(24660);
      let u = o = class {
        constructor(e) {
          this.numberFactorsMap = new Map, this.randomGenerator = e
        }

        analyze(e, t) {
          if (isNaN(e)) throw new Error("Given value is NaN");
          return p.NumberUtils.isUnsafeNumber(e) ? [e] : this.generateAdditionParts(e, t).map(e => this.mixWithMultiplyParts(e))
        }

        generateAdditionParts(e, t) {
          const r = [], n = Math.min(Math.abs(2 * e), Number.MAX_SAFE_INTEGER), i = Math.min(-o.delta, -n),
            a = Math.max(o.delta, n);
          let s = 0;
          for (let o = 0; o < t; o++) if (o < t - 1) {
            let e = this.randomGenerator.getRandomInteger(i, a);
            p.NumberUtils.isUnsafeNumber(s + e) && (e = -e), r.push(e), s += e
          } else {
            const t = e - s;
            p.NumberUtils.isUnsafeNumber(t) ? (r.push(0 - s), r.push(e)) : r.push(t)
          }
          return r
        }

        mixWithMultiplyParts(e) {
          var t;
          if (!(this.randomGenerator.getMathRandom() > .5) || 0 === e) return e;
          let r = null !== (t = this.numberFactorsMap.get(e)) && void 0 !== t ? t : null;
          if (r || (r = p.NumberUtils.getFactors(e), this.numberFactorsMap.set(e, r)), !r.length) return e;
          const o = r[this.randomGenerator.getRandomInteger(0, r.length - 1)];
          return [o, e / o]
        }
      };
      t.NumberNumericalExpressionAnalyzer = u, u.defaultAdditionalPartsCount = 3, u.delta = 1e4, t.NumberNumericalExpressionAnalyzer = u = o = i([(0, c.injectable)(), s(0, (0, c.inject)(d.ServiceIdentifiers.IRandomGenerator)), a("design:paramtypes", ["function" == typeof (n = void 0 !== l.IRandomGenerator && l.IRandomGenerator) ? n : Object])], u)
    }, 59290: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 59405: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DeadCodeInjectionIdentifiersTransformer = void 0;
      const d = r(45337), p = r(31391), u = r(51353), f = r(76393), m = r(31142), g = r(57809), h = r(75716),
        y = r(13245), S = r(27391);
      let N = class extends y.AbstractNodeTransformer {
        constructor(e, t, r, o) {
          super(t, r), this.identifierReplacer = e, this.scopeIdentifiersTraverser = o
        }

        getVisitor(e) {
          return e === h.NodeTransformationStage.RenameIdentifiers ? {
            enter: (e, t) => {
              if (t && S.NodeGuards.isProgramNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          return this.scopeIdentifiersTraverser.traverseScopeThroughIdentifiers(e, t, e => {
            const { reference: t, variableLexicalScopeNode: r } = e;
            this.transformScopeThroughIdentifiers(t, r)
          }), e
        }

        transformScopeThroughIdentifiers(e, t) {
          if (e.resolved) return;
          const r = e.identifier;
          this.storeIdentifierName(r, t), this.replaceIdentifierName(r, t, e)
        }

        storeIdentifierName(e, t) {
          this.identifierReplacer.storeLocalName(e, t)
        }

        replaceIdentifierName(e, t, r) {
          const o = this.identifierReplacer.replace(e, t);
          r.identifier.name = o.name
        }
      };
      t.DeadCodeInjectionIdentifiersTransformer = N, t.DeadCodeInjectionIdentifiersTransformer = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.IIdentifierReplacer)), l(1, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(2, (0, d.inject)(p.ServiceIdentifiers.IOptions)), l(3, (0, d.inject)(p.ServiceIdentifiers.IScopeIdentifiersTraverser)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.IIdentifierReplacer && u.IIdentifierReplacer) ? o : Object, "function" == typeof (n = void 0 !== m.IRandomGenerator && m.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== f.IOptions && f.IOptions) ? i : Object, "function" == typeof (a = void 0 !== g.IScopeIdentifiersTraverser && g.IScopeIdentifiersTraverser) ? a : Object])], N)
    }, 59628: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeTransformersRunner = void 0;
      const u = r(45337), f = r(31391), m = l(r(31659)), g = r(56869), h = r(44966), y = r(37782), S = r(27391),
        N = r(4592);
      let b = class {
        constructor(e, t) {
          this.nodeTransformerFactory = e, this.nodeTransformerNamesGroupsBuilder = t
        }

        transform(e, t, r) {
          if (!t.length) return e;
          const o = this.buildNormalizedNodeTransformers(t, r), n = this.nodeTransformerNamesGroupsBuilder.build(o);
          for (const t of n) {
            const n = [], i = [];
            for (const e of t) {
              const t = o[e].getVisitor(r);
              t && (t.enter && n.push({ enter: t.enter }), t.leave && i.push({ leave: t.leave }))
            }
            (n.length || i.length) && m.replace(e, {
              enter: this.mergeVisitorsForDirection(n, y.VisitorDirection.Enter),
              leave: this.mergeVisitorsForDirection(i, y.VisitorDirection.Leave)
            })
          }
          return e
        }

        buildNormalizedNodeTransformers(e, t) {
          return e.reduce((e, r) => {
            const o = this.nodeTransformerFactory(r);
            return o.getVisitor(t) ? { ...e, [r]: o } : e
          }, {})
        }

        mergeVisitorsForDirection(e, t) {
          const r = e.length;
          return r ? (o, n) => {
            if (N.NodeMetadata.isIgnoredNode(o)) return m.VisitorOption.Skip;
            for (let i = 0; i < r; i++) {
              const r = e[i][t];
              if (!r) continue;
              const a = r(o, n);
              a && S.NodeGuards.isNode(a) && (o = a)
            }
            return o
          } : (e, t) => e
        }
      };
      t.NodeTransformersRunner = b, t.NodeTransformersRunner = b = c([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__INodeTransformer)), p(1, (0, u.inject)(f.ServiceIdentifiers.INodeTransformerNamesGroupsBuilder)), d("design:paramtypes", ["function" == typeof (n = void 0 !== g.TNodeTransformerFactory && g.TNodeTransformerFactory) ? n : Object, "function" == typeof (i = void 0 !== h.ITransformerNamesGroupsBuilder && h.ITransformerNamesGroupsBuilder) ? i : Object])], b)
    }, 59641: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getIndirectDispatchTemplate = t.getMacroOpcodeTemplates = t.getIteratorOpcodeTemplates = t.getSpecialOpcodeTemplates = t.getEnvironmentOpcodeTemplates = t.getArrayOpcodeTemplates = t.getFunctionOpcodeTemplates = t.getClassOpcodeTemplates = t.getObjectOpcodeTemplates = t.getExceptionOpcodeTemplates = t.getControlFlowOpcodeTemplates = t.getComparisonOpcodeTemplates = t.getBitwiseOpcodeTemplates = t.getArithmeticOpcodeTemplates = t.getStackOpcodeTemplates = void 0, t.getAllOpcodeCases = S, t.getAllOpcodeCasesForIndirectDispatch = function (e = !1) {
        return S(e).replace(/(\s+)return stack\.pop\(\);/g, "$1_vmDone = true; _vmReturnValue = stack.pop(); return;").replace(/(\s+)return returnValue;/g, "$1_vmDone = true; _vmReturnValue = returnValue; return;").replace(/(\s+)return stack\.length > 0 \? stack\.pop\(\) : undefined;/g, "$1_vmDone = true; _vmReturnValue = stack.length > 0 ? stack.pop() : undefined; return;")
      }, t.getSplitDispatcherCases = function (e = !1) {
        const t = (0, i.getBitwiseOpcodeTemplates)() + (0, a.getComparisonOpcodeTemplates)(),
          r = (0, u.getArrayOpcodeTemplates)() + (0, p.getFunctionOpcodeTemplates)(),
          y = (0, d.getClassOpcodeTemplates)() + (0, m.getSpecialOpcodeTemplates)(),
          S = (0, m.getSpecialOpcodeTemplates)() + (0, f.getEnvironmentOpcodeTemplates)();
        let b = `\n                            // Split dispatcher - route by opcode range\n                            ${N((0, o.getStackOpcodeTemplates)(), "logicalOp < 10", "Stack (0-9)")}${N((0, n.getArithmeticOpcodeTemplates)(), "logicalOp < 20", "Arithmetic (10-19)")}${N(t, "logicalOp < 50", "Bitwise & Logical & Comparison (20-49)")}${N((0, s.getControlFlowOpcodeTemplates)() + (0, c.getExceptionOpcodeTemplates)(), "logicalOp < 70", "Control Flow & Exception (50-69)")}${N((0, l.getObjectOpcodeTemplates)(), "logicalOp < 90", "Object/Property (70-89)")}${N(r, "logicalOp < 120", "Array & Function & Type (90-119)")}${N((0, g.getIteratorOpcodeTemplates)(), "logicalOp < 140", "Iterator/Generator (120-139)")}${N(y, "logicalOp < 200", "Class & Special (140-199)")}`;
        return b += e ? `${N(S, "logicalOp < 250", "Debug & Environment (200-249)")}${N((0, h.getMacroOpcodeTemplates)(), "logicalOp >= 250", "Macro Operations (250+)")}` : `${N(S, "logicalOp >= 200", "Debug & Environment (200+)")}`, b += "{\n                                throw new Error('Unknown opcode: ' + op + ' (logical: ' + logicalOp + ')');\n                            }\n    ", b
      };
      const o = r(87972);
      Object.defineProperty(t, "getStackOpcodeTemplates", {
        enumerable: !0, get: function () {
          return o.getStackOpcodeTemplates
        }
      });
      const n = r(21456);
      Object.defineProperty(t, "getArithmeticOpcodeTemplates", {
        enumerable: !0, get: function () {
          return n.getArithmeticOpcodeTemplates
        }
      });
      const i = r(60609);
      Object.defineProperty(t, "getBitwiseOpcodeTemplates", {
        enumerable: !0, get: function () {
          return i.getBitwiseOpcodeTemplates
        }
      });
      const a = r(90979);
      Object.defineProperty(t, "getComparisonOpcodeTemplates", {
        enumerable: !0, get: function () {
          return a.getComparisonOpcodeTemplates
        }
      });
      const s = r(67935);
      Object.defineProperty(t, "getControlFlowOpcodeTemplates", {
        enumerable: !0, get: function () {
          return s.getControlFlowOpcodeTemplates
        }
      });
      const c = r(21091);
      Object.defineProperty(t, "getExceptionOpcodeTemplates", {
        enumerable: !0, get: function () {
          return c.getExceptionOpcodeTemplates
        }
      });
      const l = r(46237);
      Object.defineProperty(t, "getObjectOpcodeTemplates", {
        enumerable: !0, get: function () {
          return l.getObjectOpcodeTemplates
        }
      });
      const d = r(7844);
      Object.defineProperty(t, "getClassOpcodeTemplates", {
        enumerable: !0, get: function () {
          return d.getClassOpcodeTemplates
        }
      });
      const p = r(23972);
      Object.defineProperty(t, "getFunctionOpcodeTemplates", {
        enumerable: !0, get: function () {
          return p.getFunctionOpcodeTemplates
        }
      });
      const u = r(36047);
      Object.defineProperty(t, "getArrayOpcodeTemplates", {
        enumerable: !0, get: function () {
          return u.getArrayOpcodeTemplates
        }
      });
      const f = r(4320);
      Object.defineProperty(t, "getEnvironmentOpcodeTemplates", {
        enumerable: !0, get: function () {
          return f.getEnvironmentOpcodeTemplates
        }
      });
      const m = r(74937);
      Object.defineProperty(t, "getSpecialOpcodeTemplates", {
        enumerable: !0, get: function () {
          return m.getSpecialOpcodeTemplates
        }
      });
      const g = r(45562);
      Object.defineProperty(t, "getIteratorOpcodeTemplates", {
        enumerable: !0, get: function () {
          return g.getIteratorOpcodeTemplates
        }
      });
      const h = r(31424);
      Object.defineProperty(t, "getMacroOpcodeTemplates", {
        enumerable: !0, get: function () {
          return h.getMacroOpcodeTemplates
        }
      });
      const y = r(44319);

      function S(e = !1) {
        let t = (0, o.getStackOpcodeTemplates)() + (0, n.getArithmeticOpcodeTemplates)() + (0, i.getBitwiseOpcodeTemplates)() + (0, a.getComparisonOpcodeTemplates)() + (0, s.getControlFlowOpcodeTemplates)() + (0, c.getExceptionOpcodeTemplates)() + (0, l.getObjectOpcodeTemplates)() + (0, d.getClassOpcodeTemplates)() + (0, p.getFunctionOpcodeTemplates)() + (0, u.getArrayOpcodeTemplates)() + (0, f.getEnvironmentOpcodeTemplates)() + (0, m.getSpecialOpcodeTemplates)() + (0, g.getIteratorOpcodeTemplates)();
        return e && (t += (0, h.getMacroOpcodeTemplates)()), `${t}\n                        default:\n                            throw new Error('Unknown opcode: ' + op + ' (logical: ' + logicalOp + ')');\n    `
      }

      function N(e, t, r) {
        return `\n                            // ${r} dispatcher\n                            if (${t}) {\n                                switch(op) {\n                                    ${e}\n                                }\n                            } else `
      }

      Object.defineProperty(t, "getIndirectDispatchTemplate", {
        enumerable: !0, get: function () {
          return y.getIndirectDispatchTemplate
        }
      })
    }, 59805: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VM_RUNTIME = t.VM_SEPARATORS = t.VM_SPECIAL_VARS = void 0, t.isSpecialVariable = function (e) {
        return Object.values(t.VM_SPECIAL_VARS).includes(e)
      }, t.isScopedVariable = function (e) {
        return e.includes(t.VM_SEPARATORS.blockScope)
      }, t.getScopedVariableName = function (e, r) {
        return `${e}${t.VM_SEPARATORS.blockScope}${r}`
      }, t.parseScopedVariableName = function (e) {
        const r = e.split(t.VM_SEPARATORS.blockScope);
        if (2 !== r.length) return null;
        const o = parseInt(r[1], 10);
        return isNaN(o) ? null : { baseName: r[0], depth: o }
      }, t.VM_SPECIAL_VARS = {
        capturedThis: "__this__",
        capturedArguments: "__arguments__",
        arrowRestParam: "__vm_rest__"
      }, t.VM_SEPARATORS = { blockScope: "$$" }, t.VM_RUNTIME = { executorPrefix: "_vm_exec" }
    }, 60584: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.codeTransformersModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(78550), s = r(48708), c = r(85418);
      t.codeTransformersModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.Factory__ICodeTransformer).toFactory(o.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.ICodeTransformer)), e(i.ServiceIdentifiers.ICodeTransformerNamesGroupsBuilder).to(s.CodeTransformerNamesGroupsBuilder).inSingletonScope(), e(i.ServiceIdentifiers.ICodeTransformer).to(c.HashbangOperatorTransformer).whenTargetNamed(a.CodeTransformer.HashbangOperatorTransformer)
      })
    }, 60609: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getBitwiseOpcodeTemplates = function () {
        return "\n                        // Bitwise Operations\n                        case opMap[20]: { // BIT_AND\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a & b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[21]: { // BIT_OR\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a | b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[22]: { // BIT_XOR\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a ^ b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[23]: // BIT_NOT\n                            stack.push(~stack.pop());\n                            pc++;\n                            break;\n\n                        case opMap[24]: { // SHL\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a << b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[25]: { // SHR\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a >> b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[26]: { // USHR\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a >>> b);\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 60722: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 60860: (e, t) => {
      function r() {
        return "\n            // Derive encryption key from runtime environment\n            // These values are hard to predict statically\n            function _deriveEnvKey() {\n                let key = 0;\n                // Use Function.prototype.toString characteristics\n                try {\n                    key ^= (Function.prototype.toString.call(Array.prototype.push).length << 16);\n                    key ^= (Function.prototype.toString.call(Object.keys).length << 8);\n                    key ^= Function.prototype.toString.call(Math.abs).length;\n                } catch (e) {\n                    key ^= 0x12_34_56_78;\n                }\n                // Use built-in function arity\n                key ^= (Array.prototype.slice.length << 24);\n                key ^= (String.prototype.charAt.length << 20);\n                // Mix bits\n                key ^= (key >>> 16);\n                key = Math.imul(key, 0x85_EB_CA_6B) >>> 0;\n                key ^= (key >>> 13);\n                key = Math.imul(key, 0xC2_B2_AE_35) >>> 0;\n                key ^= (key >>> 16);\n                return key >>> 0;\n            }"
      }

      function o() {
        return "\n            // RC4 decryption\n            function _rc4Decrypt(data, key) {\n                let s = [];\n                let j = 0;\n                let result = '';\n                // Key scheduling\n                for (let i = 0; i < 256; i++) {\n                    s[i] = i;\n                }\n                for (let i = 0; i < 256; i++) {\n                    j = (j + s[i] + key.charCodeAt(i % key.length)) & 255;\n                    let tmp = s[i];\n                    s[i] = s[j];\n                    s[j] = tmp;\n                }\n                // Decryption\n                let i = 0;\n                j = 0;\n                for (let k = 0; k < data.length; k++) {\n                    i = (i + 1) & 255;\n                    j = (j + s[i]) & 255;\n                    let tmp = s[i];\n                    s[i] = s[j];\n                    s[j] = tmp;\n                    result += String.fromCharCode(data.charCodeAt(k) ^ s[(s[i] + s[j]) & 255]);\n                }\n                return result;\n            }"
      }

      function n() {
        return "\n            // Lazy decryption - decrypt each bytecode only when needed\n            let _envKey = _deriveEnvKey();\n            let _keyStr = _envKey.toString(16);\n\n            function _getBytecode(index) {\n                let entry = {vmBytecodeArrayName}[index];\n                if (typeof entry === 'string') {\n                    // Decode base64 and decrypt\n                    let decoded = atob(entry);\n                    let decrypted = _rc4Decrypt(decoded, _keyStr);\n                    // Decode UTF-8 bytes to string (decrypted contains UTF-8 bytes as char codes)\n                    let jsonStr = decodeURIComponent(escape(decrypted));\n                    // Parse JSON and cache\n                    let bc = JSON.parse(jsonStr);\n                    // BigInt preprocessing for constants\n                    if (bc[{keyC}]) {\n                        for (let cIdx = 0; cIdx < bc[{keyC}].length; cIdx++) {\n                            let constVal = bc[{keyC}][cIdx];\n                            if (typeof constVal === 'string' && constVal.length > 1 && constVal[constVal.length - 1] === 'n') {\n                                try {\n                                    bc[{keyC}][cIdx] = BigInt(constVal.slice(0, -1));\n                                } catch (e) {}\n                            }\n                        }\n                    }\n                    {vmBytecodeArrayName}[index] = bc;\n                }\n                return {vmBytecodeArrayName}[index];\n            }"
      }

      Object.defineProperty(t, "__esModule", { value: !0 }), t.getEnvironmentKeyTemplate = r, t.getRC4DecryptTemplate = o, t.getLazyDecryptionTemplate = n, t.getBytecodeArrayEncodingTemplate = function () {
        return "\n            // Derive encryption key from runtime environment\n            // These values are hard to predict statically\n            function _deriveEnvKey() {\n                let key = 0;\n                // Use Function.prototype.toString characteristics\n                try {\n                    key ^= (Function.prototype.toString.call(Array.prototype.push).length << 16);\n                    key ^= (Function.prototype.toString.call(Object.keys).length << 8);\n                    key ^= Function.prototype.toString.call(Math.abs).length;\n                } catch (e) {\n                    key ^= 0x12_34_56_78;\n                }\n                // Use built-in function arity\n                key ^= (Array.prototype.slice.length << 24);\n                key ^= (String.prototype.charAt.length << 20);\n                // Mix bits\n                key ^= (key >>> 16);\n                key = Math.imul(key, 0x85_EB_CA_6B) >>> 0;\n                key ^= (key >>> 13);\n                key = Math.imul(key, 0xC2_B2_AE_35) >>> 0;\n                key ^= (key >>> 16);\n                return key >>> 0;\n            }\n            // RC4 decryption\n            function _rc4Decrypt(data, key) {\n                let s = [];\n                let j = 0;\n                let result = '';\n                // Key scheduling\n                for (let i = 0; i < 256; i++) {\n                    s[i] = i;\n                }\n                for (let i = 0; i < 256; i++) {\n                    j = (j + s[i] + key.charCodeAt(i % key.length)) & 255;\n                    let tmp = s[i];\n                    s[i] = s[j];\n                    s[j] = tmp;\n                }\n                // Decryption\n                let i = 0;\n                j = 0;\n                for (let k = 0; k < data.length; k++) {\n                    i = (i + 1) & 255;\n                    j = (j + s[i]) & 255;\n                    let tmp = s[i];\n                    s[i] = s[j];\n                    s[j] = tmp;\n                    result += String.fromCharCode(data.charCodeAt(k) ^ s[(s[i] + s[j]) & 255]);\n                }\n                return result;\n            }\n            // Lazy decryption - decrypt each bytecode only when needed\n            let _envKey = _deriveEnvKey();\n            let _keyStr = _envKey.toString(16);\n\n            function _getBytecode(index) {\n                let entry = {vmBytecodeArrayName}[index];\n                if (typeof entry === 'string') {\n                    // Decode base64 and decrypt\n                    let decoded = atob(entry);\n                    let decrypted = _rc4Decrypt(decoded, _keyStr);\n                    // Decode UTF-8 bytes to string (decrypted contains UTF-8 bytes as char codes)\n                    let jsonStr = decodeURIComponent(escape(decrypted));\n                    // Parse JSON and cache\n                    let bc = JSON.parse(jsonStr);\n                    // BigInt preprocessing for constants\n                    if (bc[{keyC}]) {\n                        for (let cIdx = 0; cIdx < bc[{keyC}].length; cIdx++) {\n                            let constVal = bc[{keyC}][cIdx];\n                            if (typeof constVal === 'string' && constVal.length > 1 && constVal[constVal.length - 1] === 'n') {\n                                try {\n                                    bc[{keyC}][cIdx] = BigInt(constVal.slice(0, -1));\n                                } catch (e) {}\n                            }\n                        }\n                    }\n                    {vmBytecodeArrayName}[index] = bc;\n                }\n                return {vmBytecodeArrayName}[index];\n            }"
      }, t.getDirectBytecodeAccessTemplate = function () {
        return "\n            function _getBytecode(index) {\n                return {vmBytecodeArrayName}[index];\n            }"
      }, t.getBigIntPreprocessingTemplate = function () {
        return "\n            // Pre-process constants: Convert BigInt strings (ending with 'n') to BigInt objects\n            // This is done once at initialization instead of on every PUSH_CONST for better performance\n            for (let bcIdx = 0; bcIdx < {vmBytecodeArrayName}.length; bcIdx++) {\n                let bc = {vmBytecodeArrayName}[bcIdx];\n                if (bc[{keyC}]) {\n                    for (let cIdx = 0; cIdx < bc[{keyC}].length; cIdx++) {\n                        let constVal = bc[{keyC}][cIdx];\n                        if (typeof constVal === 'string' && constVal.length > 1 && constVal[constVal.length - 1] === 'n') {\n                            try {\n                                bc[{keyC}][cIdx] = BigInt(constVal.slice(0, -1));\n                            } catch (e) {\n                                // Not a valid BigInt, leave as string\n                            }\n                        }\n                    }\n                }\n            }"
      }, t.rc4Encrypt = function (e, t) {
        const r = Buffer.from(e, "utf8"), o = [];
        let n = 0;
        for (let e = 0; e < 256; e++) o[e] = e;
        for (let e = 0; e < 256; e++) {
          n = n + o[e] + t.charCodeAt(e % t.length) & 255;
          const r = o[e];
          o[e] = o[n], o[n] = r
        }
        let i = 0;
        n = 0;
        const a = Buffer.alloc(r.length);
        for (let e = 0; e < r.length; e++) {
          i = i + 1 & 255, n = n + o[i] & 255;
          const t = o[i];
          o[i] = o[n], o[n] = t, a[e] = r[e] ^ o[o[i] + o[n] & 255]
        }
        return a
      }, t.computeEnvironmentKey = function () {
        let e = 0;
        try {
          e ^= Function.prototype.toString.call(Array.prototype.push).length << 16, e ^= Function.prototype.toString.call(Object.keys).length << 8, e ^= Function.prototype.toString.call(Math.abs).length
        } catch (t) {
          e ^= 305419896
        }
        return e ^= Array.prototype.slice.length << 24, e ^= String.prototype.charAt.length << 20, e ^= e >>> 16, e = Math.imul(e, 2246822507) >>> 0, e ^= e >>> 13, e = Math.imul(e, 3266489909) >>> 0, e ^= e >>> 16, e >>> 0
      }
    }, 60907: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p, u, f = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, m = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, g = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMTransformer = void 0;
      const h = r(45337), y = r(31391), S = r(76393), N = r(31142), b = r(4730), _ = r(68934), v = r(84885),
        I = r(65185), O = r(60722), C = r(68581), E = r(74529), T = r(75716), R = r(52100), M = r(51875), A = r(13245),
        F = r(27391), P = r(93571), D = r(33056), j = r(59805), x = r(51841), V = r(19104), G = r(47250), k = r(73903);
      let L = class extends A.AbstractNodeTransformer {
        constructor(e, t, r, o, n, i, a, s, c, l) {
          super(c, l), this.runAfter = [], this.vmExecutorName = "", this.vmCodeHelperGroup = null, this.pendingGlobalStorageNodes = [], this.topLevelVariables = new Set, this.pendingCatchClauses = [], this.vmBytecodeCompiler = e, this.vmBytecodeStorage = t, this.vmFunctionSelector = r, this.vmGlobalStorageUtils = o, this.vmOpcodeMapStorage = n, this.vmDeadCodeInjector = i, this.vmMacroOpOptimizer = a, this.customCodeHelperGroupFactory = s
        }

        getVisitor(e) {
          return this.options.vmObfuscation && e === T.NodeTransformationStage.VMObfuscation ? {
            enter: (e, t) => {
              if (F.NodeGuards.isProgramNode(e) && (this.getVMCodeHelperGroup(), this.pendingGlobalStorageNodes = [], this.pendingCatchClauses = [], this.topLevelVariables = new Set), F.NodeGuards.isClassDeclarationNode(e) && e.id && t && F.NodeGuards.isProgramNode(t) && this.pendingGlobalStorageNodes.push({
                node: e,
                parentNode: t
              }), F.NodeGuards.isVariableDeclarationNode(e) && t && F.NodeGuards.isProgramNode(t) && this.pendingGlobalStorageNodes.push({
                node: e,
                parentNode: t
              }), F.NodeGuards.isFunctionDeclarationNode(e) && e.id && t && F.NodeGuards.isProgramNode(t) && this.pendingGlobalStorageNodes.push({
                node: e,
                parentNode: t
              }), "CatchClause" === e.type && e.param) {
                const t = e, r = t.param;
                if (this.containsNestedFunctions(t.body) && r) {
                  let e;
                  this.pendingCatchClauses.push(t), e = F.NodeGuards.isIdentifierNode(r) ? [r.name] : F.NodeGuards.isObjectPatternNode(r) || F.NodeGuards.isArrayPatternNode(r) ? this.extractIdentifiersFromPattern(r) : [];
                  for (const t of e) this.topLevelVariables.add(t)
                }
              }
            },
            leave: (e, t) => t && this.isFunctionNode(e) ? this.isNestedFunction(e, t) ? e : this.transformNode(e, t) : F.NodeGuards.isProgramNode(e) && this.vmBytecodeStorage.getLength() > 0 ? this.injectVMRuntime(e) : void 0
          } : null
        }

        transformNode(e, t) {
          if (!this.vmFunctionSelector.shouldVirtualize(e)) return e;
          if (!e.body) return e;
          if (!F.NodeGuards.isBlockStatementNode(e.body)) return e;
          if (0 === e.body.body.length) return e;
          try {
            return this.compileAndTransformFunction(e, t)
          } catch (t) {
            return e
          }
        }

        compileAndTransformFunction(e, t) {
          const r = this.vmBytecodeCompiler.compile(e, this.topLevelVariables);
          if (this.options.vmMacroOps) {
            this.vmMacroOpOptimizer.optimize(r.bytecode);
            for (const e of r.nestedFunctions) this.vmMacroOpOptimizer.optimize(e)
          }
          const o = new Map;
          for (let e = 0; e < r.nestedFunctions.length; e++) {
            const t = r.nestedFunctions[e], n = this.mapNestedFunctionIds(t.constants, o, t.functionRefIndices),
              i = this.generateOpcodeConfig(t.instructions.length, n.length), a = {
                ...t,
                constants: n, ...i, ...this.options.vmJumpsEncoding ? { jumpKey: this.randomGenerator.getRandomInteger(1, 65535) } : {}, ...this.options.vmBytecodeEncoding ? { bytecodeKey: this.randomGenerator.getRandomInteger(1, 255) } : {}, ...this.options.vmStatefulOpcodes ? {
                  smSeed: this.randomGenerator.getRandomInteger(1, 4294967295),
                  smState: this.randomGenerator.getRandomInteger(0, (0, V.getNumStates)() - 1)
                } : {}, ...this.options.vmStackEncoding ? { seKey: this.randomGenerator.getRandomInteger(1, 4294967295) } : {}
              }, s = this.vmDeadCodeInjector.injectDeadCode(a), c = this.vmBytecodeStorage.store(s);
            o.set(e, c)
          }
          const n = this.mapNestedFunctionIds(r.bytecode.constants, o, r.bytecode.functionRefIndices),
            i = this.generateOpcodeConfig(r.bytecode.instructions.length, n.length), a = {
              ...r.bytecode,
              constants: n, ...i, ...this.options.vmJumpsEncoding ? { jumpKey: this.randomGenerator.getRandomInteger(1, 65535) } : {}, ...this.options.vmBytecodeEncoding ? { bytecodeKey: this.randomGenerator.getRandomInteger(1, 255) } : {}, ...this.options.vmStatefulOpcodes ? {
                smSeed: this.randomGenerator.getRandomInteger(1, 4294967295),
                smState: this.randomGenerator.getRandomInteger(0, (0, V.getNumStates)() - 1)
              } : {}, ...this.options.vmStackEncoding ? { seKey: this.randomGenerator.getRandomInteger(1, 4294967295) } : {}
            }, s = this.vmDeadCodeInjector.injectDeadCode(a), c = this.vmBytecodeStorage.store(s),
            l = this.createVMCallBody(c, e, a, t), d = this.createTransformedFunction(e, l);
          return D.NodeUtils.parentizeNode(d, t), d
        }

        generateOpcodeConfig(e, t) {
          if (!this.options.vmOpcodeShuffle) return {};
          if (this.options.vmRuntimeOpcodeDerivation) {
            const {
              seed: r,
              opcodeMap: o
            } = (0, x.generateSeedOpcodeMapping)(() => this.randomGenerator.getRandomInteger(0, 4294967295), e, t);
            return { opcodeSeed: r, opcodeMap: o }
          }
          return { opcodeMap: this.vmOpcodeMapStorage.generateNewMapping() }
        }

        mapNestedFunctionIds(e, t, r) {
          return e.map((e, o) => {
            if (r && r.has(o) && "number" == typeof e && t.has(e)) {
              const r = t.get(e);
              if (void 0 === r) throw new Error(`[VMTransformer] Failed to find actual bytecode ID for local function ID ${e}`);
              return r
            }
            return e
          })
        }

        getVMCodeHelperGroup() {
          return this.vmCodeHelperGroup || (this.vmCodeHelperGroup = this.customCodeHelperGroupFactory(R.CustomCodeHelperGroup.VM), this.vmCodeHelperGroup.initialize(), this.vmExecutorName = this.vmCodeHelperGroup.getVMExecutorName()), this.vmCodeHelperGroup
        }

        createVMCallBody(e, t, r, o) {
          const n = t.params.some(e => F.NodeGuards.isRestElementNode(e)),
            i = F.NodeGuards.isArrowFunctionExpressionNode(t);
          let a;
          if (n && !i) a = P.NodeFactory.callExpressionNode(P.NodeFactory.memberExpressionNode(P.NodeFactory.identifierNode("Array"), P.NodeFactory.identifierNode("from")), [P.NodeFactory.identifierNode("arguments")]); else if (n && i) {
            const e = [];
            let r = !1;
            for (const o of t.params) F.NodeGuards.isIdentifierNode(o) ? e.push(P.NodeFactory.identifierNode(o.name)) : F.NodeGuards.isRestElementNode(o) && (F.NodeGuards.isIdentifierNode(o.argument) ? e.push(P.NodeFactory.spreadElementNode(P.NodeFactory.identifierNode(o.argument.name))) : r = !0);
            a = r ? P.NodeFactory.arrayExpressionNode([P.NodeFactory.spreadElementNode(P.NodeFactory.identifierNode(j.VM_SPECIAL_VARS.arrowRestParam))]) : P.NodeFactory.arrayExpressionNode(e)
          } else a = i ? P.NodeFactory.arrayExpressionNode(this.createParameterReferences(t)) : P.NodeFactory.callExpressionNode(P.NodeFactory.memberExpressionNode(P.NodeFactory.identifierNode("Array"), P.NodeFactory.identifierNode("from")), [P.NodeFactory.identifierNode("arguments")]);
          const s = P.NodeFactory.identifierNode(this.vmExecutorName),
            c = P.NodeFactory.memberExpressionNode(s, P.NodeFactory.identifierNode("call"));
          let l = P.NodeFactory.identifierNode("undefined");
          if (void 0 === r.functionNameIndex || i || (F.NodeGuards.isFunctionExpressionNode(t) && t.id || F.NodeGuards.isFunctionDeclarationNode(t) && t.id) && (l = P.NodeFactory.identifierNode(t.id.name)), F.NodeGuards.isMethodDefinitionNode(o) && "constructor" === o.kind && this.hasSuperCall(t)) return this.createPartiallyObfuscatedConstructor(t, r, e, a, l, c);
          const d = P.NodeFactory.callExpressionNode(c, [{ type: "ThisExpression" }, P.NodeFactory.literalNode(e), a, P.NodeFactory.identifierNode("undefined"), l]),
            p = P.NodeFactory.returnStatementNode(d), u = P.NodeFactory.blockStatementNode([p]);
          return D.NodeUtils.parentizeAst(u), u
        }

        createParameterReferences(e) {
          const t = [];
          for (let r = 0; r < e.params.length; r++) {
            const o = e.params[r];
            if (F.NodeGuards.isIdentifierNode(o)) t.push(P.NodeFactory.identifierNode(o.name)); else {
              if (F.NodeGuards.isRestElementNode(o)) break;
              F.NodeGuards.isArrayPatternNode(o) || F.NodeGuards.isObjectPatternNode(o) || F.NodeGuards.isAssignmentPatternNode(o), t.push(P.NodeFactory.memberExpressionNode(P.NodeFactory.identifierNode("arguments"), P.NodeFactory.literalNode(r), !0))
            }
          }
          return t
        }

        hasSuperCall(e) {
          const t = new Set, r = e => {
            if (!e || "object" != typeof e) return !1;
            if (t.has(e)) return !1;
            if (t.add(e), F.NodeGuards.isSuperNode(e)) return !0;
            for (const t in e) {
              if ("parentNode" === t || "parent" === t) continue;
              const o = e[t];
              if (Array.isArray(o)) {
                for (const e of o) if (r(e)) return !0
              } else if (r(o)) return !0
            }
            return !1
          };
          return r(e.body)
        }

        createPartiallyObfuscatedConstructor(e, t, r, o, n, i) {
          const a = e.body;
          let s = -1;
          for (let e = 0; e < a.body.length; e++) if (this.containsSuperCall(a.body[e])) {
            s = e;
            break
          }
          if (-1 === s) throw new Error("[VMTransformer] Expected super() call in derived class constructor");
          const c = a.body.slice(0, s + 1), l = a.body.slice(s + 1);
          if (0 === l.length) return a;
          const d = c.filter(e => "VariableDeclaration" === e.type), p = {
            type: "FunctionExpression",
            params: e.params,
            body: P.NodeFactory.blockStatementNode([...d, ...l]),
            async: !1,
            generator: !1
          }, u = this.vmBytecodeCompiler.compile(p, this.topLevelVariables);
          if (this.options.vmMacroOps) {
            this.vmMacroOpOptimizer.optimize(u.bytecode);
            for (const e of u.nestedFunctions) this.vmMacroOpOptimizer.optimize(e)
          }
          for (const e of u.nestedFunctions) {
            const t = this.vmDeadCodeInjector.injectDeadCode(e);
            this.vmBytecodeStorage.store(t)
          }
          const f = this.vmDeadCodeInjector.injectDeadCode(u.bytecode), m = this.vmBytecodeStorage.store(f),
            g = P.NodeFactory.callExpressionNode(i, [P.NodeFactory.thisExpressionNode(), P.NodeFactory.literalNode(m), o, P.NodeFactory.identifierNode("undefined"), n, P.NodeFactory.metaPropertyNode(P.NodeFactory.identifierNode("new"), P.NodeFactory.identifierNode("target"))]),
            h = [...c, P.NodeFactory.returnStatementNode(g)], y = P.NodeFactory.blockStatementNode(h);
          return D.NodeUtils.parentizeAst(y), y
        }

        containsSuperCall(e) {
          const t = new Set, r = e => {
            if (!e || "object" != typeof e) return !1;
            if (t.has(e)) return !1;
            if (t.add(e), F.NodeGuards.isSuperNode(e)) return !0;
            for (const t in e) {
              if ("parentNode" === t || "parent" === t) continue;
              const o = e[t];
              if (Array.isArray(o)) {
                for (const e of o) if (r(e)) return !0
              } else if (r(o)) return !0
            }
            return !1
          };
          return r(e)
        }

        createTransformedFunction(e, t) {
          if (F.NodeGuards.isFunctionDeclarationNode(e)) {
            const r = e.id ? e.id.name : "anonymous", o = P.NodeFactory.functionDeclarationNode(r, e.params, t);
            return o.async = e.async, o.generator = !1, D.NodeUtils.parentizeAst(o), o
          }
          if (F.NodeGuards.isArrowFunctionExpressionNode(e)) {
            const r = e.params.some(e => F.NodeGuards.isRestElementNode(e) && !F.NodeGuards.isIdentifierNode(e.argument));
            let o = e.params;
            r && (o = [{
              type: "RestElement",
              argument: { type: "Identifier", name: j.VM_SPECIAL_VARS.arrowRestParam }
            }]);
            const n = {
              type: "ArrowFunctionExpression",
              params: o,
              body: t,
              expression: !1,
              async: e.async,
              metadata: { ignoredNode: !1 }
            };
            return D.NodeUtils.parentizeAst(n), n
          }
          const r = P.NodeFactory.functionExpressionNode(e.params, t);
          return r.async = e.async, r.generator = !1, r.id = e.id, D.NodeUtils.parentizeAst(r), r
        }

        isFunctionNode(e) {
          return F.NodeGuards.isFunctionDeclarationNode(e) || F.NodeGuards.isFunctionExpressionNode(e) || F.NodeGuards.isArrowFunctionExpressionNode(e)
        }

        isNestedFunction(e, t) {
          if (!this.isFunctionNode(e)) return !1;
          let r = t, o = 0;
          for (; r && o < 100;) {
            if (this.isFunctionNode(r)) return !0;
            if (F.NodeGuards.isProgramNode(r)) return !1;
            r = r.parentNode, o++
          }
          return !1
        }

        containsNestedFunctions(e) {
          for (const t of e.body) {
            if (F.NodeGuards.isFunctionDeclarationNode(t)) return !0;
            if (F.NodeGuards.isVariableDeclarationNode(t)) for (const e of t.declarations) if (e.init && (F.NodeGuards.isFunctionExpressionNode(e.init) || F.NodeGuards.isArrowFunctionExpressionNode(e.init))) return !0;
            if (F.NodeGuards.isExpressionStatementNode(t)) {
              const e = t.expression;
              if (F.NodeGuards.isFunctionExpressionNode(e) || F.NodeGuards.isArrowFunctionExpressionNode(e)) return !0
            }
          }
          return !1
        }

        extractIdentifiersFromPattern(e) {
          const t = [];
          if (F.NodeGuards.isObjectPatternNode(e)) {
            for (const r of e.properties) if (F.NodeGuards.isPropertyNode(r)) {
              const e = r.value;
              F.NodeGuards.isIdentifierNode(e) ? t.push(e.name) : (F.NodeGuards.isObjectPatternNode(e) || F.NodeGuards.isArrayPatternNode(e)) && t.push(...this.extractIdentifiersFromPattern(e))
            } else if (F.NodeGuards.isRestElementNode(r)) {
              const e = r.argument;
              F.NodeGuards.isIdentifierNode(e) && t.push(e.name)
            }
          } else if (F.NodeGuards.isArrayPatternNode(e)) for (const r of e.elements) if (null !== r) if (F.NodeGuards.isIdentifierNode(r)) t.push(r.name); else if (F.NodeGuards.isObjectPatternNode(r) || F.NodeGuards.isArrayPatternNode(r)) t.push(...this.extractIdentifiersFromPattern(r)); else if (F.NodeGuards.isRestElementNode(r)) {
            const e = r.argument;
            F.NodeGuards.isIdentifierNode(e) && t.push(e.name)
          } else if (F.NodeGuards.isAssignmentPatternNode(r)) {
            const e = r.left;
            F.NodeGuards.isIdentifierNode(e) ? t.push(e.name) : (F.NodeGuards.isObjectPatternNode(e) || F.NodeGuards.isArrayPatternNode(e)) && t.push(...this.extractIdentifiersFromPattern(e))
          }
          return t
        }

        injectVMRuntime(e) {
          const t = this.getVMCodeHelperGroup().getCustomCodeHelpers().get(M.CustomCodeHelper.VMRuntime);
          if (t) {
            const r = t.getNode();
            G.NodeAppender.prepend(e, r);
            const o = this.extractVMGlobalsNameFromNode(r);
            o && (this.topLevelVariables = this.vmGlobalStorageUtils.transformTopLevelDeclarations(e, o), this.processPendingGlobalStorageNodes(o), this.processPendingCatchClauses(o))
          }
          return e
        }

        extractVMGlobalsNameFromNode(e) {
          if (0 === e.length) return null;
          const t = e[0];
          if (!F.NodeGuards.isVariableDeclarationNode(t)) return null;
          const r = t.declarations[0];
          return r && F.NodeGuards.isIdentifierNode(r.id) ? r.id.name : null
        }

        processPendingGlobalStorageNodes(e) {
          for (const {
            node: t,
            parentNode: r
          } of this.pendingGlobalStorageNodes) F.NodeGuards.isClassDeclarationNode(t) ? this.vmGlobalStorageUtils.wrapClassDeclarationWithGlobalStorage(t, r, e) : F.NodeGuards.isVariableDeclarationNode(t) ? this.vmGlobalStorageUtils.wrapVariableDeclarationWithGlobalStorage(t, r, e) : F.NodeGuards.isFunctionDeclarationNode(t) && this.vmGlobalStorageUtils.wrapFunctionDeclarationWithGlobalStorage(t, r, e);
          this.pendingGlobalStorageNodes = []
        }

        processPendingCatchClauses(e) {
          for (const t of this.pendingCatchClauses) {
            if (!t.param) continue;
            let r;
            r = F.NodeGuards.isIdentifierNode(t.param) ? [t.param.name] : F.NodeGuards.isObjectPatternNode(t.param) || F.NodeGuards.isArrayPatternNode(t.param) ? this.extractIdentifiersFromPattern(t.param) : [];
            const o = [];
            for (const t of r) {
              const r = P.NodeFactory.expressionStatementNode(P.NodeFactory.assignmentExpressionNode("=", P.NodeFactory.memberExpressionNode(P.NodeFactory.identifierNode(e), P.NodeFactory.literalNode(t), !0), P.NodeFactory.identifierNode(t)));
              D.NodeUtils.parentizeAst(r), o.push(r)
            }
            t.body.body.unshift(...o), D.NodeUtils.parentizeAst(t.body)
          }
          this.pendingCatchClauses = []
        }
      };
      t.VMTransformer = L, t.VMTransformer = L = f([(0, h.injectable)(), g(0, (0, h.inject)(y.ServiceIdentifiers.IVMBytecodeCompiler)), g(1, (0, h.inject)(y.ServiceIdentifiers.IVMBytecodeStorage)), g(2, (0, h.inject)(y.ServiceIdentifiers.IVMFunctionSelector)), g(3, (0, h.inject)(y.ServiceIdentifiers.IVMGlobalStorageUtils)), g(4, (0, h.inject)(y.ServiceIdentifiers.IVMOpcodeMapStorage)), g(5, (0, h.inject)(y.ServiceIdentifiers.IVMDeadCodeInjector)), g(6, (0, h.inject)(y.ServiceIdentifiers.IVMMacroOpOptimizer)), g(7, (0, h.inject)(y.ServiceIdentifiers.Factory__ICustomCodeHelperGroup)), g(8, (0, h.inject)(y.ServiceIdentifiers.IRandomGenerator)), g(9, (0, h.inject)(y.ServiceIdentifiers.IOptions)), m("design:paramtypes", ["function" == typeof (o = void 0 !== b.IVMBytecodeCompiler && b.IVMBytecodeCompiler) ? o : Object, "function" == typeof (n = void 0 !== _.IVMBytecodeStorage && _.IVMBytecodeStorage) ? n : Object, "function" == typeof (i = void 0 !== v.IVMFunctionSelector && v.IVMFunctionSelector) ? i : Object, "function" == typeof (a = void 0 !== I.IVMGlobalStorageUtils && I.IVMGlobalStorageUtils) ? a : Object, "function" == typeof (s = void 0 !== O.IVMOpcodeMapStorage && O.IVMOpcodeMapStorage) ? s : Object, "function" == typeof (c = void 0 !== C.VMDeadCodeInjector && C.VMDeadCodeInjector) ? c : Object, "function" == typeof (l = void 0 !== E.VMMacroOpOptimizer && E.VMMacroOpOptimizer) ? l : Object, "function" == typeof (d = void 0 !== k.TCustomCodeHelperGroupFactory && k.TCustomCodeHelperGroupFactory) ? d : Object, "function" == typeof (p = void 0 !== N.IRandomGenerator && N.IRandomGenerator) ? p : Object, "function" == typeof (u = void 0 !== S.IOptions && S.IOptions) ? u : Object])], L)
    }, 60976: e => {
      e.exports = require("md5")
    }, 61762: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.HexadecimalIdentifierNamesGenerator = void 0;
      const l = r(45337), d = r(31391), p = r(76393), u = r(31142), f = r(10419), m = r(24660), g = r(39079);
      let h = o = class extends f.AbstractIdentifierNamesGenerator {
        constructor(e, t) {
          super(e, t)
        }

        generateNext(e) {
          const t = this.randomGenerator.getRandomInteger(1e4, 99999999), r = m.NumberUtils.toHex(t),
            n = g.Utils.hexadecimalPrefix.length, i = (null != e ? e : o.baseIdentifierNameLength) + n,
            a = `_${r.slice(0, i)}`;
          return this.isValidIdentifierName(a) ? (this.preserveName(a), a) : this.generateNext(e)
        }

        generateForGlobalScope(e) {
          const t = this.generateNext(e);
          return `${this.options.identifiersPrefix}${t}`.replace("__", "_")
        }

        generateForLexicalScope(e, t) {
          return this.generateNext(t)
        }

        generateForLabel(e, t) {
          return this.generateNext(t)
        }
      };
      t.HexadecimalIdentifierNamesGenerator = h, h.baseIdentifierNameLength = 6, t.HexadecimalIdentifierNamesGenerator = h = o = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (n = void 0 !== u.IRandomGenerator && u.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== p.IOptions && p.IOptions) ? i : Object])], h)
    }, 61801: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.JavaScriptObfuscator = void 0, r(31321);
      const o = r(31391), n = r(74572), i = r(26251), a = r(39079);

      class s {
        static obfuscate(e, t = {}) {
          const r = new n.InversifyContainerFacade;
          r.load(e, "", t);
          const i = r.get(o.ServiceIdentifiers.IJavaScriptObfuscator).obfuscate(e);
          return r.unload(), i
        }

        static obfuscateMultiple(e, t = {}) {
          if ("object" != typeof e) throw new Error("Source codes object should be a plain object");
          return Object.keys(e).reduce((r, o, n) => {
            const i = a.Utils.getIdentifiersPrefixForMultipleSources(t.identifiersPrefix, n), c = e[o],
              l = { ...t, identifiersPrefix: i };
            return { ...r, [o]: s.obfuscate(c, l) }
          }, {})
        }

        static getOptionsByPreset(e) {
          return i.Options.getOptionsByPreset(e)
        }
      }

      t.JavaScriptObfuscator = s, s.version = null !== "4.2.0" ? "4.2.0" : "unknown"
    }, 61933: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 62059: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ControlFlowCustomNode = void 0, function (e) {
        e.BinaryExpressionFunctionNode = "BinaryExpressionFunctionNode", e.BlockStatementControlFlowFlatteningNode = "BlockStatementControlFlowFlatteningNode", e.CallExpressionControlFlowStorageCallNode = "CallExpressionControlFlowStorageCallNode", e.CallExpressionFunctionNode = "CallExpressionFunctionNode", e.ControlFlowStorageNode = "ControlFlowStorageNode", e.ExpressionWithOperatorControlFlowStorageCallNode = "ExpressionWithOperatorControlFlowStorageCallNode", e.LiteralNode = "LiteralNode", e.LogicalExpressionFunctionNode = "LogicalExpressionFunctionNode", e.StringLiteralControlFlowStorageCallNode = "StringLiteralControlFlowStorageCallNode"
      }(r || (t.ControlFlowCustomNode = r = {}))
    }, 62270: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomainLockRule = void 0;
      const o = r(39079);
      t.DomainLockRule = e => {
        if (e.domainLock.length) {
          const t = [];
          for (const r of e.domainLock) t.push(o.Utils.extractDomainFrom(r));
          e = { ...e, domainLock: t }
        }
        return e
      }
    }, 62467: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObfuscatingGuardResult = void 0, function (e) {
        e.ForceTransform = "ForceTransform", e.Ignore = "Ignore", e.Transform = "Transform"
      }(r || (t.ObfuscatingGuardResult = r = {}))
    }, 62625: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 62951: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IfStatementSimplifyTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(24698), m = r(27391),
        g = r(93571), h = r(33056);
      let y = class extends f.AbstractStatementSimplifyTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Simplifying ? {
            leave: (e, t) => {
              if (t && m.NodeGuards.isIfStatementNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          const r = this.getStatementSimplifyData(e.consequent);
          if (!r) return e;
          let o;
          if (e.alternate) {
            const t = this.getStatementSimplifyData(e.alternate);
            if (!t) return e;
            o = this.getConsequentAndAlternateNode(e, r, t)
          } else o = this.getConsequentNode(e, r);
          return h.NodeUtils.parentizeNode(o, t)
        }

        getConsequentNode(e, t) {
          return t.leadingStatements.length || !t.trailingStatement ? g.NodeFactory.ifStatementNode(e.test, this.getPartialStatement(t)) : t.hasReturnStatement ? g.NodeFactory.ifStatementNode(e.test, t.trailingStatement.statement) : g.NodeFactory.expressionStatementNode(g.NodeFactory.logicalExpressionNode("&&", e.test, t.trailingStatement.expression))
        }

        getConsequentAndAlternateNode(e, t, r) {
          return t.leadingStatements.length || r.leadingStatements.length || !t.trailingStatement || !r.trailingStatement ? g.NodeFactory.ifStatementNode(e.test, this.getPartialStatement(t), this.getPartialStatement(r)) : t.hasReturnStatement && r.hasReturnStatement ? g.NodeFactory.returnStatementNode(g.NodeFactory.conditionalExpressionNode(e.test, t.trailingStatement.expression, r.trailingStatement.expression)) : t.hasReturnStatement || r.hasReturnStatement ? g.NodeFactory.ifStatementNode(e.test, t.trailingStatement.statement, r.trailingStatement.statement) : g.NodeFactory.expressionStatementNode(g.NodeFactory.conditionalExpressionNode(e.test, t.trailingStatement.expression, r.trailingStatement.expression))
        }

        getPartialStatement(e) {
          const t = super.getPartialStatement(e);
          return m.NodeGuards.isBlockStatementNode(t) ? 1 !== t.body.length || this.isProhibitedSingleStatementForIfStatementBranch(t.body[0]) ? t : t.body[0] : t
        }

        isProhibitedSingleStatementForIfStatementBranch(e) {
          return m.NodeGuards.isFunctionDeclarationNode(e) || m.NodeGuards.isIfStatementNode(e) || m.NodeGuards.isNodeWithSingleStatementBody(e) || m.NodeGuards.isVariableDeclarationNode(e) && "var" !== e.kind
        }
      };
      t.IfStatementSimplifyTransformer = y, t.IfStatementSimplifyTransformer = y = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], y)
    }, 62957: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ArrayStorage = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(50164);
      let f = class {
        constructor(e, t) {
          this.storageLength = 0, this.randomGenerator = e, this.options = t
        }

        initialize() {
          this.storage = [], this.storageId = this.randomGenerator.getRandomString(6)
        }

        delete(e) {
          var t;
          const r = null !== (t = this.storage.splice(e, 1)[0]) && void 0 !== t ? t : void 0;
          return r && this.storageLength--, r
        }

        get(e) {
          return this.storage[e]
        }

        getOrThrow(e) {
          const t = this.get(e);
          if (!t) throw new Error(`No value found in array storage with key \`${e}\``);
          return t
        }

        getKeyOf(e) {
          const t = this.storage.indexOf(e);
          return t >= 0 ? t : null
        }

        getLength() {
          return this.storageLength
        }

        getStorage() {
          return this.storage
        }

        getStorageId() {
          return this.storageId
        }

        mergeWith(e, t = !1) {
          this.storage = [...this.storage, ...e.getStorage()], t && (this.storageId = e.getStorageId())
        }

        set(e, t) {
          e === this.storageLength ? this.storage.push(t) : this.storage.splice(e, 0, t), this.storageLength++
        }
      };
      t.ArrayStorage = f, i([(0, u.initializable)(), a("design:type", Array)], f.prototype, "storage", void 0), i([(0, u.initializable)(), a("design:type", String)], f.prototype, "storageId", void 0), i([(0, c.postConstruct)(), a("design:type", Function), a("design:paramtypes", []), a("design:returntype", void 0)], f.prototype, "initialize", null), t.ArrayStorage = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], f)
    }, 63016: function (e, t, r) {
      var o, n, i = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), a = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && i(t, e, r[n]);
        return a(t, e), t
      }), l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      }, p = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomCodeHelperFormatter = void 0;
      const u = r(45337), f = r(31391), m = c(r(31659)), g = p(r(42782)), h = r(1561), y = r(27391);
      let S = class {
        constructor(e) {
          this.prevailingKindOfVariables = e.getPrevailingKind()
        }

        formatTemplate(e, t) {
          return (0, g.default)(e, t)
        }

        formatStructure(e) {
          for (const t of e) m.replace(t, {
            enter: e => {
              if (y.NodeGuards.isVariableDeclarationNode(e)) return "var" === this.prevailingKindOfVariables && (e.kind = "var"), e
            }
          });
          return e
        }
      };
      t.CustomCodeHelperFormatter = S, t.CustomCodeHelperFormatter = S = s([(0, u.injectable)(), d(0, (0, u.inject)(f.ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)), l("design:paramtypes", ["function" == typeof (n = void 0 !== h.IPrevailingKindOfVariablesAnalyzer && h.IPrevailingKindOfVariablesAnalyzer) ? n : Object])], S)
    }, 63191: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayBase64DecodeTemplate = function (e) {
        const t = e.getRandomString(6), r = e.getRandomString(6), o = e.getRandomString(6);
        return `\n        if ({stringArrayCallsWrapperName}.${t} === undefined) {\n            {atobPolyfill}\n            {stringArrayCallsWrapperName}.${r} = {atobFunctionName};\n\n            {stringArrayCallsWrapperName}.${o} = {};\n            \n            {stringArrayCallsWrapperName}.${t} = true;\n        }\n                  \n        const firstValue = stringArray[0];\n        const cacheKey = index + firstValue;\n        const cachedValue = {stringArrayCallsWrapperName}.${o}[cacheKey];\n        \n        if (!cachedValue) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${r}(value);\n            {stringArrayCallsWrapperName}.${o}[cacheKey] = value;\n        } else {\n            value = cachedValue;\n        }\n    `
      }
    }, 63312: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DirectivePlacementTransformer = void 0;
      const u = r(45337), f = r(31391), m = l(r(31659)), g = r(76393), h = r(31142), y = r(75716), S = r(92486),
        N = r(13245), b = r(47250), _ = r(27391), v = r(33056);
      let I = class extends N.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [S.NodeTransformer.CustomCodeHelpersTransformer], this.lexicalScopeDirectives = new WeakMap
        }

        getVisitor(e) {
          switch (e) {
            case y.NodeTransformationStage.Preparing:
              return {
                enter: (e, t) => {
                  if (t && _.NodeGuards.isNodeWithLexicalScopeStatements(e, t)) return this.analyzeNode(e, t)
                }
              };
            case y.NodeTransformationStage.Finalizing:
              return {
                enter: (e, t) => {
                  if (t && _.NodeGuards.isNodeWithLexicalScopeStatements(e, t)) return this.transformNode(e, t)
                }
              };
            default:
              return null
          }
        }

        analyzeNode(e, t) {
          var r;
          if (!_.NodeGuards.isNodeWithLexicalScope(t)) return e;
          const o = null !== (r = e.body[0]) && void 0 !== r ? r : null;
          return o && _.NodeGuards.isDirectiveNode(o) && this.lexicalScopeDirectives.set(t, o), e
        }

        transformNode(e, t) {
          if (!_.NodeGuards.isNodeWithLexicalScope(t)) return e;
          const r = this.lexicalScopeDirectives.get(t);
          if (r) {
            const t = v.NodeUtils.clone(r);
            b.NodeAppender.prepend(e, [t]);
            let o = !1;
            m.replace(e, { enter: e => o ? m.VisitorOption.Break : e === r ? (o = !0, m.VisitorOption.Remove) : void 0 })
          }
          return e
        }
      };
      t.DirectivePlacementTransformer = I, t.DirectivePlacementTransformer = I = c([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (n = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== g.IOptions && g.IOptions) ? i : Object])], I)
    }, 63512: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.base64alphabet = void 0;
      const o = r(6088), n = r(55194), i = r(36869);
      t.base64alphabet = `${o.alphabetStringUppercase}${n.alphabetString}${i.numbersString}+/=`
    }, 63705: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 63989: function (e, t, r) {
      var o, n = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), a = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), a = 0; a < r.length; a++) "default" !== r[a] && n(t, e, r[a]);
        return i(t, e), t
      }), s = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ASTParserFacade = void 0;
      const c = a(r(3749)), l = s(r(96895));

      class d {
        static parse(e, t) {
          const r = d.sourceTypes.length;
          for (let o = 0; o < r; o++) try {
            return d.parseType(e, t, d.sourceTypes[o])
          } catch (t) {
            if (o < r - 1) continue;
            throw new Error(d.processParsingError(e, t.message, t.loc))
          }
          throw new Error("Acorn parsing error")
        }

        static parseType(e, t, r) {
          const o = [], n = { ...t, allowAwaitOutsideFunction: !0, onComment: o, sourceType: r }, i = c.parse(e, n);
          return o.length && (i.comments = o), i
        }

        static processParsingError(e, t, r) {
          if (!(null == r ? void 0 : r.line) || !r.column) throw new Error(t);
          const o = e.split(/\r?\n/)[r.line - 1];
          if (!o) throw new Error(t);
          const n = Math.max(0, r.column - d.nearestSymbolsCount),
            i = Math.min(o.length, r.column + d.nearestSymbolsCount), a = d.colorError(">"),
            s = `...${o.slice(n, i).replace(/^\s+/, "")}...`;
          throw new Error(`ERROR at line ${r.line}: ${t}\n${a} ${s}`)
        }
      }

      t.ASTParserFacade = d, d.colorError = l.default.red, d.nearestSymbolsCount = 15, d.sourceTypes = ["script", "module"]
    }, 64134: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 64395: function (e, t, r) {
      var o, n, i, a = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), s = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && a(t, e, r[n]);
        return s(t, e), t
      }), d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMFunctionSelector = void 0;
      const u = r(45337), f = l(r(31659)), m = r(31391), g = r(76393), h = r(31142), y = r(27391), S = r(4592);
      let N = class {
        constructor(e, t) {
          this.allowListSet = null, this.denyListSet = null, this.randomGenerator = e, this.options = t
        }

        shouldVirtualize(e) {
          var t;
          if (!this.options.vmObfuscation) return !1;
          if (null === (t = e.metadata) || void 0 === t ? void 0 : t.ignoredNode) return !1;
          const r = this.getFunctionName(e);
          return !(r && this.isDenied(r) || this.getAllowListSet().size > 0 && (!r || !this.isAllowed(r)) || !this.passesThreshold() || !this.isSuitableForVirtualization(e))
        }

        isAllowed(e) {
          const t = this.getAllowListSet();
          return 0 === t.size || t.has(e)
        }

        isDenied(e) {
          return this.getDenyListSet().has(e)
        }

        passesThreshold() {
          return this.randomGenerator.getMathRandom() <= this.options.vmObfuscationThreshold
        }

        getFunctionName(e) {
          return y.NodeGuards.isFunctionDeclarationNode(e) && e.id || y.NodeGuards.isFunctionExpressionNode(e) && e.id ? e.id.name : null
        }

        isSuitableForVirtualization(e) {
          return !(y.NodeGuards.isBlockStatementNode(e.body) && 0 === e.body.body.length || this.containsDirectEval(e.body))
        }

        containsDirectEval(e) {
          let t = !1;
          return f.traverse(e, { enter: r => y.NodeGuards.isCallExpressionNode(r) && y.NodeGuards.isIdentifierNode(r.callee) && "eval" === r.callee.name || S.NodeMetadata.isEvalHostNode(r) ? (t = !0, f.VisitorOption.Break) : r !== e && (y.NodeGuards.isFunctionDeclarationNode(r) || y.NodeGuards.isFunctionExpressionNode(r) || y.NodeGuards.isArrowFunctionExpressionNode(r)) ? f.VisitorOption.Skip : void 0 }), t
        }

        getAllowListSet() {
          return null === this.allowListSet && (this.allowListSet = new Set(this.options.vmTargetFunctions || [])), this.allowListSet
        }

        getDenyListSet() {
          return null === this.denyListSet && (this.denyListSet = new Set(this.options.vmExcludeFunctions || [])), this.denyListSet
        }
      };
      t.VMFunctionSelector = N, t.VMFunctionSelector = N = c([(0, u.injectable)(), p(0, (0, u.inject)(m.ServiceIdentifiers.IRandomGenerator)), p(1, (0, u.inject)(m.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (n = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== g.IOptions && g.IOptions) ? i : Object])], N)
    }, 64544: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 64717: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMExpressionBytecodeCompiler = void 0;
      const f = r(45337), m = r(46188), g = r(81102), h = r(15200), y = r(57798), S = r(96884), N = r(91015),
        b = r(20924), _ = r(31391), v = r(25115), I = r(59805), O = r(27391);
      let C = class {
        constructor(e, t, r, o, n, i, a) {
          this.literalCompiler = e, this.operatorCompiler = t, this.assignmentCompiler = r, this.callCompiler = o, this.memberAccessCompiler = n, this.classCompiler = i, this.vmCompilerUtils = a
        }

        compileExpression(e, t) {
          this.compileLiteralExpression(e, t) || this.compileOperatorExpression(e, t) || this.compileSpecialExpression(e, t) || this.vmCompilerUtils.createInstructionBuilder(t).pushUndefined()
        }

        compileBinaryExpression(e, t) {
          this.operatorCompiler.compileBinaryExpression(e, t)
        }

        compileUnaryExpression(e, t) {
          this.operatorCompiler.compileUnaryExpression(e, t)
        }

        compileLogicalExpression(e, t) {
          this.operatorCompiler.compileLogicalExpression(e, t)
        }

        compileCallExpression(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          if (O.NodeGuards.isIdentifierNode(e.callee) && "Symbol" === e.callee.name) if (0 === e.arguments.length) n.createSymbol(null); else {
            const o = e.arguments[0];
            if (O.NodeGuards.isSpreadElementNode(o)) return void this.callCompiler.compileCallExpression(e, t);
            null === (r = t.dispatch) || void 0 === r || r.expression(o), n.createSymbol(0)
          } else {
            if (O.NodeGuards.isMemberExpressionNode(e.callee) && O.NodeGuards.isIdentifierNode(e.callee.object) && "Symbol" === e.callee.object.name && O.NodeGuards.isIdentifierNode(e.callee.property) && "for" === e.callee.property.name && !e.callee.computed && e.arguments.length > 0) {
              const r = e.arguments[0];
              if (O.NodeGuards.isLiteralNode(r) && "string" == typeof r.value) {
                const e = t.constantPool.add(r.value);
                return void n.symbolFor(e)
              }
            }
            if (O.NodeGuards.isMemberExpressionNode(e.callee) && O.NodeGuards.isIdentifierNode(e.callee.object) && "Symbol" === e.callee.object.name && O.NodeGuards.isIdentifierNode(e.callee.property) && "keyFor" === e.callee.property.name && !e.callee.computed && e.arguments.length > 0) {
              const r = e.arguments[0];
              return null === (o = t.dispatch) || void 0 === o || o.expression(r), void n.symbolKeyFor()
            }
            this.callCompiler.compileCallExpression(e, t)
          }
        }

        compileMemberExpression(e, t) {
          this.memberAccessCompiler.compileMemberExpression(e, t)
        }

        compileAssignmentExpression(e, t) {
          this.assignmentCompiler.compileAssignmentExpression(e, t)
        }

        compileConditionalExpression(e, t) {
          var r, o, n;
          null === (r = t.dispatch) || void 0 === r || r.expression(e.test);
          const i = this.vmCompilerUtils.emitConditionalJump(v.VMOpCode.JUMP_IF_FALSE, t);
          null === (o = t.dispatch) || void 0 === o || o.expression(e.consequent);
          const a = this.vmCompilerUtils.emitConditionalJump(v.VMOpCode.JUMP, t);
          this.vmCompilerUtils.patchJump(i, t), null === (n = t.dispatch) || void 0 === n || n.expression(e.alternate), this.vmCompilerUtils.patchJump(a, t)
        }

        compileUpdateExpression(e, t) {
          this.operatorCompiler.compileUpdateExpression(e, t)
        }

        compileNewExpression(e, t) {
          this.callCompiler.compileNewExpression(e, t)
        }

        compileSequenceExpression(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          for (let n = 0; n < e.expressions.length; n++) null === (r = t.dispatch) || void 0 === r || r.expression(e.expressions[n]), n < e.expressions.length - 1 && o.pop()
        }

        compileTaggedTemplateExpression(e, t) {
          this.literalCompiler.compileTaggedTemplateExpression(e, t)
        }

        compileAwaitExpression(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          null === (r = t.dispatch) || void 0 === r || r.expression(e.argument), o.await()
        }

        compileYieldExpression(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          e.argument ? null === (r = t.dispatch) || void 0 === r || r.expression(e.argument) : o.pushUndefined(), e.delegate ? o.yieldStar() : o.yield()
        }

        compileChainExpression(e, t) {
          var r;
          null === (r = t.dispatch) || void 0 === r || r.expression(e.expression)
        }

        compileThisExpression(e) {
          const t = this.vmCompilerUtils.createInstructionBuilder(e);
          e.isArrowFunction ? (e.capturedThis = !0, e.capturedVars.add(I.VM_SPECIAL_VARS.capturedThis), t.loadFromEnvByName(I.VM_SPECIAL_VARS.capturedThis)) : t.this()
        }

        compileMetaProperty(e, t) {
          const r = this.vmCompilerUtils.createInstructionBuilder(t);
          "MetaProperty" === e.type && "new" === e.meta.name && "target" === e.property.name ? r.newTarget() : r.pushUndefined()
        }

        compileLiteralExpression(e, t) {
          switch (e.type) {
            case"Literal":
              return this.literalCompiler.compileLiteral(e, t), !0;
            case"Identifier":
              return this.literalCompiler.compileIdentifier(e, t), !0;
            case"ArrayExpression":
              return this.literalCompiler.compileArrayExpression(e, t), !0;
            case"ObjectExpression":
              return this.literalCompiler.compileObjectExpression(e, t), !0;
            case"TemplateLiteral":
              return this.literalCompiler.compileTemplateLiteral(e, t), !0;
            case"ThisExpression":
              return this.compileThisExpression(t), !0;
            case"MetaProperty":
              return this.compileMetaProperty(e, t), !0;
            default:
              return !1
          }
        }

        compileOperatorExpression(e, t) {
          switch (e.type) {
            case"BinaryExpression":
              return this.compileBinaryExpression(e, t), !0;
            case"UnaryExpression":
              return this.compileUnaryExpression(e, t), !0;
            case"LogicalExpression":
              return this.compileLogicalExpression(e, t), !0;
            case"ConditionalExpression":
              return this.compileConditionalExpression(e, t), !0;
            case"AssignmentExpression":
              return this.compileAssignmentExpression(e, t), !0;
            case"UpdateExpression":
              return this.compileUpdateExpression(e, t), !0;
            default:
              return !1
          }
        }

        compileSpecialExpression(e, t) {
          return !!this.compileFunctionObjectExpression(e, t) || this.compileAsyncExpression(e, t)
        }

        compileFunctionObjectExpression(e, t) {
          var r;
          switch (e.type) {
            case"CallExpression":
              return this.compileCallExpression(e, t), !0;
            case"MemberExpression":
              return this.compileMemberExpression(e, t), !0;
            case"FunctionExpression":
            case"ArrowFunctionExpression":
              return null === (r = t.dispatch) || void 0 === r || r.functionExpression(e), !0;
            case"ClassExpression":
              return this.classCompiler.compileClassExpression(e, t), !0;
            case"NewExpression":
              return this.compileNewExpression(e, t), !0;
            case"SequenceExpression":
              return this.compileSequenceExpression(e, t), !0;
            default:
              return !1
          }
        }

        compileAsyncExpression(e, t) {
          switch (e.type) {
            case"TaggedTemplateExpression":
              return this.compileTaggedTemplateExpression(e, t), !0;
            case"AwaitExpression":
              return this.compileAwaitExpression(e, t), !0;
            case"YieldExpression":
              return this.compileYieldExpression(e, t), !0;
            case"ChainExpression":
              return this.compileChainExpression(e, t), !0;
            default:
              return !1
          }
        }
      };
      t.VMExpressionBytecodeCompiler = C, t.VMExpressionBytecodeCompiler = C = d([(0, f.injectable)(), u(0, (0, f.inject)(_.ServiceIdentifiers.IVMLiteralBytecodeCompiler)), u(1, (0, f.inject)(_.ServiceIdentifiers.IVMOperatorCompiler)), u(2, (0, f.inject)(_.ServiceIdentifiers.IVMAssignmentCompiler)), u(3, (0, f.inject)(_.ServiceIdentifiers.IVMCallCompiler)), u(4, (0, f.inject)(_.ServiceIdentifiers.IVMMemberAccessCompiler)), u(5, (0, f.inject)(_.ServiceIdentifiers.IVMClassBytecodeCompiler)), u(6, (0, f.inject)(_.ServiceIdentifiers.IVMCompilerUtils)), p("design:paramtypes", ["function" == typeof (o = void 0 !== m.IVMLiteralBytecodeCompiler && m.IVMLiteralBytecodeCompiler) ? o : Object, "function" == typeof (n = void 0 !== g.IVMOperatorCompiler && g.IVMOperatorCompiler) ? n : Object, "function" == typeof (i = void 0 !== h.IVMAssignmentCompiler && h.IVMAssignmentCompiler) ? i : Object, "function" == typeof (a = void 0 !== y.IVMCallCompiler && y.IVMCallCompiler) ? a : Object, "function" == typeof (s = void 0 !== S.IVMMemberAccessCompiler && S.IVMMemberAccessCompiler) ? s : Object, "function" == typeof (c = void 0 !== N.IVMClassBytecodeCompiler && N.IVMClassBytecodeCompiler) ? c : Object, "function" == typeof (l = void 0 !== b.IVMCompilerUtils && b.IVMCompilerUtils) ? l : Object])], C)
    }, 64858: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SourceMapMode = void 0;
      const o = r(39079);
      t.SourceMapMode = o.Utils.makeEnum({ Inline: "inline", Separate: "separate" })
    }, 65185: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 65714: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ConsoleOutputCodeHelperGroup = void 0;
      const p = r(45337), u = r(31391), f = r(58544), m = r(18741), g = r(76393), h = r(31142), y = r(50164),
        S = r(51875), N = r(75716), b = r(26455), _ = r(47250), v = r(75096);
      let I = class extends b.AbstractCustomCodeHelperGroup {
        constructor(e, t, r, o) {
          super(t, r, o), this.customCodeHelperFactory = e
        }

        appendOnPreparingStage(e, t) {
          var r;
          if (!this.options.disableConsoleOutput) return;
          const o = this.getRandomCallsGraphIndex(t.length),
            n = t.length ? _.NodeAppender.getOptimalBlockScope(t, o) : e,
            i = t.length ? _.NodeAppender.getOptimalBlockScope(t, o, 1) : e,
            a = null !== (r = v.NodeLexicalScopeUtils.getLexicalScope(n)) && void 0 !== r ? r : null,
            s = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext(),
            c = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext();
          this.appendCustomNodeIfExist(S.CustomCodeHelper.ConsoleOutputDisable, e => {
            e.initialize(c, s), _.NodeAppender.prepend(n, e.getNode())
          }), this.appendCustomNodeIfExist(S.CustomCodeHelper.CallsControllerFunction, e => {
            e.initialize(N.NodeTransformationStage.Preparing, c), _.NodeAppender.prepend(i, e.getNode())
          })
        }

        initialize() {
          if (this.customCodeHelpers = new Map, !this.options.disableConsoleOutput) return;
          const e = this.customCodeHelperFactory(S.CustomCodeHelper.ConsoleOutputDisable),
            t = this.customCodeHelperFactory(S.CustomCodeHelper.CallsControllerFunction);
          this.customCodeHelpers.set(S.CustomCodeHelper.ConsoleOutputDisable, e), this.customCodeHelpers.set(S.CustomCodeHelper.CallsControllerFunction, t)
        }
      };
      t.ConsoleOutputCodeHelperGroup = I, c([(0, y.initializable)(), l("design:type", "function" == typeof (s = "undefined" != typeof Map && Map) ? s : Object)], I.prototype, "customCodeHelpers", void 0), t.ConsoleOutputCodeHelperGroup = I = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__ICustomCodeHelper)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TCustomCodeHelperFactory && f.TCustomCodeHelperFactory) ? o : Object, "function" == typeof (n = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== g.IOptions && g.IOptions) ? a : Object])], I)
    }, 65850: e => {
      e.exports = require("@javascript-obfuscator/escodegen")
    }, 66339: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayHexadecimalNumberIndexNode = void 0;
      const c = r(45337), l = r(76393), d = r(31142), p = r(31391), u = r(81131), f = r(93571), m = r(24660);
      let g = class extends u.AbstractStringArrayIndexNode {
        constructor(e, t) {
          super(e, t)
        }

        getNode(e) {
          const t = m.NumberUtils.toHex(e);
          return f.NodeFactory.literalNode(e, t)
        }
      };
      t.StringArrayHexadecimalNumberIndexNode = g, t.StringArrayHexadecimalNumberIndexNode = g = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(p.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== d.IRandomGenerator && d.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== l.IOptions && l.IOptions) ? n : Object])], g)
    }, 66540: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallsWrapperRc4CodeHelper = void 0;
      const n = r(45337), i = r(7962), a = r(95325), s = r(18255), c = r(54867);
      let l = class extends c.StringArrayCallsWrapperCodeHelper {
        getDecodeStringArrayTemplate() {
          const e = this.randomGenerator.getRandomString(6), t = this.randomGenerator.getRandomString(6),
            r = this.customCodeHelperFormatter.formatTemplate((0, i.AtobTemplate)(this.options.selfDefending), { atobFunctionName: e }),
            o = this.customCodeHelperFormatter.formatTemplate((0, a.Rc4Template)(), {
              atobFunctionName: e,
              rc4FunctionName: t
            }), n = this.getSelfDefendingTemplate();
          return this.customCodeHelperFormatter.formatTemplate((0, s.StringArrayRC4DecodeTemplate)(this.randomGenerator), {
            atobPolyfill: r,
            rc4FunctionName: t,
            rc4Polyfill: o,
            selfDefendingCode: n,
            stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,
            stringArrayFunctionName: this.stringArrayFunctionName
          })
        }
      };
      t.StringArrayCallsWrapperRc4CodeHelper = l, t.StringArrayCallsWrapperRc4CodeHelper = l = o([(0, n.injectable)()], l)
    }, 66628: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IgnoredImportObfuscatingGuard = void 0;
      const c = r(45337), l = r(76393), d = r(62467), p = r(31391), u = r(27391);
      let f = o = class {
        constructor(e) {
          this.options = e
        }

        static isDynamicImport(e) {
          return u.NodeGuards.isImportExpressionNode(e)
        }

        static isRequireImport(e) {
          return u.NodeGuards.isCallExpressionNode(e) && u.NodeGuards.isIdentifierNode(e.callee) && "require" === e.callee.name
        }

        check(e) {
          return this.options.ignoreImports && (o.isDynamicImport(e) || o.isRequireImport(e)) ? d.ObfuscatingGuardResult.Ignore : d.ObfuscatingGuardResult.Transform
        }
      };
      t.IgnoredImportObfuscatingGuard = f, t.IgnoredImportObfuscatingGuard = f = o = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (n = void 0 !== l.IOptions && l.IOptions) ? n : Object])], f)
    }, 66902: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getOpcodeDerivationTemplate = function () {
        return `\n            // ===== Opcode Derivation Functions =====\n            // These derive the opcode mapping from a seed at runtime\n\n            // Derivation constants (must match compile-time exactly)\n            let _D_MULT1 = 0x85EBCA6B;\n            let _D_MULT2 = 0xC2B2AE35;\n            let _D_SHIFT1 = 0x10;\n            let _D_SHIFT2 = 0x0D;\n            let _D_SHIFT3 = 0x10;\n            let _D_PHI = 0x9E3779B9; // Golden ratio derivative\n            let _D_OPCODE_COUNT = ${o.VM_OPCODE_COUNT}; // Must cover all VMOpCode values (including macro-ops 250-261)\n\n            // Mix bits of a 32-bit integer (MurmurHash3 finalizer variant)\n            function _mixBits(h) {\n                h = h >>> 0;\n                h ^= h >>> _D_SHIFT1;\n                h = Math.imul(h, _D_MULT1) >>> 0;\n                h ^= h >>> _D_SHIFT2;\n                h = Math.imul(h, _D_MULT2) >>> 0;\n                h ^= h >>> _D_SHIFT3;\n                return h >>> 0;\n            }\n\n            // Derive a pseudo-random value from seed and index\n            function _deriveValue(seed, index) {\n                let combined = (seed ^ (index * _D_PHI)) >>> 0;\n                combined = (combined ^ (combined >>> 11)) >>> 0;\n                combined = Math.imul(combined, 0x1B873593) >>> 0;\n                combined = (combined ^ (combined >>> 15)) >>> 0;\n                return _mixBits(combined);\n            }\n\n            // Generate opcode mapping table from seed using Fisher-Yates shuffle\n            function _deriveOpcodeTable(seed, instrCount, constCount) {\n                // Layer 1: Mix seed with function metadata\n                let mixedSeed = seed ^ ((instrCount * _D_PHI) >>> 0);\n                mixedSeed = (mixedSeed ^ ((constCount * 0x27D4EB2D) >>> 0)) >>> 0;\n                mixedSeed = _mixBits(mixedSeed);\n\n                // Layer 2: Create initial array [0, 1, 2, ..., 127]\n                let arr = [];\n                for (let i = 0; i < _D_OPCODE_COUNT; i++) {\n                    arr[i] = i;\n                }\n\n                // Layer 3: Fisher-Yates shuffle with derived random values\n                for (let i = _D_OPCODE_COUNT - 1; i > 0; i--) {\n                    let randVal = _deriveValue(mixedSeed, i);\n                    let j = randVal % (i + 1);\n                    let tmp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = tmp;\n                }\n\n                // Convert to lookup object: logical -> randomized\n                let opMap = {};\n                for (let i = 0; i < _D_OPCODE_COUNT; i++) {\n                    opMap[i] = arr[i];\n                }\n\n                return opMap;\n            }\n\n            // Cache for derived opcode tables (keyed by seed + metadata)\n            let _derivedTables = {};\n\n            // Get or create opcode table from seed\n            function _getOpcodeTable(seed, instrCount, constCount) {\n                let cacheKey = seed + '_' + instrCount + '_' + constCount;\n                if (!_derivedTables[cacheKey]) {\n                    _derivedTables[cacheKey] = _deriveOpcodeTable(seed, instrCount, constCount);\n                }\n                return _derivedTables[cacheKey];\n            }\n`
      }, t.getOpcodeDerivationInitTemplate = function () {
        return "\n                // Runtime opcode derivation: derive opcode table from seed if present\n                if (bc.os !== undefined) {\n                    let instrCount = instructions.length >> 1;\n                    let constCount = constants ? constants.length : 0;\n                    opMap = _getOpcodeTable(bc.os, instrCount, constCount);\n                }\n"
      };
      const o = r(79240)
    }, 67655: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getExecutorInitTemplate = function () {
        return "                let bc = _getBytecode(bytecodeId);\n                let stack = [];\n                // Local variables array (for non-captured variables)\n                let locals = new Array((bc.p || 0) + (bc.l || 0));\n                let pc = 0;\n                let constants = bc.c;\n                let instructions = bc.i;\n                let opMap = {vmOpcodeMapName};\n\n                // Exception handler stack\n                // Each handler stores: { catchIndex, finallyIndex, endIndex, stackSize, pendingException, pendingReturn }\n                let exceptionHandlers = [];\n\n                // Pending exception to re-throw after finally block\n                let pendingException = null;\n\n                // Pending return value and flag\n                let pendingReturn = { hasReturn: false, value: undefined };\n\n                // Pending break/continue target (for try-finally)\n                let pendingBreak = { hasBreak: false, target: 0 };\n                let pendingContinue = { hasContinue: false, target: 0 };\n\n                // Create environment for this function execution\n                // Environment holds captured variables that need reference semantics\n                let env = {\n                    parent: parentEnv,\n                    vars: {}\n                };\n\n                // Initialize parameters as locals\n                if (args) {\n                    for (let _loopIdx = 0; _loopIdx < Math.min(args.length, bc.p || 0); _loopIdx++) {\n                        locals[_loopIdx] = args[_loopIdx];\n                    }\n                }"
      }, t.getExceptionHandlerLogicTemplate = function () {
        return "                    // Exception was thrown during instruction execution\n                    // Search for an exception handler\n                    if (exceptionHandlers.length > 0) {\n                        // Get the most recent exception handler\n                        // Don't pop it yet if there's a finally block to execute\n                        let handler = exceptionHandlers[exceptionHandlers.length - 1];\n\n                        // Restore stack to the state when try block started\n                        stack.length = handler.stackSize;\n\n                        // Jump to catch handler if it exists, otherwise jump to finally\n                        if (handler.catchIndex !== undefined) {\n                            // Push the exception onto stack (will be stored by CATCH_START)\n                            stack.push(exception);\n                            pc = handler.catchIndex;\n                            // Clear catchIndex so next exception goes to finally\n                            // This handles exceptions thrown from within the catch block\n                            handler.catchIndex = undefined;\n                            // If there's a finally block, keep handler for potential re-throw from catch\n                            if (handler.finallyIndex === undefined) {\n                                // No finally block, pop the handler\n                                exceptionHandlers.pop();\n                            }\n                        } else if (handler.finallyIndex !== undefined) {\n                            pc = handler.finallyIndex;\n                            // Store the exception as pending - it will be re-thrown after finally\n                            handler.pendingException = exception;\n                            // Don't pop handler yet - FINALLY_START will do it\n                        } else {\n                            // No catch or finally, jump to end\n                            pc = handler.endIndex;\n                            exceptionHandlers.pop();\n                        }\n\n                        // Re-enter the execution loop - continue from catch/finally handler\n                        // Since we're now outside the while loop (caught by outer try-catch),\n                        // we need to recursively re-enter the execution\n                        // This is safe because we've updated pc to the catch/finally handler\n                        continue;\n                    }\n\n                    // No exception handler found - re-throw to JavaScript\n                    throw exception;"
      }, t.getFunctionNameBindingTemplate = function () {
        return "                // Bind function name for named function expressions\n                // Named function expressions have their name visible inside the function scope\n                // We bind it to env.vars so it's available for recursive calls\n                if (bc.ni !== undefined && currentFunc) {\n                    const funcName = bc.c[bc.ni];\n                    env.vars[funcName] = currentFunc;\n                    // Mark as const so it can't be reassigned\n                    if (!env.constVars) {\n                        env.constVars = {};\n                    }\n                    env.constVars[funcName] = true;\n                    // Set the function's .name property for introspection\n                    // This allows constructor.name and function.name to work correctly\n                    try {\n                        Object.defineProperty(currentFunc, 'name', {\n                            value: funcName,\n                            writable: false,\n                            enumerable: false,\n                            configurable: true\n                        });\n                    } catch (e) {\n                        // Ignore errors if name property can't be set\n                    }\n                }"
      }
    }, 67935: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getControlFlowOpcodeTemplates = function () {
        return "\n                        // Control Flow\n                        case opMap[50]: { // JUMP\n                            pc = decodeJump(jumpTargets[pc]);\n                            break;\n                        }\n\n                        case opMap[51]: { // JUMP_IF_TRUE\n                            if (stack.pop()) {\n                                pc = decodeJump(jumpTargets[pc]);\n                            } else {\n                                pc++;\n                            }\n                            break;\n                        }\n\n                        case opMap[52]: { // JUMP_IF_FALSE\n                            if (!stack.pop()) {\n                                pc = decodeJump(jumpTargets[pc]);\n                            } else {\n                                pc++;\n                            }\n                            break;\n                        }\n\n                        case opMap[53]: { // JUMP_NULLISH\n                            let val = stack.pop();\n                            if (val !== null && val !== undefined) {\n                                pc = decodeJump(jumpTargets[pc]);\n                            } else {\n                                pc++;\n                            }\n                            break;\n                        }\n\n                        case opMap[54]: { // CALL\n                            let argCount = stack.pop();\n                            let fn = stack.pop();\n                            stack.push(fn.apply(undefined, collectArgs(stack, argCount)));\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[55]: { // CALL_METHOD\n                            let argCount = stack.pop();\n                            let method = stack.pop();\n                            let obj = stack.pop();\n                            if (typeof method !== 'function') {\n                                throw new TypeError(method + ' is not a function');\n                            }\n                            stack.push(method.apply(obj, collectArgs(stack, argCount)));\n                            pc++;\n                            break;\n                        }                            \n\n                        case opMap[56]: { // RETURN\n                            if (exceptionHandlers.length > 0) {\n                                let handler = exceptionHandlers[exceptionHandlers.length - 1];\n                                if (handler.finallyIndex !== undefined) {\n                                    pendingReturn.hasReturn = true;\n                                    pendingReturn.value = stack.pop();\n                                    pc = handler.finallyIndex;\n                                    break;\n                                }\n                            }\n                            if (pendingReturn.hasReturn) {\n                                pendingReturn.hasReturn = false;\n                                pendingReturn.value = undefined;\n                            }\n                            return stack.pop();\n                        }\n\n                        case opMap[57]: { // THROW\n                            throw stack.pop();\n                        }\n\n                        case opMap[63]: { // BREAK\n                            if (exceptionHandlers.length > 0) {\n                                let handler = exceptionHandlers[exceptionHandlers.length - 1];\n                                if (handler.finallyIndex !== undefined) {\n                                    pendingBreak.hasBreak = true;\n                                    pendingBreak.target = decodeJump(jumpTargets[pc]);\n                                    pc = handler.finallyIndex;\n                                    break;\n                                }\n                            }\n                            pc = decodeJump(jumpTargets[pc]);\n                            break;\n                        }\n\n                        case opMap[64]: { // CONTINUE\n                            if (exceptionHandlers.length > 0) {\n                                let handler = exceptionHandlers[exceptionHandlers.length - 1];\n                                if (handler.finallyIndex !== undefined) {\n                                    pendingContinue.hasContinue = true;\n                                    pendingContinue.target = decodeJump(jumpTargets[pc]);\n                                    pc = handler.finallyIndex;\n                                    break;\n                                }\n                            }\n                            pc = decodeJump(jumpTargets[pc]);\n                            break;\n                        }\n    "
      }
    }, 68113: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ImportMetaObfuscationGuard = void 0;
      const n = r(45337), i = r(62467), a = r(27391);
      let s = class {
        check(e) {
          const t = a.NodeGuards.isMetaPropertyNode(e),
            r = !!(null == e ? void 0 : e.parentNode) && a.NodeGuards.isMetaPropertyNode(e.parentNode);
          return t || r ? i.ObfuscatingGuardResult.Ignore : i.ObfuscatingGuardResult.Transform
        }
      };
      t.ImportMetaObfuscationGuard = s, t.ImportMetaObfuscationGuard = s = o([(0, n.injectable)()], s)
    }, 68289: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.RenamePropertiesMode = void 0;
      const o = r(39079);
      t.RenamePropertiesMode = o.Utils.makeEnum({ Safe: "safe", Unsafe: "unsafe" })
    }, 68351: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LiteralNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(50164),
        y = r(8053), S = r(93571);
      let N = class extends y.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e) {
          this.literalNode = e
        }

        getNodeStructure() {
          return [S.NodeFactory.expressionStatementNode(this.literalNode)]
        }
      };
      t.LiteralNode = N, s([(0, h.initializable)(), c("design:type", Object)], N.prototype, "literalNode", void 0), t.LiteralNode = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 68418: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), d = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), p = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, u = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && l(t, e, r[n]);
        return d(t, e), t
      }), f = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, m = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayControlFlowTransformer = void 0;
      const g = r(45337), h = r(31391), y = u(r(31659)), S = r(46300), N = r(74593), b = r(38914), _ = r(76393),
        v = r(31142), I = r(80935), O = r(16868), C = r(93184), E = r(75716), T = r(92486), R = r(73534), M = r(27391);
      let A = class extends R.FunctionControlFlowTransformer {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n), this.runAfter = [T.NodeTransformer.StringArrayTransformer, T.NodeTransformer.StringArrayRotateFunctionTransformer, T.NodeTransformer.StringArrayScopeCallsWrapperTransformer], this.controlFlowReplacersMap = new Map([[C.NodeType.Literal, I.ControlFlowReplacer.StringArrayCallControlFlowReplacer]]), this.controlFlowStorageNodes = new WeakSet, this.controlFlowStorageFactory = e(O.ControlFlowStorage.StringControlFlowStorage)
        }

        getVisitor(e) {
          return this.options.stringArrayCallsTransform && e === E.NodeTransformationStage.StringArray ? {
            leave: (e, t) => {
              if (t && M.NodeGuards.isFunctionNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformFunctionBodyNode(e, t, r, o) {
          return M.NodeGuards.isVariableDeclarationNode(e) && this.controlFlowStorageNodes.has(e) ? y.VisitorOption.Skip : super.transformFunctionBodyNode(e, t, r, o)
        }

        getControlFlowStorage(e) {
          return this.controlFlowStorageFactory()
        }

        appendControlFlowStorageNode(e, t) {
          super.appendControlFlowStorageNode(e, t), this.controlFlowStorageNodes.add(t)
        }

        isAllowedTransformationByThreshold() {
          return this.randomGenerator.getMathRandom() <= this.options.stringArrayCallsTransformThreshold
        }
      };
      t.StringArrayControlFlowTransformer = A, t.StringArrayControlFlowTransformer = A = p([(0, g.injectable)(), m(0, (0, g.inject)(h.ServiceIdentifiers.Factory__TControlFlowStorage)), m(1, (0, g.inject)(h.ServiceIdentifiers.Factory__IControlFlowReplacer)), m(2, (0, g.inject)(h.ServiceIdentifiers.Factory__IControlFlowCustomNode)), m(3, (0, g.inject)(h.ServiceIdentifiers.IRandomGenerator)), m(4, (0, g.inject)(h.ServiceIdentifiers.IOptions)), f("design:paramtypes", ["function" == typeof (n = void 0 !== b.TControlFlowStorageFactoryCreator && b.TControlFlowStorageFactoryCreator) ? n : Object, "function" == typeof (i = void 0 !== N.TControlFlowReplacerFactory && N.TControlFlowReplacerFactory) ? i : Object, "function" == typeof (a = void 0 !== S.TControlFlowCustomNodeFactory && S.TControlFlowCustomNodeFactory) ? a : Object, "function" == typeof (s = void 0 !== v.IRandomGenerator && v.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== _.IOptions && _.IOptions) ? c : Object])], A)
    }, 68431: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BlockStatementDeadCodeInjectionNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(8053),
        y = r(93571), S = r(33056);
      let N = class extends h.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e, t) {
          this.blockStatementNode = e, this.deadCodeInjectionRootAstHostNode = t
        }

        getNode() {
          return this.getNodeStructure()
        }

        getNodeStructure() {
          const e = Math.random() > .5, t = Math.random() > .5, r = e ? "===" : "!==",
            o = this.randomGenerator.getRandomString(5),
            n = t ? o : this.randomGenerator.getRandomString(5), [i, a] = e === t ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode] : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode],
            s = y.NodeFactory.blockStatementNode([y.NodeFactory.ifStatementNode(y.NodeFactory.binaryExpressionNode(r, y.NodeFactory.literalNode(o), y.NodeFactory.literalNode(n)), i, a)]);
          return S.NodeUtils.parentizeAst(s), [s]
        }
      };
      t.BlockStatementDeadCodeInjectionNode = N, t.BlockStatementDeadCodeInjectionNode = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 68581: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMDeadCodeInjector = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(25115);
      let f = class {
        constructor(e, t) {
          this.injectionProbability = .3, this.minInstructionGap = 5, this.options = e, this.randomGenerator = t
        }

        injectDeadCode(e) {
          if (!this.options.vmDeadCodeInjection) return e;
          if (e.instructions.length < 10) return e;
          const t = [...e.instructions], r = [...e.constants], o = this.findInjectionPoints(t);
          let n = 0;
          for (let e = o.length - 1; e >= 0; e--) if (this.randomGenerator.getMathRandom() <= this.injectionProbability) {
            const i = o[e], a = this.generateDeadCodeBlock(r, i);
            if (t.splice(i, 0, ...a), this.adjustJumpTargets(t, i, a.length, i + a.length), n++, n >= 3) break
          }
          return { ...e, instructions: t, constants: r }
        }

        findInjectionPoints(e) {
          const t = [];
          let r = 0;
          for (let o = 1; o < e.length - 1; o++) {
            if (o - r < this.minInstructionGap) continue;
            const n = e[o - 1], i = e[o];
            this.isJumpInstruction(n) || i.op !== u.VMOpCode.RETURN && n.op !== u.VMOpCode.TRY_START && i.op !== u.VMOpCode.TRY_END && (t.push(o), r = o)
          }
          return t
        }

        generateDeadCodeBlock(e, t) {
          const r = [];
          switch (this.randomGenerator.getRandomInteger(0, 2)) {
            case 0:
              this.generateSquareGeZeroPredicate(r, e);
              break;
            case 1:
              this.generateOrOneNotZeroPredicate(r, e);
              break;
            case 2:
              this.generateAndSelfEqualsPredicate(r, e)
          }
          const o = this.randomGenerator.getRandomInteger(3, 6),
            n = { op: u.VMOpCode.JUMP_IF_TRUE, target: t + r.length + 1 + o + 1 };
          return r.push(n), this.generatePlausibleDeadCode(r, e, o), r
        }

        generateSquareGeZeroPredicate(e, t) {
          const r = this.randomGenerator.getRandomInteger(1, 100), o = this.addConstant(t, r);
          e.push({ op: u.VMOpCode.PUSH_CONST, arg: o }), e.push({ op: u.VMOpCode.DUP }), e.push({ op: u.VMOpCode.MUL });
          const n = this.addConstant(t, 0);
          e.push({ op: u.VMOpCode.PUSH_CONST, arg: n }), e.push({ op: u.VMOpCode.GTE })
        }

        generateOrOneNotZeroPredicate(e, t) {
          const r = this.randomGenerator.getRandomInteger(0, 1e3), o = this.addConstant(t, r);
          e.push({ op: u.VMOpCode.PUSH_CONST, arg: o });
          const n = this.addConstant(t, 1);
          e.push({ op: u.VMOpCode.PUSH_CONST, arg: n }), e.push({ op: u.VMOpCode.BIT_OR });
          const i = this.addConstant(t, 0);
          e.push({ op: u.VMOpCode.PUSH_CONST, arg: i }), e.push({ op: u.VMOpCode.NEQ })
        }

        generateAndSelfEqualsPredicate(e, t) {
          const r = this.randomGenerator.getRandomInteger(1, 100), o = this.addConstant(t, r);
          e.push({
            op: u.VMOpCode.PUSH_CONST,
            arg: o
          }), e.push({ op: u.VMOpCode.DUP }), e.push({ op: u.VMOpCode.DUP }), e.push({ op: u.VMOpCode.BIT_AND }), e.push({ op: u.VMOpCode.EQ })
        }

        generatePlausibleDeadCode(e, t, r) {
          for (let o = 0; o < r; o++) switch (this.randomGenerator.getRandomInteger(0, 4)) {
            case 0: {
              const r = this.randomGenerator.getRandomInteger(0, 100), o = this.addConstant(t, r);
              e.push({ op: u.VMOpCode.PUSH_CONST, arg: o });
              break
            }
            case 1:
              if (o > 0) {
                const t = [u.VMOpCode.ADD, u.VMOpCode.SUB, u.VMOpCode.MUL];
                e.push({ op: t[this.randomGenerator.getRandomInteger(0, t.length - 1)] })
              } else e.push({ op: u.VMOpCode.NOP });
              break;
            case 2:
              o > 0 ? e.push({ op: u.VMOpCode.POP }) : e.push({ op: u.VMOpCode.NOP });
              break;
            case 3:
              e.push({ op: u.VMOpCode.PUSH_UNDEFINED });
              break;
            case 4:
              e.push({ op: u.VMOpCode.NOP })
          }
          e.push({ op: u.VMOpCode.POP })
        }

        addConstant(e, t) {
          const r = e.indexOf(t);
          return -1 !== r ? r : (e.push(t), e.length - 1)
        }

        isJumpInstruction(e) {
          return e.op === u.VMOpCode.JUMP || e.op === u.VMOpCode.JUMP_IF_TRUE || e.op === u.VMOpCode.JUMP_IF_FALSE || e.op === u.VMOpCode.JUMP_NULLISH || e.op === u.VMOpCode.BREAK || e.op === u.VMOpCode.CONTINUE
        }

        adjustJumpTargets(e, t, r, o) {
          for (let n = 0; n < e.length; n++) {
            if (n >= t && n < o) continue;
            const i = e[n];
            this.adjustJumpInstructionTarget(i, t, r), this.adjustTryStartIndices(i, t, r)
          }
        }

        adjustJumpInstructionTarget(e, t, r) {
          this.isJumpInstruction(e) && "target" in e && e.target >= t && (e.target += r)
        }

        adjustTryStartIndices(e, t, r) {
          if (e.op !== u.VMOpCode.TRY_START) return;
          const o = e;
          void 0 !== o.catchIndex && o.catchIndex >= t && (o.catchIndex += r), void 0 !== o.finallyIndex && o.finallyIndex >= t && (o.finallyIndex += r), o.endIndex >= t && (o.endIndex += r)
        }
      };
      t.VMDeadCodeInjector = f, t.VMDeadCodeInjector = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IOptions)), s(1, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), a("design:paramtypes", ["function" == typeof (o = void 0 !== d.IOptions && d.IOptions) ? o : Object, "function" == typeof (n = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? n : Object])], f)
    }, 68934: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 69112: function (e, t, r) {
      var o, n = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), a = 0; a < r.length; a++) "default" !== r[a] && n(t, e, r[a]);
        return i(t, e), t
      });
      Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionExpressionCalleeDataExtractor = void 0;
      const c = r(45337), l = s(r(31659)), d = r(75476), p = r(27391), u = r(43243);
      let f = class extends d.AbstractCalleeDataExtractor {
        extract(e, t) {
          let r = null, o = null;
          return p.NodeGuards.isIdentifierNode(t) ? (r = t.name, o = this.getCalleeBlockStatement(u.NodeStatementUtils.getParentNodeWithStatements(e[0]), t.name)) : p.NodeGuards.isFunctionExpressionNode(t) && (r = null, o = t.body), o ? {
            callee: o,
            name: r
          } : null
        }

        getCalleeBlockStatement(e, t) {
          let r = null;
          return l.traverse(e, {
            enter: (e, o) => {
              if (p.NodeGuards.isFunctionExpressionNode(e) && o && p.NodeGuards.isVariableDeclaratorNode(o) && p.NodeGuards.isIdentifierNode(o.id) && o.id.name === t) return r = e.body, l.VisitorOption.Break
            }
          }), r
        }
      };
      t.FunctionExpressionCalleeDataExtractor = f, t.FunctionExpressionCalleeDataExtractor = f = a([(0, c.injectable)()], f)
    }, 69684: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.EscapeSequenceEncoder = void 0;
      const i = r(45337);
      let a = o = class {
        constructor() {
          this.stringsCache = new Map
        }

        encode(e, t) {
          const r = `${e}-${String(t)}`;
          if (this.stringsCache.has(r)) return this.stringsCache.get(r);
          const n = new RegExp("[\\s\\S]", "g");
          let i, a;
          const s = e.replace(n, e => t || o.forceEscapeCharactersRegExp.test(e) ? (o.ASCIICharactersRegExp.test(e) ? (i = "\\x", a = "00") : (i = "\\u", a = "0000"), `${i}${(a + e.charCodeAt(0).toString(16)).slice(-a.length)}`) : e);
          return this.stringsCache.set(r, s), this.stringsCache.set(`${s}-${String(t)}`, s), s
        }
      };
      t.EscapeSequenceEncoder = a, a.ASCIICharactersRegExp = /[\x00-\x7F]/, a.forceEscapeCharactersRegExp = /[\x00-\x1F\x7F-\x9F'"\\\s]/, t.EscapeSequenceEncoder = a = o = n([(0, i.injectable)()], a)
    }, 69904: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayTemplate = function () {
        return "\n        function {stringArrayFunctionName} () {\n            const {stringArrayName} = [{stringArrayStorageItems}];\n            \n            {stringArrayFunctionName} = function () {\n                return {stringArrayName};\n            };\n            \n            return {stringArrayFunctionName}();\n        }\n    "
      }
    }, 70072: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMParameterBytecodeCompiler = void 0;
      const c = r(45337), l = r(20924), d = r(94487), p = r(31391), u = r(27391);
      let f = class {
        constructor(e, t) {
          this.vmCompilerUtils = e, this.scopeManager = t
        }

        compileParameters(e, t) {
          var r, o;
          let n = null, i = null, a = 0;
          const s = [], c = [];
          e && e.forEach((e, r) => {
            if (e) if (u.NodeGuards.isIdentifierNode(e)) t.parameters.set(e.name, r), a++; else if (u.NodeGuards.isAssignmentPatternNode(e)) u.NodeGuards.isIdentifierNode(e.left) ? (t.parameters.set(e.left.name, r), a++, s.push({
              paramIndex: r,
              defaultExpr: e.right
            })) : (u.NodeGuards.isArrayPatternNode(e.left) || u.NodeGuards.isObjectPatternNode(e.left)) && (a++, c.push({
              paramIndex: r,
              pattern: e.left
            }), s.push({ paramIndex: r, defaultExpr: e.right })); else if (u.NodeGuards.isRestElementNode(e)) {
              if (u.NodeGuards.isIdentifierNode(e.argument)) {
                n = e.argument.name;
                const r = t.localVariables.size;
                t.localVariables.set(n, r)
              } else if (u.NodeGuards.isArrayPatternNode(e.argument) || u.NodeGuards.isObjectPatternNode(e.argument)) {
                i = e.argument, n = "__rest_temp__";
                const r = t.localVariables.size;
                t.localVariables.set(n, r)
              }
            } else (u.NodeGuards.isArrayPatternNode(e) || u.NodeGuards.isObjectPatternNode(e)) && (a++, c.push({
              paramIndex: r,
              pattern: e
            }))
          });
          const l = this.vmCompilerUtils.createInstructionBuilder(t);
          for (const [e, r] of t.parameters) t.envVars.has(e) && (l.loadArg(r), l.storeToEnvByName(e), l.pop());
          for (const { paramIndex: e, defaultExpr: o } of s) {
            l.loadArg(e);
            const n = l.emitUndefinedCheck();
            l.pop();
            const i = [];
            for (const [r, o] of t.parameters) o >= e && i.push(r);
            this.scopeManager.enterParametersTDZ(t, i), null === (r = t.dispatch) || void 0 === r || r.expression(o), l.storeArg(e);
            let a = null;
            for (const [r, o] of t.parameters) if (o === e) {
              a = r;
              break
            }
            a && t.envVars.has(a) && (l.loadArg(e), l.storeToEnvByName(a), l.pop());
            const s = l.jump();
            n.patchToHere(), l.pop(), s.patchToHere()
          }
          this.scopeManager.clearParametersTDZ(t), null !== n && this.vmCompilerUtils.emitRestParameterHandling(n, i, a, t);
          for (const {
            paramIndex: e,
            pattern: r
          } of c) l.loadArg(e), null === (o = t.dispatch) || void 0 === o || o.destructuring(r, !1);
          return a
        }
      };
      t.VMParameterBytecodeCompiler = f, t.VMParameterBytecodeCompiler = f = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IVMCompilerUtils)), s(1, (0, c.inject)(p.ServiceIdentifiers.IVMScopeManager)), a("design:paramtypes", ["function" == typeof (o = void 0 !== l.IVMCompilerUtils && l.IVMCompilerUtils) ? o : Object, "function" == typeof (n = void 0 !== d.IVMScopeManager && d.IVMScopeManager) ? n : Object])], f)
    }, 70475: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 70793: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 70858: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 70881: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, d = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, p = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CallsControllerFunctionCodeHelper = void 0;
      const u = r(45337), f = r(31391), m = r(18741), g = r(25714), h = r(39032), y = r(76393), S = r(31142),
        N = r(75716), b = r(50164), _ = r(58188), v = r(48222), I = r(33056);
      let O = class extends v.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t) {
          this.nodeTransformationStage = e, this.callsControllerFunctionName = t
        }

        getNodeStructure(e) {
          return I.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          return this.nodeTransformationStage === N.NodeTransformationStage.Finalizing ? this.customCodeHelperObfuscator.obfuscateTemplate(this.customCodeHelperFormatter.formatTemplate((0, _.SingleCallControllerTemplate)(), { callControllerFunctionName: this.callsControllerFunctionName })) : this.customCodeHelperFormatter.formatTemplate((0, _.SingleCallControllerTemplate)(), { callControllerFunctionName: this.callsControllerFunctionName })
        }
      };
      t.CallsControllerFunctionCodeHelper = O, l([(0, b.initializable)(), d("design:type", String)], O.prototype, "callsControllerFunctionName", void 0), l([(0, b.initializable)(), d("design:type", "function" == typeof (c = void 0 !== N.NodeTransformationStage && N.NodeTransformationStage) ? c : Object)], O.prototype, "nodeTransformationStage", void 0), t.CallsControllerFunctionCodeHelper = O = l([(0, u.injectable)(), p(0, (0, u.inject)(f.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), p(1, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperFormatter)), p(2, (0, u.inject)(f.ServiceIdentifiers.ICustomCodeHelperObfuscator)), p(3, (0, u.inject)(f.ServiceIdentifiers.IRandomGenerator)), p(4, (0, u.inject)(f.ServiceIdentifiers.IOptions)), d("design:paramtypes", ["function" == typeof (o = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== h.ICustomCodeHelperFormatter && h.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== y.IOptions && y.IOptions) ? s : Object])], O)
    }, 71024: e => {
      e.exports = require("chance")
    }, 71389: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SetUtils = void 0;
      const s = r(45337), c = r(31391), l = r(26906);
      let d = class {
        constructor(e) {
          this.arrayUtils = e
        }

        getLastElement(e) {
          const t = [...e];
          return this.arrayUtils.getLastElement(t)
        }
      };
      t.SetUtils = d, t.SetUtils = d = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.IArrayUtils)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.IArrayUtils && l.IArrayUtils) ? o : Object])], d)
    }, 72083: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CryptUtilsStringArray = void 0;
      const s = r(45337), c = r(31391), l = r(31142), d = r(38606), p = r(95225);
      let u = class extends p.CryptUtils {
        constructor(e) {
          super(e), this.base64Alphabet = d.base64alphabetSwapped
        }

        btoa(e) {
          return super.btoa(e).replace(/=+$/, "")
        }
      };
      t.CryptUtilsStringArray = u, t.CryptUtilsStringArray = u = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.IRandomGenerator)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.IRandomGenerator && l.IRandomGenerator) ? o : Object])], u)
    }, 72282: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 72849: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.analyzersModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(21593), s = r(3147), c = r(52240), l = r(69112),
        d = r(59228), p = r(86249), u = r(9955), f = r(51254), m = r(28240);
      t.analyzersModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.ICallsGraphAnalyzer).to(s.CallsGraphAnalyzer).inSingletonScope(), e(i.ServiceIdentifiers.INumberNumericalExpressionAnalyzer).to(d.NumberNumericalExpressionAnalyzer).inSingletonScope(), e(i.ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer).to(u.PrevailingKindOfVariablesAnalyzer).inSingletonScope(), e(i.ServiceIdentifiers.IScopeAnalyzer).to(f.ScopeAnalyzer).inSingletonScope(), e(i.ServiceIdentifiers.IStringArrayStorageAnalyzer).to(m.StringArrayStorageAnalyzer).inSingletonScope(), e(i.ServiceIdentifiers.ICalleeDataExtractor).to(c.FunctionDeclarationCalleeDataExtractor).whenTargetNamed(a.CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor), e(i.ServiceIdentifiers.ICalleeDataExtractor).to(l.FunctionExpressionCalleeDataExtractor).whenTargetNamed(a.CalleeDataExtractor.FunctionExpressionCalleeDataExtractor), e(i.ServiceIdentifiers.ICalleeDataExtractor).to(p.ObjectExpressionCalleeDataExtractor).whenTargetNamed(a.CalleeDataExtractor.ObjectExpressionCalleeDataExtractor), e(i.ServiceIdentifiers.Factory__ICalleeDataExtractor).toFactory(o.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.ICalleeDataExtractor))
      })
    }, 73534: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), p = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), u = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, f = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && d(t, e, r[n]);
        return p(t, e), t
      }), m = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, g = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.FunctionControlFlowTransformer = void 0;
      const h = r(45337), y = r(31391), S = f(r(31659)), N = r(46300), b = r(74593), _ = r(38914), v = r(76393),
        I = r(31142), O = r(62059), C = r(80935), E = r(16868), T = r(93184), R = r(75716), M = r(13245), A = r(47250),
        F = r(27391), P = r(4592), D = r(43243), j = r(33056);
      let x = n = class extends M.AbstractNodeTransformer {
        constructor(e, t, r, o, n) {
          super(o, n), this.controlFlowReplacersMap = new Map([[T.NodeType.BinaryExpression, C.ControlFlowReplacer.BinaryExpressionControlFlowReplacer], [T.NodeType.CallExpression, C.ControlFlowReplacer.CallExpressionControlFlowReplacer], [T.NodeType.LogicalExpression, C.ControlFlowReplacer.LogicalExpressionControlFlowReplacer], [T.NodeType.Literal, C.ControlFlowReplacer.StringLiteralControlFlowReplacer]]), this.controlFlowData = new WeakMap, this.hostNodesWithControlFlowNode = new WeakMap, this.visitedFunctionNodes = new WeakSet, this.controlFlowStorageFactory = e(E.ControlFlowStorage.FunctionControlFlowStorage), this.controlFlowReplacerFactory = t, this.controlFlowCustomNodeFactory = r
        }

        getVisitor(e) {
          return this.options.controlFlowFlattening && e === R.NodeTransformationStage.ControlFlowFlattening ? {
            leave: (e, t) => {
              if (t && F.NodeGuards.isFunctionNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (this.visitedFunctionNodes.add(e), !F.NodeGuards.isBlockStatementNode(e.body)) return e;
          const r = this.getHostNode(e.body), o = this.getControlFlowStorage(r);
          if (this.transformFunctionBody(e, o), !o.getLength()) return e;
          const n = this.getControlFlowStorageNode(o);
          return this.appendControlFlowStorageNode(r, n), e
        }

        transformFunctionBody(e, t) {
          S.replace(e.body, { enter: (r, o) => this.transformFunctionBodyNode(r, o, e, t) })
        }

        transformFunctionBodyNode(e, t, r, o) {
          var n;
          if (!t || P.NodeMetadata.isIgnoredNode(e) || this.isVisitedFunctionNode(e)) return S.VisitorOption.Skip;
          const i = null !== (n = this.controlFlowReplacersMap.get(e.type)) && void 0 !== n ? n : null;
          if (!i) return e;
          if (!this.isAllowedTransformationByThreshold()) return e;
          const a = this.controlFlowReplacerFactory(i).replace(e, t, o);
          return j.NodeUtils.parentizeNode(a, t), a
        }

        getHostNode(e) {
          const t = D.NodeStatementUtils.getParentNodesWithStatements(e);
          return 1 === t.length ? e : (t.pop(), t.length > n.hostNodeSearchMinDepth && t.splice(0, n.hostNodeSearchMinDepth), t.length > n.hostNodeSearchMaxDepth && (t.length = n.hostNodeSearchMaxDepth), this.randomGenerator.getRandomGenerator().pickone(t))
        }

        getControlFlowStorage(e) {
          var t, r;
          let o;
          const n = null !== (t = this.controlFlowData.get(e)) && void 0 !== t ? t : null;
          if (n) {
            const t = null !== (r = this.hostNodesWithControlFlowNode.get(e)) && void 0 !== r ? r : null;
            t && A.NodeAppender.remove(e, t), o = n
          } else o = this.controlFlowStorageFactory();
          return this.controlFlowData.set(e, o), o
        }

        getControlFlowStorageNode(e) {
          const t = this.controlFlowCustomNodeFactory(O.ControlFlowCustomNode.ControlFlowStorageNode);
          t.initialize(e);
          const r = t.getNode()[0];
          if (!F.NodeGuards.isVariableDeclarationNode(r)) throw new Error("`controlFlowStorageNode` should contain `VariableDeclaration` node with control flow storage object");
          return r
        }

        appendControlFlowStorageNode(e, t) {
          j.NodeUtils.parentizeAst(t), A.NodeAppender.prepend(e, [t]), this.hostNodesWithControlFlowNode.set(e, t)
        }

        isVisitedFunctionNode(e) {
          return F.NodeGuards.isFunctionNode(e) && this.visitedFunctionNodes.has(e)
        }

        isAllowedTransformationByThreshold() {
          return this.randomGenerator.getMathRandom() <= this.options.controlFlowFlatteningThreshold
        }
      };
      t.FunctionControlFlowTransformer = x, x.hostNodeSearchMinDepth = 0, x.hostNodeSearchMaxDepth = 2, t.FunctionControlFlowTransformer = x = n = u([(0, h.injectable)(), g(0, (0, h.inject)(y.ServiceIdentifiers.Factory__TControlFlowStorage)), g(1, (0, h.inject)(y.ServiceIdentifiers.Factory__IControlFlowReplacer)), g(2, (0, h.inject)(y.ServiceIdentifiers.Factory__IControlFlowCustomNode)), g(3, (0, h.inject)(y.ServiceIdentifiers.IRandomGenerator)), g(4, (0, h.inject)(y.ServiceIdentifiers.IOptions)), m("design:paramtypes", ["function" == typeof (i = void 0 !== _.TControlFlowStorageFactoryCreator && _.TControlFlowStorageFactoryCreator) ? i : Object, "function" == typeof (a = void 0 !== b.TControlFlowReplacerFactory && b.TControlFlowReplacerFactory) ? a : Object, "function" == typeof (s = void 0 !== N.TControlFlowCustomNodeFactory && N.TControlFlowCustomNodeFactory) ? s : Object, "function" == typeof (c = void 0 !== I.IRandomGenerator && I.IRandomGenerator) ? c : Object, "function" == typeof (l = void 0 !== v.IOptions && v.IOptions) ? l : Object])], x)
    }, 73566: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 73903: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 73921: e => {
      e.exports = require("stringz")
    }, 74341: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMRuntimeTemplate = function (e) {
        const { isNodeTarget: t, splitDispatcher: r = !1, macroOps: s = !1, indirectDispatch: c = !1 } = e;
        let l;
        l = c ? (0, o.getIndirectDispatchTemplate)(s) : r ? (0, o.getSplitDispatcherCases)(s) : `switch(op) {\n                            ${(0, o.getAllOpcodeCases)(s)}\n                            }`;
        const d = (0, n.getExceptionHandlerLogicTemplate)(), p = (0, i.getRuntimeHelpersTemplate)();
        return `\n        // Global variables storage for top-level const/let declarations\n        // Store directly on global object so it's accessible to all VM functions via LOAD_GLOBAL fallback\n        // IMPORTANT: Reuse existing vmGlobals if it exists (multiple VM runtimes in same module share it)\n        let {vmGlobalsName} = (typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : global))[{vmGlobalsNameString}] || ((typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : global))[{vmGlobalsNameString}] = {});\n        ${t ? (0, a.getNodeModuleVarsCaptureTemplate)() : ""}\n        // Keep vmModuleVarsName for backward compatibility and explicit checks\n        let {vmModuleVarsName} = {vmGlobalsName};\n\n        const {vmExecutorName} = (function() {\n            // VM bytecode storage\n            let {vmBytecodeArrayName} = {bytecodeArray};\n\n            // Bytecode key mapping (when vmRandomizeKeys is enabled)\n            {keyMappingDeclaration}\n{binaryDecoderFunctions}\n{bytecodeArrayEncodingFunctions}\n{bytecodePreprocessing}\n            // Opcode mapping (randomized per session)\n            let {vmOpcodeMapName} = {opcodeMapping};\n${p}\n{opcodeDerivationFunctions}\n{stateMachineFunctions}\n            /**\n             * Core VM Executor (Generator)\n             * Contains opcode switch once, yields at AWAIT/YIELD/YIELD_STAR points.\n             * All variables stay in same scope so closures work correctly.\n             */\n            function* _coreExec(bc, args, parentEnv, currentFunc, newTarget, _this) {\n                let stack = [];\n                let locals = new Array((bc[{keyP}] || 0) + (bc[{keyL}] || 0));\n                let pc = 0;\n                let constants = bc[{keyC}];\n                let instructions = bc[{keyI}];\n                let jumpTargets = bc[{keyJ}] || {};\n                let exHandlers = bc[{keyX}] || {};\n                let instrCount = instructions.length >> 1;\n\n                let exceptionHandlers = [];\n                let pendingException = null;\n                let pendingReturn = { hasReturn: false, value: undefined };\n                let pendingBreak = { hasBreak: false, target: 0 };\n                let pendingContinue = { hasContinue: false, target: 0 };\n\n                // Use per-function opcode map if present (vmOpcodeShuffle), otherwise use global map\n                let opMap = bc[{keyO}] || {vmOpcodeMapName};\n{opcodeDerivationInit}\n{stateMachineInit}\n{stackEncodingInit}\n                // Jump XOR key for decoding (when vmJumpsEncoding is enabled)\n                let jumpKey = bc[{keyJk}] || 0;\n\n                // Bytecode XOR key for decoding (when vmBytecodeEncoding is enabled)\n                let bytecodeKey = bc[{keyBk}] || 0;\n\n                // Helper to decode jump target\n                let decodeJump = function(encoded) {\n                    return jumpKey ? (encoded ^ jumpKey) : encoded;\n                };\n\n                // Helper to decode bytecode value\n                let decodeBytecode = function(encoded) {\n                    return bytecodeKey ? (encoded ^ bytecodeKey) : encoded;\n                };\n\n                let env = { parent: parentEnv, vars: {} };\n\n                // Initialize parameters\n                if (args) {\n                    for (let _i = 0; _i < Math.min(args.length, bc[{keyP}] || 0); _i++) {\n                        locals[_i] = args[_i];\n                    }\n                }\n\n                // Function name binding for named function expressions\n                if (bc[{keyNi}] !== undefined && currentFunc) {\n                    let funcName = bc[{keyC}][bc[{keyNi}]];\n                    env.vars[funcName] = currentFunc;\n                    if (!env.constVars) env.constVars = {};\n                    env.constVars[funcName] = true;\n                    try {\n                        Object.defineProperty(currentFunc, 'name', {\n                            value: funcName, writable: false, enumerable: false, configurable: true\n                        });\n                    } catch (e) {}\n                }\n\n                // Debug protection check counter (check every 100 instructions)\n                let _dbgCheckCounter = 0;\n\n                // Main execution loop - flat array format: [op, arg, op, arg, ...]\n                while (pc < instrCount) {\n                    try {\n                        while (pc < instrCount) {\n                            // Debug protection: periodic timing check (when vmDebugProtection is enabled)\n                            if (++_dbgCheckCounter > 100) {\n                                _dbgCheckCounter = 0;\n                                _checkDebug();\n                            }\n\n                            let flatIdx = pc << 1;\n                            // Decode opcode (XOR with bytecodeKey if enabled)\n                            let physicalOp = decodeBytecode(instructions[flatIdx]);\n                            // Apply state machine decoding if enabled (physicalOp -> logicalOp)\n                            // State is computed from seed and pc (position-based, not history-based)\n                            let logicalOp = physicalOp;\n                            if (_smStateMaps) {\n                                let _smState = _smComputeState(_smSeed, pc);\n                                let _smStateMap = _smStateMaps[_smState];\n                                if (_smStateMap) {\n                                    logicalOp = _smStateMap[physicalOp];\n                                }\n                            }\n                            let op = opMap[logicalOp];\n                            // Decode arg (XOR with bytecodeKey if enabled and arg is numeric)\n                            let rawArg = instructions[flatIdx + 1];\n                            let arg = (rawArg === null) ? undefined : (typeof rawArg === 'number' ? decodeBytecode(rawArg) : rawArg);\n\n                            // AWAIT - yield to async driver\n                            if (logicalOp === 122) {\n                                let awaitVal = stack.pop();\n                                let resolved = yield {t: 1, v: awaitVal};\n                                stack.push(resolved);\n                                pc++;\n                                continue;\n                            }\n\n                            // YIELD - yield to generator driver\n                            if (logicalOp === 120) {\n                                let yieldVal = stack.pop();\n                                let input = yield {t: 2, v: yieldVal};\n                                stack.push(input);\n                                pc++;\n                                continue;\n                            }\n\n                            // YIELD_STAR - delegate\n                            if (logicalOp === 121) {\n                                let iterable = stack.pop();\n                                let delegateResult = yield {t: 3, v: iterable};\n                                stack.push(delegateResult);\n                                pc++;\n                                continue;\n                            }\n\n                            ${l}\n                        }\n                        break;\n                    } catch (exception) {\n                        ${d}\n                    }\n                }\n\n                return stack.length > 0 ? stack.pop() : undefined;\n            }\n\n            /**\n             * Sync VM Executor - drives core generator to completion\n             */\n            let {vmExecutorName} = function(bytecodeId, args, parentEnv, currentFunc, newTarget) {\n                let bc = _getBytecode(bytecodeId);\n                let gen = _coreExec(bc, args, parentEnv, currentFunc, newTarget, this);\n                let result = gen.next();\n                while (!result.done) {\n                    // Sync context should never hit await/yield\n                    throw new Error('Unexpected async/generator operation in sync context');\n                }\n                return result.value;\n            };\n\n            /**\n             * Async VM Executor - drives core generator, awaits at AWAIT signals\n             */\n            let {vmAsyncExecutorName} = async function(bytecodeId, args, parentEnv, currentFunc, newTarget) {\n                let bc = _getBytecode(bytecodeId);\n                let gen = _coreExec(bc, args, parentEnv, currentFunc, newTarget, this);\n                let result = gen.next();\n\n                while (!result.done) {\n                    if (result.value.t === 1) { // AWAIT\n                        try {\n                            let resolved = await Promise.resolve(result.value.v);\n                            result = gen.next(resolved);\n                        } catch (e) {\n                            result = gen.throw(e);\n                        }\n                    } else {\n                        throw new Error('Unexpected yield in async context');\n                    }\n                }\n\n                return result.value;\n            };\n\n\n            /**\n             * Generator VM Executor - drives core generator, handles YIELD/YIELD_STAR\n             */\n            let {vmGeneratorExecutorName} = function(bytecodeId, args, parentEnv, currentFunc) {\n                let bc = _getBytecode(bytecodeId);\n                let gen = _coreExec(bc, args, parentEnv, currentFunc, undefined, this);\n                let done = false;\n                let currentDelegate = null;\n                let genThis = this;\n\n                function step(inputValue, isThrow) {\n                    if (done) return { value: undefined, done: true };\n\n                    // Handle active delegate first\n                    if (currentDelegate) {\n                        let delegateResult;\n                        try {\n                            delegateResult = isThrow\n                                ? (typeof currentDelegate.throw === 'function'\n                                    ? currentDelegate.throw(inputValue)\n                                    : (currentDelegate = null, (function() { throw inputValue; })()))\n                                : currentDelegate.next(inputValue);\n                        } catch (e) {\n                            currentDelegate = null;\n                            // Forward exception to core generator\n                            try {\n                                let r = gen.throw(e);\n                                return handleResult(r);\n                            } catch (e2) {\n                                done = true;\n                                throw e2;\n                            }\n                        }\n\n                        if (!delegateResult.done) {\n                            return { value: delegateResult.value, done: false };\n                        }\n                        // Delegate exhausted, send return value to core\n                        currentDelegate = null;\n                        inputValue = delegateResult.value;\n                        isThrow = false;\n                    }\n\n                    // Drive core generator\n                    let result;\n                    try {\n                        result = isThrow ? gen.throw(inputValue) : gen.next(inputValue);\n                    } catch (e) {\n                        done = true;\n                        throw e;\n                    }\n\n                    return handleResult(result);\n                }\n\n                function handleResult(result) {\n                    if (result.done) {\n                        done = true;\n                        return { value: result.value, done: true };\n                    }\n\n                    let sig = result.value;\n\n                    // YIELD signal (t:2)\n                    if (sig.t === 2) {\n                        return { value: sig.v, done: false };\n                    }\n\n                    // YIELD_STAR signal (t:3) - set up delegation\n                    if (sig.t === 3) {\n                        let iterable = sig.v;\n                        let iter = iterable;\n                        if (iter && typeof iter[Symbol.iterator] === 'function') {\n                            iter = iter[Symbol.iterator]();\n                        }\n                        if (iter && typeof iter.next === 'function') {\n                            let first = iter.next();\n                            if (!first.done) {\n                                currentDelegate = iter;\n                                return { value: first.value, done: false };\n                            }\n                            // Delegate immediately done, send return value back\n                            return step(first.value, false);\n                        }\n                        // Invalid iterator\n                        return step(undefined, false);\n                    }\n\n                    // Unexpected signal\n                    throw new Error('Unexpected signal in generator');\n                }\n\n                return {\n                    next: function(v) { return step(v, false); },\n                    return: function(v) {\n                        if (done) return { value: v, done: true };\n                        done = true;\n                        try { gen.return(v); } catch(e) {}\n                        return { value: v, done: true };\n                    },\n                    throw: function(e) {\n                        if (done) throw e;\n                        return step(e, true);\n                    },\n                    [Symbol.iterator]: function() { return this; }\n                };\n            };\n\n\n            // Return a dispatcher that chooses sync, async, or generator executor based on bytecode flags\n            // Must preserve 'this' context for non-arrow functions\n            return function(bytecodeId, args, parentEnv, currentFunc, newTarget) {\n                let bc = _getBytecode(bytecodeId);\n                if (bc && bc[{keyG}]) {\n                    // Generator bytecode - create and return generator object (bytecode executes on .next())\n                    return {vmGeneratorExecutorName}.call(this, bytecodeId, args, parentEnv, currentFunc);\n                } else if (bc && bc[{keyS}]) {\n                    // Async bytecode - use async executor\n                    return {vmAsyncExecutorName}.call(this, bytecodeId, args, parentEnv, currentFunc, newTarget);\n                } else {\n                    // Sync bytecode - use sync executor\n                    return {vmExecutorName}.call(this, bytecodeId, args, parentEnv, currentFunc, newTarget);\n                }\n            };\n        })();\n    `
      };
      const o = r(59641), n = r(67655), i = r(33636), a = r(93141)
    }, 74361: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BinaryWriter = t.FlagBits = t.ConstType = void 0, t.encodeBytecodeToBuffer = function (e, n) {
        const i = new r;
        i.writeUint8(1);
        let a = 0;
        e.isArrow && (a |= t.FlagBits.IsArrow), e.isAsync && (a |= t.FlagBits.IsAsync), e.isGenerator && (a |= t.FlagBits.IsGenerator), void 0 !== e.functionNameIndex && (a |= t.FlagBits.HasFunctionName), void 0 !== e.opcodeSeed && (a |= t.FlagBits.HasOpcodeSeed), e.opcodeMap && (a |= t.FlagBits.HasOpcodeMap), void 0 !== e.jumpKey && (a |= t.FlagBits.HasJumpKey), void 0 !== e.bytecodeKey && (a |= t.FlagBits.HasBytecodeKey), void 0 !== e.smSeed && (a |= t.FlagBits.HasSmSeed), void 0 !== e.smState && (a |= t.FlagBits.HasSmState), void 0 !== e.seKey && (a |= t.FlagBits.HasSeKey);
        const s = e.instructions.some(e => void 0 !== e.target),
          c = e.instructions.some(e => void 0 !== e.catchIndex || void 0 !== e.finallyIndex || void 0 !== e.endIndex);
        if (s && (a |= t.FlagBits.HasJumps), c && (a |= t.FlagBits.HasExceptions), i.writeUint16(a), i.writeVarint(e.params), i.writeVarint(e.locals), a & t.FlagBits.HasFunctionName && i.writeVarint(e.functionNameIndex), a & t.FlagBits.HasOpcodeSeed && i.writeUint32(e.opcodeSeed), a & t.FlagBits.HasOpcodeMap) {
          const t = Object.entries(e.opcodeMap);
          i.writeVarint(t.length);
          for (const [e, r] of t) i.writeVarint(parseInt(e, 10)), i.writeVarint(r)
        }
        a & t.FlagBits.HasJumpKey && i.writeUint32(e.jumpKey), a & t.FlagBits.HasBytecodeKey && i.writeUint32(e.bytecodeKey), a & t.FlagBits.HasSmSeed && i.writeUint32(e.smSeed), a & t.FlagBits.HasSmState && i.writeVarint(e.smState), a & t.FlagBits.HasSeKey && i.writeUint32(e.seKey), i.writeVarint(e.constants.length);
        for (const t of e.constants) o(i, t);
        i.writeVarint(e.instructions.length);
        for (const r of e.instructions) if (i.writeVarint(r.op), void 0 === r.arg || null === r.arg) i.writeUint8(t.ConstType.Null); else if ("number" == typeof r.arg) if (void 0 !== r.arg2) {
          const e = r.arg2 << 16 | r.arg;
          i.writeUint8(t.ConstType.Int32), i.writeInt32(e)
        } else Number.isInteger(r.arg) && r.arg >= -128 && r.arg <= 127 ? (i.writeUint8(t.ConstType.Int8), i.writeUint8(255 & r.arg)) : Number.isInteger(r.arg) && r.arg >= -32768 && r.arg <= 32767 ? (i.writeUint8(t.ConstType.Int16), i.writeUint16(65535 & r.arg)) : Number.isInteger(r.arg) ? (i.writeUint8(t.ConstType.Int32), i.writeInt32(r.arg)) : (i.writeUint8(t.ConstType.Float64), i.writeFloat64(r.arg)); else "string" == typeof r.arg && (i.writeUint8(t.ConstType.String), i.writeString(r.arg));
        if (a & t.FlagBits.HasJumps) {
          const t = [];
          e.instructions.forEach((r, o) => {
            if (void 0 !== r.target) {
              const n = void 0 !== e.jumpKey ? r.target ^ e.jumpKey : r.target;
              t.push([o, n])
            }
          }), i.writeVarint(t.length);
          for (const [e, r] of t) i.writeVarint(e), i.writeVarint(r)
        }
        if (a & t.FlagBits.HasExceptions) {
          const t = [], r = (r, o) => {
            var n, i, a;
            if (void 0 !== r.catchIndex || void 0 !== r.finallyIndex || void 0 !== r.endIndex) {
              const s = null !== (n = r.catchIndex) && void 0 !== n ? n : -1,
                c = null !== (i = r.finallyIndex) && void 0 !== i ? i : -1,
                l = null !== (a = r.endIndex) && void 0 !== a ? a : -1, d = e.jumpKey;
              t.push([o, void 0 !== d && s >= 0 ? s ^ d : s, void 0 !== d && c >= 0 ? c ^ d : c, void 0 !== d && l >= 0 ? l ^ d : l])
            }
          };
          e.instructions.forEach(r), i.writeVarint(t.length);
          for (const [e, r, o, n] of t) i.writeVarint(e), i.writeVarint(r + 1), i.writeVarint(o + 1), i.writeVarint(n + 1)
        }
        return i.getBuffer()
      }, t.bufferToBase64 = function (e) {
        if ("undefined" != typeof Buffer) return Buffer.from(e).toString("base64");
        let t = "";
        for (const r of e) t += String.fromCharCode(r);
        return btoa(t)
      }, t.ConstType = {
        Null: 0,
        Undefined: 1,
        BooleanFalse: 2,
        BooleanTrue: 3,
        Int8: 4,
        Int16: 5,
        Int32: 6,
        Float64: 7,
        String: 8,
        BigInt: 9,
        Regex: 10
      }, t.FlagBits = {
        IsArrow: 1,
        IsAsync: 2,
        IsGenerator: 4,
        HasFunctionName: 8,
        HasOpcodeSeed: 16,
        HasOpcodeMap: 32,
        HasJumpKey: 64,
        HasBytecodeKey: 128,
        HasSmSeed: 256,
        HasSmState: 512,
        HasSeKey: 1024,
        HasJumps: 2048,
        HasExceptions: 4096
      };

      class r {
        constructor(e = 1024) {
          this.offset = 0, this.buffer = new Uint8Array(e), this.view = new DataView(this.buffer.buffer)
        }

        writeUint8(e) {
          this.ensureCapacity(1), this.buffer[this.offset++] = 255 & e
        }

        writeUint16(e) {
          this.ensureCapacity(2), this.view.setUint16(this.offset, e, !0), this.offset += 2
        }

        writeUint32(e) {
          this.ensureCapacity(4), this.view.setUint32(this.offset, e, !0), this.offset += 4
        }

        writeInt32(e) {
          this.ensureCapacity(4), this.view.setInt32(this.offset, e, !0), this.offset += 4
        }

        writeFloat64(e) {
          this.ensureCapacity(8), this.view.setFloat64(this.offset, e, !0), this.offset += 8
        }

        writeVarint(e) {
          let t = e >= 0 ? 2 * e : 2 * -e - 1;
          for (; t >= 128;) this.writeUint8(127 & t | 128), t >>>= 7;
          this.writeUint8(t)
        }

        writeString(e) {
          const t = (new TextEncoder).encode(e);
          this.writeVarint(t.length), this.ensureCapacity(t.length), this.buffer.set(t, this.offset), this.offset += t.length
        }

        getBuffer() {
          return this.buffer.slice(0, this.offset)
        }

        getOffset() {
          return this.offset
        }

        ensureCapacity(e) {
          if (this.offset + e <= this.buffer.length) return;
          const t = Math.max(2 * this.buffer.length, this.offset + e), r = new Uint8Array(t);
          r.set(this.buffer), this.buffer = r, this.view = new DataView(this.buffer.buffer)
        }
      }

      function o(e, r) {
        null === r ? e.writeUint8(t.ConstType.Null) : void 0 === r ? e.writeUint8(t.ConstType.Undefined) : !1 === r ? e.writeUint8(t.ConstType.BooleanFalse) : !0 === r ? e.writeUint8(t.ConstType.BooleanTrue) : "number" == typeof r ? Number.isInteger(r) && r >= -128 && r <= 127 ? (e.writeUint8(t.ConstType.Int8), e.writeUint8(255 & r)) : Number.isInteger(r) && r >= -32768 && r <= 32767 ? (e.writeUint8(t.ConstType.Int16), e.writeUint16(65535 & r)) : Number.isInteger(r) && r >= -2147483648 && r <= 2147483647 ? (e.writeUint8(t.ConstType.Int32), e.writeInt32(r)) : (e.writeUint8(t.ConstType.Float64), e.writeFloat64(r)) : "string" == typeof r ? (e.writeUint8(t.ConstType.String), e.writeString(r)) : "bigint" == typeof r ? (e.writeUint8(t.ConstType.BigInt), e.writeString(r.toString())) : r instanceof RegExp && (e.writeUint8(t.ConstType.Regex), e.writeString(r.source), e.writeString(r.flags))
      }

      t.BinaryWriter = r
    }, 74529: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMMacroOpOptimizer = void 0;
      const n = r(45337), i = r(25115);
      let a = class {
        constructor() {
          this.usedMacroOps = new Set, this.patterns = [{
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.PUSH_CONST, i.VMOpCode.ADD, i.VMOpCode.STORE_LOCAL],
            validate: (e, t, r) => {
              const o = e[t], n = e[t + 1], i = e[t + 3];
              return o.arg === i.arg && void 0 !== n.arg && 1 === r[n.arg]
            },
            macroOp: i.VMOpCode.MACRO_INC_LOCAL,
            extractArgs: (e, t) => ({ arg: e[t].arg })
          }, {
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.PUSH_CONST, i.VMOpCode.SUB, i.VMOpCode.STORE_LOCAL],
            validate: (e, t, r) => {
              const o = e[t], n = e[t + 1], i = e[t + 3];
              return o.arg === i.arg && void 0 !== n.arg && 1 === r[n.arg]
            },
            macroOp: i.VMOpCode.MACRO_DEC_LOCAL,
            extractArgs: (e, t) => ({ arg: e[t].arg })
          }, {
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.PUSH_CONST, i.VMOpCode.ADD],
            macroOp: i.VMOpCode.MACRO_ADD_LOCAL_CONST,
            extractArgs: (e, t) => ({ arg: e[t].arg, arg2: e[t + 1].arg })
          }, {
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.PUSH_CONST, i.VMOpCode.SUB],
            macroOp: i.VMOpCode.MACRO_SUB_LOCAL_CONST,
            extractArgs: (e, t) => ({ arg: e[t].arg, arg2: e[t + 1].arg })
          }, {
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.PUSH_CONST, i.VMOpCode.MUL],
            macroOp: i.VMOpCode.MACRO_MUL_LOCAL_CONST,
            extractArgs: (e, t) => ({ arg: e[t].arg, arg2: e[t + 1].arg })
          }, {
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.PUSH_CONST, i.VMOpCode.LT],
            macroOp: i.VMOpCode.MACRO_LT_LOCAL_CONST,
            extractArgs: (e, t) => ({ arg: e[t].arg, arg2: e[t + 1].arg })
          }, {
            opcodes: [i.VMOpCode.LOAD_LOCAL, i.VMOpCode.GET_PROP],
            macroOp: i.VMOpCode.MACRO_LOAD_LOCAL_GET_PROP,
            extractArgs: (e, t) => ({ arg: e[t].arg, arg2: e[t + 1].arg })
          }]
        }

        getUsedMacroOps() {
          return this.usedMacroOps
        }

        resetUsedMacroOps() {
          this.usedMacroOps.clear()
        }

        optimize(e) {
          this.usedMacroOps.clear();
          const t = e.instructions, r = e.constants, o = [], n = new Map;
          let i = 0;
          for (; i < t.length;) {
            n.set(i, o.length);
            const e = this.tryMatchPattern(t, i, r);
            if (e) {
              const t = { op: e.macroOp, ...e.args };
              o.push(t), this.usedMacroOps.add(e.macroOp);
              for (let t = 1; t < e.consumedCount; t++) n.set(i + t, o.length - 1);
              i += e.consumedCount
            } else o.push(t[i]), i++
          }
          return this.fixJumpTargets(o, n, t.length), e.instructions = o, e
        }

        tryMatchPattern(e, t, r) {
          for (const o of this.patterns) if (this.matchesPattern(e, t, o, r)) return {
            macroOp: o.macroOp,
            args: o.extractArgs(e, t),
            consumedCount: o.opcodes.length
          };
          return null
        }

        matchesPattern(e, t, r, o) {
          if (t + r.opcodes.length > e.length) return !1;
          for (let o = 0; o < r.opcodes.length; o++) if (e[t + o].op !== r.opcodes[o]) return !1;
          for (let o = 1; o < r.opcodes.length; o++) if (this.isJumpTarget(e, t + o)) return !1;
          return !(r.validate && !r.validate(e, t, o))
        }

        isJumpTarget(e, t) {
          for (const r of e) if (this.isInstructionJumpingTo(r, t)) return !0;
          return !1
        }

        isInstructionJumpingTo(e, t) {
          if ("target" in e && e.target === t) return !0;
          if (e.op === i.VMOpCode.TRY_START) {
            const r = e;
            if (r.catchIndex === t || r.finallyIndex === t || r.endIndex === t) return !0
          }
          return !1
        }

        fixJumpTargets(e, t, r) {
          t.set(r, e.length);
          for (const r of e) this.fixInstructionJumpTarget(r, t), this.fixTryStartIndices(r, t)
        }

        fixInstructionJumpTarget(e, t) {
          if ("target" in e) {
            const r = t.get(e.target);
            void 0 !== r && (e.target = r)
          }
        }

        fixTryStartIndices(e, t) {
          if (e.op !== i.VMOpCode.TRY_START) return;
          const r = e;
          if (void 0 !== r.catchIndex) {
            const e = t.get(r.catchIndex);
            void 0 !== e && (r.catchIndex = e)
          }
          if (void 0 !== r.finallyIndex) {
            const e = t.get(r.finallyIndex);
            void 0 !== e && (r.finallyIndex = e)
          }
          if (void 0 !== r.endIndex) {
            const e = t.get(r.endIndex);
            void 0 !== e && (r.endIndex = e)
          }
        }
      };
      t.VMMacroOpOptimizer = a, t.VMMacroOpOptimizer = a = o([(0, n.injectable)()], a)
    }, 74572: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.InversifyContainerFacade = void 0;
      const o = r(45337), n = r(31391), i = r(72849), a = r(60584), s = r(88711), c = r(93313), l = r(95309),
        d = r(57524), p = r(18998), u = r(6057), f = r(40275), m = r(85869), g = r(30215), h = r(77144), y = r(95129),
        S = r(28558), N = r(28124), b = r(12839), _ = r(26323), v = r(16077), I = r(89467), O = r(50704), C = r(81077),
        E = r(2396), T = r(82247), R = r(55253), M = r(59628), A = r(12928), F = r(43296);
      t.InversifyContainerFacade = class {
        constructor() {
          this.container = new o.Container
        }

        static getFactory(e) {
          return t => r => t.container.getNamed(e, r)
        }

        static getCacheFactory(e) {
          return t => {
            const r = new Map;
            return o => {
              if (r.has(o)) return r.get(o);
              const n = t.container.getNamed(e, o);
              return r.set(o, n), n
            }
          }
        }

        static getConstructorFactory(e, ...t) {
          return r => {
            const o = new Map, n = [];
            return i => {
              if (t.forEach((e, t) => {
                n[t] || (n[t] = r.container.get(e))
              }), o.has(i)) return new (o.get(i))(...n);
              const a = r.container.getNamed(e, i);
              return o.set(i, a), new a(...n)
            }
          }
        }

        get(e) {
          return this.container.get(e)
        }

        getNamed(e, t) {
          return this.container.getNamed(e, t)
        }

        load(e, t, r) {
          this.container.bind(n.ServiceIdentifiers.ISourceCode).toDynamicValue(() => new F.SourceCode(e, t)).inSingletonScope(), this.container.bind(n.ServiceIdentifiers.TInputOptions).toDynamicValue(() => r).inSingletonScope(), this.container.bind(n.ServiceIdentifiers.ILogger).to(R.Logger).inSingletonScope(), this.container.bind(n.ServiceIdentifiers.IJavaScriptObfuscator).to(T.JavaScriptObfuscator).inSingletonScope(), this.container.bind(n.ServiceIdentifiers.ICodeTransformersRunner).to(E.CodeTransformersRunner).inSingletonScope(), this.container.bind(n.ServiceIdentifiers.INodeTransformersRunner).to(M.NodeTransformersRunner).inSingletonScope(), this.container.bind(n.ServiceIdentifiers.IObfuscationResult).to(A.ObfuscationResult), this.container.bind(n.ServiceIdentifiers.Factory__IObfuscationResult).toFactory(e => (t, r) => {
            const o = e.container.get(n.ServiceIdentifiers.IObfuscationResult);
            return o.initialize(t, r), o
          }), this.container.load(i.analyzersModule), this.container.load(a.codeTransformersModule), this.container.load(s.controlFlowTransformersModule), this.container.load(c.convertingTransformersModule), this.container.load(l.customCodeHelpersModule), this.container.load(d.customNodesModule), this.container.load(p.deadCodeInjectionTransformersModule), this.container.load(u.finalizingTransformersModule), this.container.load(f.generatorsModule), this.container.load(m.initializingTransformersModule), this.container.load(g.nodeModule), this.container.load(h.nodeTransformersModule), this.container.load(y.optionsModule), this.container.load(S.preparingTransformersModule), this.container.load(N.renameIdentifiersTransformersModule), this.container.load(b.renamePropertiesTransformersModule), this.container.load(_.simplifyingTransformersModule), this.container.load(I.storagesModule), this.container.load(O.stringArrayTransformersModule), this.container.load(v.vmTransformersModule), this.container.load(C.utilsModule)
        }

        unload() {
          this.container.unbindAll()
        }
      }
    }, 74593: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 74937: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getSpecialOpcodeTemplates = function () {
        return "\n                        // Special Operations\n                        case opMap[160]: { // THIS\n                            stack.push(_this);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[161]: { // ARGUMENTS\n                            // Create arguments-like array with callee property\n                            let argsArr = Array.prototype.slice.call(args || []);\n                            argsArr.callee = currentFunc;\n                            stack.push(argsArr);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[164]: { // NEW_TARGET\n                            // Push new.target value (will be undefined if not called with 'new')\n                            stack.push(newTarget);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[162]: { // NEW_REGEX\n                            let regexData = constants[arg];\n                            let parts = regexData.split('|||');\n                            let pattern = parts[0];\n                            let flags = parts[1];\n                            stack.push(new RegExp(pattern, flags));\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[163]: { // VOID\n                            stack.pop();\n                            stack.push(undefined);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[167]: { // SYMBOL\n                            // Create unique symbol: Symbol(description)\n                            // arg is -1 for no description, otherwise index in constants\n                            if (arg === -1) {\n                                stack.push(Symbol());\n                            } else {\n                                let desc = stack.pop();\n                                stack.push(Symbol(desc));\n                            }\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[168]: { // SYMBOL_FOR\n                            // Get/create global symbol: Symbol.for(key)\n                            // arg is index of key in constants\n                            let symbolKey = constants[arg];\n                            stack.push(Symbol.for(symbolKey));\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[169]: { // SYMBOL_KEY_FOR\n                            // Get key for global symbol: Symbol.keyFor(symbol)\n                            // Stack: [symbol] -> [key or undefined]\n                            let sym = stack.pop();\n                            stack.push(Symbol.keyFor(sym));\n                            pc++;\n                            break;\n                        }\n\n                        // Assignment Operators\n                        case opMap[170]: { // ASSIGN\n                            // Value is already on stack from assignment expression\n                            pc++;\n                            break;\n                        }\n\n                        // Debug/Utility\n                        case opMap[200]: { // DEBUGGER\n                            debugger;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[201]: { // NOP\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[202]: { // END\n                            return stack.length > 0 ? stack.pop() : undefined;\n                        }\n    "
      }
    }, 75096: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeLexicalScopeUtils = void 0;
      const o = r(27391);

      class n {
        static getLexicalScope(e) {
          return n.getLexicalScopesRecursive(e, 1)[0]
        }

        static getLexicalScopes(e) {
          return n.getLexicalScopesRecursive(e)
        }

        static getLexicalScopesRecursive(e, t = 1 / 0, r = [], i = 0) {
          if (r.length >= t) return r;
          const a = e.parentNode;
          if (!a) throw new ReferenceError("`parentNode` property of given node is `undefined`");
          return o.NodeGuards.isNodeWithLexicalScope(e) && r.push(e), e !== a ? n.getLexicalScopesRecursive(a, t, r, ++i) : r
        }
      }

      t.NodeLexicalScopeUtils = n
    }, 75276: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionFunctionCallTemplate = function () {
        return "\n        (function () {\n            {callControllerFunctionName}(\n                this,\n                function () {\n                    const regExp1 = new RegExp('function *\\\\( *\\\\)');\n                    const regExp2 = new RegExp('\\\\+\\\\+ *\\(?:[a-zA-Z_$][0-9a-zA-Z_$]*\\)', 'i');\n           \n                    const result = {debugProtectionFunctionName}('init');\n                    \n                    if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                        result('0');\n                    } else {\n                        {debugProtectionFunctionName}();\n                    }\n                }\n            )();\n        })();\n    "
      }
    }, 75476: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractCalleeDataExtractor = void 0;
      const n = r(45337);
      let i = class {
      };
      t.AbstractCalleeDataExtractor = i, t.AbstractCalleeDataExtractor = i = o([(0, n.injectable)()], i)
    }, 75500: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 75532: function (e, t, r) {
      var o = this && this.__importDefault || function (e) {
        return e && e.__esModule ? e : { default: e }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IsIdentifierNamesCache = function (e) {
        return (t, r) => {
          (0, i.registerDecorator)({
            propertyName: r,
            constraints: [],
            name: "IsIdentifierNamesCache",
            options: e,
            target: t.constructor,
            validator: {
              validate(e, t) {
                const o = a.DEFAULT_PRESET[r];
                return !(!(0, n.default)(e, o) && null != e) || "object" == typeof e && !!s(null == e ? void 0 : e.globalIdentifiers) && s(null == e ? void 0 : e.propertyIdentifiers)
              }, defaultMessage: () => "Passed value must be an identifier names cache object or `null/undefined` value"
            }
          })
        }
      };
      const n = o(r(77078)), i = r(97403), a = r(45887), s = e => {
        if (void 0 === e) return !0;
        if ("object" != typeof e || null === e) return !1;
        const t = Object.values(e);
        if (!t.length) return !0;
        for (const e of t) if ("string" != typeof e) return !1;
        return !0
      }
    }, 75716: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeTransformationStage = void 0, function (e) {
        e.ControlFlowFlattening = "ControlFlowFlattening", e.Converting = "Converting", e.DeadCodeInjection = "DeadCodeInjection", e.Finalizing = "Finalizing", e.Initializing = "Initializing", e.Preparing = "Preparing", e.RenameIdentifiers = "RenameIdentifiers", e.RenameProperties = "RenameProperties", e.Simplifying = "Simplifying", e.StringArray = "StringArray", e.VMObfuscation = "VMObfuscation"
      }(r || (t.NodeTransformationStage = r = {}))
    }, 75851: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMBytecodeStorage = void 0;
      const n = r(45337), i = r(62957);
      let a = class extends i.ArrayStorage {
        store(e) {
          const t = this.getLength();
          return this.set(t, e), t
        }

        getById(e) {
          return this.get(e)
        }

        getAllBytecode() {
          return this.getStorage()
        }

        clear() {
          this.storage = []
        }
      };
      t.VMBytecodeStorage = a, t.VMBytecodeStorage = a = o([(0, n.injectable)()], a)
    }, 76034: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 76393: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 76436: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IdentifierNamesGenerator = void 0;
      const o = r(39079);
      t.IdentifierNamesGenerator = o.Utils.makeEnum({
        DictionaryIdentifierNamesGenerator: "dictionary",
        HexadecimalIdentifierNamesGenerator: "hexadecimal",
        MangledIdentifierNamesGenerator: "mangled",
        MangledShuffledIdentifierNamesGenerator: "mangled-shuffled"
      })
    }, 77078: e => {
      e.exports = require("fast-deep-equal")
    }, 77144: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.nodeTransformersModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(53684);
      t.nodeTransformersModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.Factory__INodeTransformer).toFactory(o.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.INodeTransformer)), e(i.ServiceIdentifiers.INodeTransformerNamesGroupsBuilder).to(a.NodeTransformerNamesGroupsBuilder).inSingletonScope()
      })
    }, 77898: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 78005: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.SelfDefendingCodeHelper = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(39032), g = r(25714), h = r(76393), y = r(31142),
        S = r(50164), N = r(55866), b = r(48222), _ = r(33056);
      let v = class extends b.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t) {
          this.callsControllerFunctionName = e, this.selfDefendingFunctionName = t
        }

        getNodeStructure(e) {
          return _.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          return this.customCodeHelperFormatter.formatTemplate((0, N.SelfDefendingTemplate)(), {
            callControllerFunctionName: this.callsControllerFunctionName,
            selfDefendingFunctionName: this.selfDefendingFunctionName
          })
        }
      };
      t.SelfDefendingCodeHelper = v, c([(0, S.initializable)(), l("design:type", String)], v.prototype, "callsControllerFunctionName", void 0), c([(0, S.initializable)(), l("design:type", String)], v.prototype, "selfDefendingFunctionName", void 0), t.SelfDefendingCodeHelper = v = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperObfuscator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== h.IOptions && h.IOptions) ? s : Object])], v)
    }, 78102: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMStatementBytecodeCompiler = void 0;
      const f = r(45337), m = r(20924), g = r(94487), h = r(72282), y = r(73566), S = r(37526), N = r(53758),
        b = r(91015), _ = r(31391), v = r(27391), I = r(59805);
      let O = class {
        constructor(e, t, r, o, n, i, a) {
          this.vmCompilerUtils = e, this.loopCompiler = t, this.conditionalCompiler = r, this.exceptionCompiler = o, this.declarationCompiler = n, this.classCompiler = i, this.scopeManager = a
        }

        compileBlockStatement(e, t) {
          var r, o;
          const n = [];
          let i = !1, a = null;
          const s = t.isFunctionBody;
          if (s && (t.isFunctionBody = !1), !s && this.vmCompilerUtils.containsFunction(e)) for (const t of e.body) if (v.NodeGuards.isVariableDeclarationNode(t) && ("let" === t.kind || "const" === t.kind)) for (const e of t.declarations) if (v.NodeGuards.isIdentifierNode(e.id)) {
            const t = e.id.name;
            i = !0, n.push(t)
          } else if (v.NodeGuards.isArrayPatternNode(e.id) || v.NodeGuards.isObjectPatternNode(e.id)) {
            const t = this.vmCompilerUtils.extractIdentifiersFromPattern(e.id);
            for (const e of t) i = !0, n.push(e)
          }
          if (i) {
            const e = this.vmCompilerUtils.createInstructionBuilder(t);
            for (const r of n) for (let o = t.blockScopeDepth; o >= 0; o--) {
              const n = (0, I.getScopedVariableName)(r, o);
              if (t.localVariables.has(n)) {
                if (t.envVars.has(r)) e.loadFromEnvByName(r), e.storeToCurrentEnvByName(r); else {
                  const o = t.localVariables.get(n);
                  void 0 !== o && (e.loadLocal(o), e.storeToEnvByName(r), t.envVars.add(r))
                }
                break
              }
            }
            a = this.scopeManager.enterEnv(t, e);
            for (const e of n) t.envVars.add(e)
          }
          const c = this.scopeManager.enterBlock(t), l = [];
          if (!s) {
            for (const t of e.body) if (v.NodeGuards.isVariableDeclarationNode(t) && ("let" === t.kind || "const" === t.kind)) for (const e of t.declarations) if (v.NodeGuards.isIdentifierNode(e.id)) {
              const t = e.id.name;
              l.push(t)
            } else if (v.NodeGuards.isArrayPatternNode(e.id) || v.NodeGuards.isObjectPatternNode(e.id)) {
              const t = this.vmCompilerUtils.extractIdentifiersFromPattern(e.id);
              for (const e of t) l.push(e)
            }
            if (l.length > 0 && this.scopeManager.enterLocalsTDZ(t, l), l.length > 0 && i) {
              const e = this.vmCompilerUtils.createInstructionBuilder(t);
              for (const t of l) n.includes(t) && e.declareTDZ(t)
            }
          }
          const d = new Set;
          for (const t of e.body) if (v.NodeGuards.isVariableDeclarationNode(t)) for (const e of t.declarations) {
            const t = this.vmCompilerUtils.extractIdentifiersFromPattern(e.id);
            for (const e of t) d.add(e)
          } else (v.NodeGuards.isFunctionDeclarationNode(t) && t.id || v.NodeGuards.isClassDeclarationNode(t) && t.id) && d.add(t.id.name);
          const p = new Set;
          if (!s) for (const o of e.body) if (v.NodeGuards.isFunctionDeclarationNode(o) && o.id) {
            const e = o.id.name;
            let n = !1;
            for (let r = t.blockScopeDepth - 1; r >= 0; r--) {
              const o = (0, I.getScopedVariableName)(e, r);
              if (t.localVariables.has(o)) {
                n = !0;
                break
              }
            }
            if (!n && t.localVariables.has(e) && (n = !0), !n && t.parameters.has(e) && (n = !0), !n && t.envVars.has(e) && (n = !0), n) continue;
            const i = this.vmCompilerUtils.collectReferencedIdentifiers(o), a = new Set;
            for (const e of o.params) v.NodeGuards.isIdentifierNode(e) && a.add(e.name);
            const s = this.vmCompilerUtils.containsFunction(o.body);
            let c = !1;
            if (!s) for (const t of i) if (!a.has(t) && t !== e && d.has(t)) {
              c = !0;
              break
            }
            s || c || (null === (r = t.dispatch) || void 0 === r || r.statement(o), p.add(o))
          }
          for (const r of e.body) p.has(r) || null === (o = t.dispatch) || void 0 === o || o.statement(r);
          for (const e of l) this.scopeManager.exitLocalTDZ(t, e);
          if (this.scopeManager.exitBlockWithHandle(t, c), a) {
            const e = this.vmCompilerUtils.createInstructionBuilder(t);
            this.scopeManager.exitEnv(t, e, a)
          }
        }

        compileReturnStatement(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          e.argument ? null === (r = t.dispatch) || void 0 === r || r.expression(e.argument) : o.pushUndefined(), o.return()
        }

        compileIfStatement(e, t) {
          this.conditionalCompiler.compileIfStatement(e, t)
        }

        compileWhileStatement(e, t) {
          this.loopCompiler.compileWhileStatement(e, t)
        }

        compileDoWhileStatement(e, t) {
          this.loopCompiler.compileDoWhileStatement(e, t)
        }

        compileForStatement(e, t) {
          this.loopCompiler.compileForStatement(e, t)
        }

        compileForOfStatement(e, t) {
          this.loopCompiler.compileForOfStatement(e, t)
        }

        compileForInStatement(e, t) {
          this.loopCompiler.compileForInStatement(e, t)
        }

        compileBreakStatement(e, t) {
          if (e.label) {
            const r = e.label.name, o = t.labelTargets.get(r);
            void 0 !== o && this.emitJumpWithEnvRestore(0, o, !0, t)
          } else if (t.breakTargets.length > 0) {
            const e = t.breakEnvDepths[t.breakEnvDepths.length - 1], r = t.breakTargets[t.breakTargets.length - 1];
            this.emitJumpWithEnvRestore(e, r, !0, t)
          }
        }

        compileContinueStatement(e, t) {
          if (e.label) {
            const r = e.label.name, o = t.labelContinueTargets.get(r);
            void 0 !== o && this.emitJumpWithEnvRestore(0, o, !1, t)
          } else if (t.continueTargets.length > 0) {
            const e = t.continueEnvDepths[t.continueEnvDepths.length - 1],
              r = t.continueTargets[t.continueTargets.length - 1];
            this.emitJumpWithEnvRestore(e, r, !1, t)
          }
        }

        compileThrowStatement(e, t) {
          this.exceptionCompiler.compileThrowStatement(e, t)
        }

        compileTryStatement(e, t) {
          this.exceptionCompiler.compileTryStatement(e, t)
        }

        compileSwitchStatement(e, t) {
          this.conditionalCompiler.compileSwitchStatement(e, t)
        }

        compileVariableDeclaration(e, t) {
          this.declarationCompiler.compileVariableDeclaration(e, t)
        }

        compileFunctionDeclaration(e, t) {
          this.declarationCompiler.compileFunctionDeclaration(e, t)
        }

        compileClassDeclaration(e, t) {
          this.classCompiler.compileClassDeclaration(e, t)
        }

        compileLabeledStatement(e, t) {
          var r;
          const o = e.label.name, n = t.instructions.length;
          t.labelTargets.set(o, n), t.breakTargets.push(n), t.breakEnvDepths.push(t.envDepth);
          const i = t.currentLabel;
          t.currentLabel = o, null === (r = t.dispatch) || void 0 === r || r.statement(e.body), t.currentLabel = i;
          const a = t.instructions.length;
          this.vmCompilerUtils.patchLabeledBreakStatements(n, a, t), t.labelTargets.delete(o), t.labelContinueTargets.delete(o), t.breakTargets.pop(), t.breakEnvDepths.pop()
        }

        emitJumpWithEnvRestore(e, t, r, o) {
          const n = this.vmCompilerUtils.createInstructionBuilder(o);
          for (let t = o.envDepth; t > e; t--) n.restoreParentEnv();
          r ? n.break().patchTo(t) : n.continue().patchTo(t)
        }
      };
      t.VMStatementBytecodeCompiler = O, t.VMStatementBytecodeCompiler = O = d([(0, f.injectable)(), u(0, (0, f.inject)(_.ServiceIdentifiers.IVMCompilerUtils)), u(1, (0, f.inject)(_.ServiceIdentifiers.IVMLoopCompiler)), u(2, (0, f.inject)(_.ServiceIdentifiers.IVMConditionalCompiler)), u(3, (0, f.inject)(_.ServiceIdentifiers.IVMExceptionCompiler)), u(4, (0, f.inject)(_.ServiceIdentifiers.IVMDeclarationCompiler)), u(5, (0, f.inject)(_.ServiceIdentifiers.IVMClassBytecodeCompiler)), u(6, (0, f.inject)(_.ServiceIdentifiers.IVMScopeManager)), p("design:paramtypes", ["function" == typeof (o = void 0 !== m.IVMCompilerUtils && m.IVMCompilerUtils) ? o : Object, "function" == typeof (n = void 0 !== h.IVMLoopCompiler && h.IVMLoopCompiler) ? n : Object, "function" == typeof (i = void 0 !== y.IVMConditionalCompiler && y.IVMConditionalCompiler) ? i : Object, "function" == typeof (a = void 0 !== S.IVMExceptionCompiler && S.IVMExceptionCompiler) ? a : Object, "function" == typeof (s = void 0 !== N.IVMDeclarationCompiler && N.IVMDeclarationCompiler) ? s : Object, "function" == typeof (c = void 0 !== b.IVMClassBytecodeCompiler && b.IVMClassBytecodeCompiler) ? c : Object, "function" == typeof (l = void 0 !== g.IVMScopeManager && g.IVMScopeManager) ? l : Object])], O)
    }, 78550: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeTransformer = void 0, function (e) {
        e.HashbangOperatorTransformer = "HashbangOperatorTransformer"
      }(r || (t.CodeTransformer = r = {}))
    }, 79148: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMDestructuringBytecodeCompiler = void 0;
      const c = r(45337), l = r(20924), d = r(94487), p = r(31391), u = r(27391), f = r(59805);
      let m = class {
        constructor(e, t) {
          this.vmCompilerUtils = e, this.scopeManager = t
        }

        compileDestructuringPattern(e, t, r = !1, o = !1) {
          const n = t._destructuringMode;
          t._destructuringMode = o ? "assignment" : "declaration", u.NodeGuards.isArrayPatternNode(e) ? this.compileArrayPatternDestructuring(e, t) : u.NodeGuards.isObjectPatternNode(e) && this.compileObjectPatternDestructuring(e, t), t._destructuringMode = n, r && this.vmCompilerUtils.createInstructionBuilder(t).pop()
        }

        compileArrayPatternDestructuring(e, t) {
          const r = this.vmCompilerUtils.createInstructionBuilder(t);
          let o = !1;
          for (let n = 0; n < e.elements.length; n++) {
            const i = e.elements[n];
            null !== i && (u.NodeGuards.isRestElementNode(i) ? (o = !0, this.compileRestElementDestructuring(i, n, t)) : (r.dup(), r.loadConst(n), r.getComputed(), this.compileDestructuringElement(i, t)))
          }
          o || r.pop()
        }

        compileObjectPatternDestructuring(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t), n = [];
          for (const i of e.properties) if (u.NodeGuards.isRestElementNode(i)) this.compileObjectRestElement(i, n, t); else if (u.NodeGuards.isPropertyNode(i)) {
            const e = i.key, a = i.value;
            if (u.NodeGuards.isIdentifierNode(e) && !i.computed && n.push(e.name), o.dup(), u.NodeGuards.isIdentifierNode(e) && !i.computed) {
              const r = t.constantPool.add(e.name);
              o.getPropertyByName(r)
            } else null === (r = t.dispatch) || void 0 === r || r.expression(e), o.getComputed();
            this.compileDestructuringElement(a, t)
          }
          o.pop()
        }

        compileDestructuringElement(e, t) {
          var r, o, n, i;
          const a = this.vmCompilerUtils.createInstructionBuilder(t);
          if (u.NodeGuards.isIdentifierNode(e)) {
            const o = e.name;
            if ("assignment" === t._destructuringMode) this.vmCompilerUtils.emitStoreVariable(o, t); else {
              const e = t._declarationKind || "var", n = "let" === e || "const" === e, i = "const" === e,
                s = !0 === t._compilingFunctionParameters;
              if (t.envVars.has(o)) {
                const e = t.constantPool.add(o);
                t.localVariables.has(o) || t.localVariables.set(o, t.localVariables.size), n ? i ? a.storeToCurrentEnvConst(e) : a.storeToCurrentEnv(e) : a.storeToEnv(e)
              } else {
                let e, i;
                n ? (i = (0, f.getScopedVariableName)(o, t.blockScopeDepth), e = this.vmCompilerUtils.getNextLocalIndex(t), t.variableScopes.set(i, {
                  depth: t.blockScopeDepth,
                  index: e
                }), t.localVariables.set(i, e), null === (r = t.activeBlockScopes) || void 0 === r || r.add(i)) : (i = o, t.localVariables.has(i) ? e = t.localVariables.get(i) : (e = t.localVariables.size, t.localVariables.set(i, e))), s && (t.destructuredParameterNames || (t.destructuredParameterNames = new Set), t.destructuredParameterNames.add(i));
                const c = this.vmCompilerUtils.getActualLocalIndex(e, t);
                a.storeLocal(c)
              }
              this.scopeManager.exitLocalTDZ(t, o)
            }
          } else if (u.NodeGuards.isMemberExpressionNode(e)) {
            const r = e;
            if (null === (o = t.dispatch) || void 0 === o || o.expression(r.object), a.swap(), r.computed) null === (n = t.dispatch) || void 0 === n || n.expression(r.property), a.swap(), a.setComputed(), a.pop(); else {
              const e = r.property.name, o = t.constantPool.add(e);
              a.setProperty(o), a.pop()
            }
          } else if (u.NodeGuards.isArrayPatternNode(e) || u.NodeGuards.isObjectPatternNode(e)) this.compileDestructuringPattern(e, t, !1); else if (u.NodeGuards.isAssignmentPatternNode(e)) {
            const r = e.left, o = e.right;
            a.dup(), a.pushUndefined(), a.strictEqual();
            const n = a.jumpIfFalse();
            a.pop(), null === (i = t.dispatch) || void 0 === i || i.expression(o);
            const s = a.jump();
            n.patchToHere(), s.patchToHere(), this.compileDestructuringElement(r, t)
          }
        }

        compileRestElementDestructuring(e, t, r) {
          const o = this.vmCompilerUtils.createInstructionBuilder(r), n = e.argument, i = r.localVariables.size;
          r.localVariables.set(`__array_temp_${t}__`, i);
          const a = this.vmCompilerUtils.getActualLocalIndex(i, r);
          o.storeLocal(a), o.loadConst(t), o.loadLocal(a), o.dup(), o.getProp("slice"), o.loadConst(1), o.callMethod(1), this.compileDestructuringElement(n, r)
        }

        compileObjectRestElement(e, t, r) {
          const o = this.vmCompilerUtils.createInstructionBuilder(r), n = e.argument, i = r.localVariables.size;
          r.localVariables.set("__obj_rest_source__", i);
          const a = this.vmCompilerUtils.getActualLocalIndex(i, r);
          o.storeLocal(a), o.newObject(), o.loadLocal(a), o.emitStaticMethodCall("Object", "assign", 2);
          const s = r.localVariables.size;
          r.localVariables.set("__obj_rest_copy__", s);
          const c = this.vmCompilerUtils.getActualLocalIndex(s, r);
          o.storeLocal(c);
          for (const e of t) o.loadLocal(c), o.loadConst(e), o.deleteProperty(), o.pop();
          o.loadLocal(c), this.compileDestructuringElement(n, r)
        }
      };
      t.VMDestructuringBytecodeCompiler = m, t.VMDestructuringBytecodeCompiler = m = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IVMCompilerUtils)), s(1, (0, c.inject)(p.ServiceIdentifiers.IVMScopeManager)), a("design:paramtypes", ["function" == typeof (o = void 0 !== l.IVMCompilerUtils && l.IVMCompilerUtils) ? o : Object, "function" == typeof (n = void 0 !== d.IVMScopeManager && d.IVMScopeManager) ? n : Object])], m)
    }, 79240: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VM_OPCODE_MASK = t.VM_OPCODE_COUNT = void 0, t.VM_OPCODE_COUNT = 512, t.VM_OPCODE_MASK = 511
    }, 79286: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), l = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && c(t, e, r[n]);
        return l(t, e), t
      }), u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMCompilerUtils = void 0;
      const m = r(45337), g = p(r(31659)), h = r(31391), y = r(25560), S = r(25115), N = r(10192), b = r(43636),
        _ = r(27391), v = r(3977), I = r(57809), O = r(93571);
      let C = class {
        constructor(e, t) {
          this.variableResolver = e, this.scopeIdentifiersTraverser = t
        }

        isEnvVariable(e, t) {
          let r = t;
          for (; r;) {
            if (r.envVars.has(e)) return !0;
            r = r.parentContext
          }
          return !1
        }

        isDeclaredInParentScope(e, t) {
          let r = t;
          for (; r;) {
            if (r.envVars.has(e)) return !0;
            if (r.localVariables.has(e)) return !0;
            const t = `${e}$$`;
            for (const e of r.localVariables.keys()) if (e.startsWith(t)) return !0;
            if (r.parameters.has(e) && !r.parametersInTDZ.has(e)) return !0;
            for (const e of r.parameters.keys()) if (e.startsWith(t) && !r.parametersInTDZ.has(e)) return !0;
            r = r.parentContext
          }
          return !1
        }

        getActualLocalIndex(e, t) {
          return t.parameters.size + e
        }

        getNextLocalIndex(e) {
          let t = -1;
          return e.localVariables.forEach(e => {
            e > t && (t = e)
          }), t + 1
        }

        emitArgumentsSlice(e, t) {
          const r = this.createInstructionBuilder(t);
          r.loadConst(e), r.arguments(), r.dup(), r.getProp("slice"), r.loadConst(1), r.callMethod(1)
        }

        emitRestParameterHandling(e, t, r, o) {
          var n;
          const i = this.createInstructionBuilder(o);
          if (this.emitArgumentsSlice(r, o), null !== t) null === (n = o.dispatch) || void 0 === n || n.destructuring(t, !1); else if (o.envVars.has(e)) i.storeToEnvByName(e); else {
            const t = o.localVariables.get(e), r = this.getActualLocalIndex(t, o);
            i.storeLocal(r)
          }
        }

        createInstructionBuilder(e) {
          return e.builder || (e.builder = new v.VMInstructionBuilder(e)), e.builder
        }

        patchJumpTargets(e, t, r, o, n) {
          for (let i = e; i < t; i++) {
            const e = n.instructions[i];
            e.op !== S.VMOpCode.JUMP && e.op !== S.VMOpCode.BREAK && e.op !== S.VMOpCode.CONTINUE || e.target !== r || (e.target = o)
          }
        }

        patchLoopBreakStatements(e, t, r) {
          for (let o = e; o < t - 1; o++) {
            const n = r.instructions[o];
            (n.op === S.VMOpCode.JUMP || n.op === S.VMOpCode.BREAK || n.op === S.VMOpCode.CONTINUE) && n.target === e && (n.target = t)
          }
        }

        patchLabeledBreakStatements(e, t, r) {
          for (let o = e; o < t; o++) {
            const n = r.instructions[o];
            (n.op === S.VMOpCode.JUMP || n.op === S.VMOpCode.BREAK) && n.target === e && (n.target = t)
          }
        }

        createTempLocal(e, t) {
          const r = t.localVariables.size;
          return t.localVariables.set(e, r), { localIndex: r, actualIndex: this.getActualLocalIndex(r, t) }
        }

        emitLoadVariable(e, t) {
          const r = this.createInstructionBuilder(t), o = this.variableResolver.resolve(e, t);
          switch (o.location) {
            case y.VariableLocation.Environment:
              r.loadFromEnv(o.index);
              break;
            case y.VariableLocation.Parameter:
              r.loadArg(o.index);
              break;
            case y.VariableLocation.Local: {
              const e = this.getActualLocalIndex(o.index, t);
              r.loadLocal(e);
              break
            }
            case y.VariableLocation.Global:
              r.loadGlobal(o.index)
          }
        }

        emitStoreVariable(e, t) {
          const r = this.createInstructionBuilder(t), o = this.variableResolver.resolve(e, t, !0);
          switch (o.location) {
            case y.VariableLocation.Environment:
              r.storeToEnv(o.index);
              break;
            case y.VariableLocation.Parameter:
              r.storeArg(o.index);
              break;
            case y.VariableLocation.Local: {
              const e = this.getActualLocalIndex(o.index, t);
              if (t.constLocalVariables.has(e)) return r.pop(), void r.throwError("TypeError", "Assignment to constant variable.");
              r.storeLocal(e);
              break
            }
            case y.VariableLocation.Global:
              r.storeGlobal(o.index), r.pop()
          }
        }

        createContext(e, t = !1, r) {
          const o = {
            constantPool: new N.VMConstantPool,
            instructions: [],
            localVariables: new Map,
            parameters: new Map,
            parametersInTDZ: new Set,
            localVariablesInTDZ: new Set,
            constLocalVariables: new Set,
            breakTargets: [],
            breakEnvDepths: [],
            continueTargets: [],
            continueEnvDepths: [],
            labelTargets: new Map,
            labelContinueTargets: new Map,
            currentLabel: null,
            activeFinallyBlocks: [],
            nextBytecodeId: 0,
            parentContext: e,
            capturedVars: new Set,
            envVars: new Set,
            nestedFunctions: new Map,
            functionRefIndices: new Set,
            isArrowFunction: t,
            capturedThis: !1,
            capturedArguments: !1,
            blockScopeDepth: 0,
            variableScopes: new Map,
            activeBlockScopes: new Set,
            envDepth: 0,
            isFunctionBody: !1,
            hoistedFunctionDeclarations: new Set,
            maxLocals: 0,
            dispatchFactory: null == e ? void 0 : e.dispatchFactory,
            topLevelVariables: r,
            perIterationLoopVars: null == e ? void 0 : e.perIterationLoopVars,
            declaredVariables: new Set,
            classExpressionNameAliases: null == e ? void 0 : e.classExpressionNameAliases
          };
          return o.dispatchFactory && (o.dispatch = o.dispatchFactory(o)), o
        }

        traverseStatements(e, t) {
          for (const r of e) g.traverse(r, {
            enter: e => {
              if (_.NodeGuards.isStatementOrDeclarationNode(e) && t(e), _.NodeGuards.isFunctionNode(e)) return g.VisitorOption.Skip
            }
          })
        }

        emitConditionalJump(e, t) {
          const r = this.createInstructionBuilder(t), o = r.currentInstructionIndex();
          return r.emitRaw({ op: e, target: 0 }), o
        }

        patchJump(e, t, r) {
          const o = null != r ? r : t.instructions.length;
          t.instructions[e].target = o
        }

        adjustJumpTargetsAfterInsertion(e, t, r) {
          for (const o of r.instructions) {
            if ("target" in o && void 0 !== o.target) {
              const r = o;
              r.target >= e && (r.target += t)
            }
            if (o.op === S.VMOpCode.TRY_START) {
              const r = o;
              void 0 !== r.catchIndex && r.catchIndex >= e && (r.catchIndex += t), void 0 !== r.finallyIndex && r.finallyIndex >= e && (r.finallyIndex += t), void 0 !== r.endIndex && r.endIndex >= e && (r.endIndex += t)
            }
          }
        }

        extractIdentifiersFromPattern(e) {
          const t = [],
            r = O.NodeFactory.programNode([O.NodeFactory.variableDeclarationNode([O.NodeFactory.variableDeclaratorNode(e, null)])]);
          return this.scopeIdentifiersTraverser.traverseScopeIdentifiers(r, r, e => {
            t.push(e.variable.name)
          }), t
        }

        traverseBlocksSkipScopes(e, t) {
          if (!_.NodeGuards.isFunctionOrClassNode(e)) if (t(e), _.NodeGuards.isBlockStatementNode(e)) for (const r of e.body) this.traverseBlocksSkipScopes(r, t); else if (_.NodeGuards.isIfStatementNode(e)) this.traverseBlocksSkipScopes(e.consequent, t), e.alternate && this.traverseBlocksSkipScopes(e.alternate, t); else if (_.NodeGuards.isWhileStatementNode(e) || _.NodeGuards.isDoWhileStatementNode(e)) this.traverseBlocksSkipScopes(e.body, t); else if (_.NodeGuards.isForStatementNode(e)) e.init && this.traverseBlocksSkipScopes(e.init, t), this.traverseBlocksSkipScopes(e.body, t); else if (_.NodeGuards.isForOfStatementNode(e) || _.NodeGuards.isForInStatementNode(e)) this.traverseBlocksSkipScopes(e.left, t), this.traverseBlocksSkipScopes(e.body, t); else if (_.NodeGuards.isSwitchStatementNode(e)) for (const r of e.cases) for (const e of r.consequent) this.traverseBlocksSkipScopes(e, t); else _.NodeGuards.isTryStatementNode(e) ? (this.traverseBlocksSkipScopes(e.block, t), e.handler && this.traverseBlocksSkipScopes(e.handler.body, t), e.finalizer && this.traverseBlocksSkipScopes(e.finalizer, t)) : (_.NodeGuards.isLabeledStatementNode(e) || _.NodeGuards.isWithStatementNode(e)) && this.traverseBlocksSkipScopes(e.body, t)
        }

        containsFunction(e) {
          let t = !1;
          return g.traverse(e, {
            enter: e => {
              var r;
              if (_.NodeGuards.isFunctionNode(e)) return t = !0, g.VisitorOption.Break;
              if (_.NodeGuards.isClassNode(e) && (null === (r = e.body) || void 0 === r ? void 0 : r.body)) for (const r of e.body.body) {
                if (_.NodeGuards.isPropertyDefinitionNode(r) && null !== r.value) return t = !0, g.VisitorOption.Break;
                if (_.NodeGuards.isStaticBlockNode(r)) return t = !0, g.VisitorOption.Break
              }
            }
          }), t
        }

        checkVariableShadowsOuter(e, t, r) {
          if (!r) return !1;
          const o = e.split("$$")[0], n = Array.from(t.localVariables.keys()).some(e => e.split("$$")[0] === o),
            i = t.parameters.has(e);
          return !!t.parentContext && this.isDeclaredInParentScope(e, t.parentContext) || i || t.envVars.has(e) || t.localVariables.has(e) || n
        }

        collectReferencedIdentifiers(e) {
          const t = new Set;
          return g.traverse(e.body, {
            enter: (r, o) => {
              if (_.NodeGuards.isFunctionNode(r) && r !== e) return g.VisitorOption.Skip;
              if (_.NodeGuards.isIdentifierNode(r)) {
                if (o) {
                  if (_.NodeGuards.isVariableDeclaratorNode(o) && o.id === r) return;
                  if (_.NodeGuards.isFunctionNode(o) && o.params.includes(r)) return;
                  if (_.NodeGuards.isPropertyNode(o) && o.key === r && !o.computed) return;
                  if (_.NodeGuards.isMemberExpressionNode(o) && o.property === r && !o.computed) return;
                  if (_.NodeGuards.isFunctionDeclarationNode(o) && o.id === r) return;
                  if ("CatchClause" === o.type && o.param === r) return
                }
                t.add(r.name)
              }
            }
          }), t
        }
      };
      t.VMCompilerUtils = C, d([(0, m.inject)(h.ServiceIdentifiers.IVMVariableResolver), u("design:type", "function" == typeof (a = void 0 !== b.VMVariableResolver && b.VMVariableResolver) ? a : Object)], C.prototype, "variableResolver", void 0), d([(0, m.inject)(h.ServiceIdentifiers.IScopeIdentifiersTraverser), u("design:type", "function" == typeof (s = void 0 !== I.IScopeIdentifiersTraverser && I.IScopeIdentifiersTraverser) ? s : Object)], C.prototype, "scopeIdentifiersTraverser", void 0), t.VMCompilerUtils = C = d([(0, m.injectable)(), f(0, (0, m.inject)(h.ServiceIdentifiers.IVMVariableResolver)), f(1, (0, m.inject)(h.ServiceIdentifiers.IScopeIdentifiersTraverser)), u("design:paramtypes", ["function" == typeof (n = void 0 !== b.VMVariableResolver && b.VMVariableResolver) ? n : Object, "function" == typeof (i = void 0 !== I.IScopeIdentifiersTraverser && I.IScopeIdentifiersTraverser) ? i : Object])], C)
    }, 80050: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMRuntimeCodeHelper = void 0;
      const f = r(45337), m = r(31391), g = r(18741), h = r(39032), y = r(25714), S = r(76393), N = r(31142),
        b = r(68934), _ = r(60722), v = r(50164), I = r(74341), O = r(66902), C = r(32111), E = r(60860), T = r(74361),
        R = r(7409), M = r(84133), A = r(19104), F = r(48222), P = r(27391), D = r(4592), j = r(33056), x = r(98151);
      let V = class extends F.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n), this.bytecodeKeyMapping = null, this.vmKeyMappingName = ""
        }

        initialize(e, t, r) {
          this.vmBytecodeStorage = e, this.vmOpcodeMapStorage = t, this.vmExecutorName = r, this.vmAsyncExecutorName = this.identifierNamesGenerator.generateNext(), this.identifierNamesGenerator.preserveName(this.vmAsyncExecutorName), this.vmSyncExecutorName = this.identifierNamesGenerator.generateNext(), this.identifierNamesGenerator.preserveName(this.vmSyncExecutorName), this.vmGeneratorExecutorName = this.identifierNamesGenerator.generateNext(), this.identifierNamesGenerator.preserveName(this.vmGeneratorExecutorName), this.vmGlobalsName = "", this.vmBytecodeArrayName = "", this.vmOpcodeMapName = "", this.vmModuleVarsName = ""
        }

        getVMGlobalsName() {
          return this.vmGlobalsName
        }

        getCodeHelperTemplate() {
          if (this.vmBytecodeArrayName || (this.vmBytecodeArrayName = this.identifierNamesGenerator.generateNext()), this.vmOpcodeMapName || (this.vmOpcodeMapName = this.identifierNamesGenerator.generateNext()), !this.vmGlobalsName) {
            const e = this.identifierNamesGenerator.generateForGlobalScope(),
              t = Math.floor(16777215 * this.randomGenerator.getMathRandom()).toString(16);
            this.vmGlobalsName = `${e}_${t}`
          }
          this.vmModuleVarsName || (this.vmModuleVarsName = this.identifierNamesGenerator.generateNext()), this.options.vmRandomizeKeys && !this.bytecodeKeyMapping && (this.bytecodeKeyMapping = this.generateBytecodeKeyMapping(), this.vmKeyMappingName = this.identifierNamesGenerator.generateNext());
          const e = this.options.vmRuntimeOpcodeDerivation ? (0, O.getOpcodeDerivationTemplate)() : "",
            t = this.options.vmRuntimeOpcodeDerivation ? (0, O.getOpcodeDerivationInitTemplate)() : "",
            r = this.options.vmStatefulOpcodes ? (0, C.getStateMachineFunctionsTemplate)() : "",
            o = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.smSeed` : "'smSeed'",
            n = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.seKey` : "'seKey'";
          let i = this.options.vmStatefulOpcodes ? (0, C.getStateMachineInitTemplate)() : "\n                // State machine disabled - define null placeholders\n                var _smSeed = 0;\n                var _smStateMaps = null;\n";
          i = i.replace(/\{keySmSeed\}/g, o);
          let a = this.options.vmStackEncoding ? (0, C.getStackEncodingInitTemplate)() : "";
          a = a.replace(/\{keySeKey\}/g, n);
          const s = this.bytecodeKeyMapping ? `var ${this.vmKeyMappingName}=${this.serializeKeyMapping()};` : "",
            c = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.i` : "'i'",
            l = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.c` : "'c'",
            d = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.p` : "'p'",
            p = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.l` : "'l'",
            u = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.j` : "'j'",
            f = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.x` : "'x'",
            m = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.a` : "'a'",
            g = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.o` : "'o'",
            h = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.jk` : "'jk'",
            y = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.bk` : "'bk'",
            S = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.ni` : "'ni'",
            N = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.g` : "'g'",
            b = this.bytecodeKeyMapping ? `${this.vmKeyMappingName}.s` : "'s'";
          let _ = "", v = "", T = "";
          const A = this.options.vmBytecodeFormat === M.VMBytecodeFormat.Binary,
            F = this.bytecodeKeyMapping ? this.vmKeyMappingName : "null",
            P = { vmBytecodeArrayName: this.vmBytecodeArrayName, keyC: l, keyMappingRef: F };
          if (A && (T = (0, R.getBinaryBytecodeDecoderTemplate)()), this.options.vmBytecodeArrayEncoding) {
            let e = (0, E.getBytecodeArrayEncodingTemplate)();
            A && (e = this.getBinaryWithRC4EncodingTemplate()), _ = this.customCodeHelperFormatter.formatTemplate(e, P)
          } else A ? _ = this.customCodeHelperFormatter.formatTemplate((0, R.getBinaryBytecodeAccessTemplate)(), P) : (_ = this.customCodeHelperFormatter.formatTemplate((0, E.getDirectBytecodeAccessTemplate)(), P), v = this.customCodeHelperFormatter.formatTemplate((0, E.getBigIntPreprocessingTemplate)(), P));
          const D = this.options.target === x.ObfuscationTarget.Node, j = this.options.vmSplitDispatcher,
            V = this.options.vmMacroOps, G = this.options.vmIndirectDispatch;
          return this.customCodeHelperFormatter.formatTemplate((0, I.VMRuntimeTemplate)({
            isNodeTarget: D,
            splitDispatcher: j,
            macroOps: V,
            indirectDispatch: G
          }), {
            vmBytecodeArrayName: this.vmBytecodeArrayName,
            vmOpcodeMapName: this.vmOpcodeMapName,
            vmGlobalsName: this.vmGlobalsName,
            vmGlobalsNameString: `'${this.vmGlobalsName}'`,
            vmModuleVarsName: this.vmModuleVarsName,
            vmExecutorName: this.vmExecutorName,
            vmSyncExecutorName: this.vmSyncExecutorName,
            vmAsyncExecutorName: this.vmAsyncExecutorName,
            vmGeneratorExecutorName: this.vmGeneratorExecutorName,
            bytecodeArray: this.serializeBytecode(),
            opcodeMapping: this.serializeOpcodeMapping(),
            dbgEnabled: this.options.vmDebugProtection ? "true" : "false",
            opcodeDerivationFunctions: e,
            opcodeDerivationInit: t,
            stateMachineFunctions: r,
            stateMachineInit: i,
            stackEncodingInit: a,
            keyMappingDeclaration: s,
            binaryDecoderFunctions: T,
            bytecodeArrayEncodingFunctions: _,
            bytecodePreprocessing: v,
            keyI: c,
            keyC: l,
            keyP: d,
            keyL: p,
            keyJ: u,
            keyX: f,
            keyA: m,
            keyO: g,
            keyJk: h,
            keyBk: y,
            keyNi: S,
            keyG: N,
            keyS: b
          })
        }

        getNodeStructure(e) {
          const t = j.NodeUtils.convertCodeToStructure(e);
          return this.markBytecodeConstantsAsVerbatim(t), t
        }

        generateBytecodeKeyMapping() {
          const e = ["i", "c", "p", "l", "j", "x", "a", "s", "g", "ni", "os", "o", "jk", "bk", "smSeed", "smState", "seKey"],
            t = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", r = new Set, o = {};
          for (const n of e) {
            let e;
            do {
              e = t[this.randomGenerator.getRandomInteger(0, 51)] + t[this.randomGenerator.getRandomInteger(0, 51)]
            } while (r.has(e));
            r.add(e), o[n] = e
          }
          return o
        }

        serializeKeyMapping() {
          return this.bytecodeKeyMapping ? `{${Object.entries(this.bytecodeKeyMapping).map(([e, t]) => `${e}:'${t}'`).join(",")}}` : ""
        }

        markBytecodeConstantsAsVerbatim(e, t = new Set) {
          if (Array.isArray(e)) e.forEach(e => this.markBytecodeConstantsAsVerbatim(e, t)); else if (e && "object" == typeof e && !t.has(e)) {
            t.add(e), P.NodeGuards.isLiteralNode(e) && "string" == typeof e.value && (D.NodeMetadata.set(e, { ignoredNode: !0 }), j.NodeUtils.addXVerbatimPropertyTo(e));
            for (const r in e) {
              if ("parent" === r || "metadata" === r || "x-verbatim-property" === r) continue;
              const o = e[r];
              o && "object" == typeof o && this.markBytecodeConstantsAsVerbatim(o, t)
            }
          }
        }

        serializeBytecode() {
          const e = this.vmBytecodeStorage.getAllBytecode();
          if (0 === e.length) return "[]";
          const t = this.options.vmBytecodeFormat === M.VMBytecodeFormat.Binary;
          return `[${e.map(e => {
            const r = this.options.vmStatefulOpcodes && void 0 !== e.smSeed && void 0 !== e.smState ? (0, A.deriveStateMachineConfig)(e.smSeed, e.smState, 0) : void 0, {
                flatInstructions: o,
                jumpTargets: n,
                exceptionHandlers: i
              } = this.serializeInstructionsFlat(e.instructions, e.jumpKey, e.bytecodeKey, r),
              a = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.i : "i",
              s = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.c : "c",
              c = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.p : "p",
              l = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.l : "l",
              d = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.j : "j",
              p = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.x : "x",
              u = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.a : "a",
              f = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.s : "s",
              m = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.g : "g",
              g = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.ni : "ni",
              h = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.os : "os",
              y = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.o : "o",
              S = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.jk : "jk",
              N = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.bk : "bk",
              b = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.smSeed : "smSeed",
              _ = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.smState : "smState",
              v = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.seKey : "seKey",
              I = this.buildBytecodeObject(e, o, n, i, r);
            if (t && !this.options.vmBytecodeArrayEncoding) {
              const t = this.buildBinaryBytecodeObject(e, r),
                o = (0, T.encodeBytecodeToBuffer)(t, this.bytecodeKeyMapping), n = (0, T.bufferToBase64)(o);
              return JSON.stringify(n)
            }
            if (this.options.vmBytecodeArrayEncoding) {
              let o;
              if (t) {
                const t = this.buildBinaryBytecodeObject(e, r),
                  n = (0, T.encodeBytecodeToBuffer)(t, this.bytecodeKeyMapping);
                o = (0, T.bufferToBase64)(n)
              } else o = JSON.stringify(I);
              const n = (0, E.computeEnvironmentKey)().toString(16), i = (0, E.rc4Encrypt)(o, n).toString("base64");
              return JSON.stringify(i)
            }
            let O = `{${a}:${o},${s}:${this.serializeConstants(e.constants)},${c}:${e.params},${l}:${e.locals}`;
            return n && (O += `,${d}:${n}`), i && (O += `,${p}:${i}`), e.isArrow && (O += `,${u}:1`), e.isAsync && (O += `,${f}:1`), e.isGenerator && (O += `,${m}:1`), void 0 !== e.functionNameIndex && (O += `,${g}:${e.functionNameIndex}`), void 0 !== e.opcodeSeed && this.options.vmRuntimeOpcodeDerivation ? O += `,${h}:${e.opcodeSeed}` : e.opcodeMap && (O += `,${y}:{${Object.entries(e.opcodeMap).map(([e, t]) => `${e}:${t}`).join(",")}}`), void 0 !== e.jumpKey && (O += `,${S}:${e.jumpKey}`), void 0 !== e.bytecodeKey && (O += `,${N}:${e.bytecodeKey}`), void 0 !== e.smSeed && (O += `,${b}:${e.smSeed}`), void 0 !== e.smState && (O += `,${_}:${e.smState}`), void 0 !== e.seKey && (O += `,${v}:${e.seKey}`), O += "}", O
          }).join(",")}]`
        }

        serializeInstructionsFlat(e, t, r, o) {
          const n = [], i = {}, a = {};
          let s = !1, c = !1;
          e.forEach((e, l) => {
            var d, p, u;
            const f = e.op;
            let m = f;
            if (o) {
              const e = (0, A.computeState)(o.seed, l);
              m = o.stateMaps[e][f]
            }
            if (void 0 !== r && (m ^= r), n.push(m), void 0 !== e.arg) if (void 0 !== e.arg2 && "number" == typeof e.arg) {
              const t = e.arg2 << 16 | e.arg;
              void 0 !== r ? n.push(t ^ r) : n.push(t)
            } else "string" == typeof e.arg ? n.push(JSON.stringify(e.arg)) : "number" == typeof e.arg && void 0 !== r ? n.push(e.arg ^ r) : n.push(e.arg); else n.push("null");
            if (void 0 !== e.target && (i[l] = void 0 !== t ? e.target ^ t : e.target, s = !0), void 0 !== e.catchIndex || void 0 !== e.finallyIndex || void 0 !== e.endIndex) {
              const r = null !== (d = e.catchIndex) && void 0 !== d ? d : -1,
                o = null !== (p = e.finallyIndex) && void 0 !== p ? p : -1,
                n = null !== (u = e.endIndex) && void 0 !== u ? u : -1;
              a[l] = [void 0 !== t && r >= 0 ? r ^ t : r, void 0 !== t && o >= 0 ? o ^ t : o, void 0 !== t && n >= 0 ? n ^ t : n], c = !0
            }
          });
          const l = `[${n.join(",")}]`;
          let d = null;
          s && (d = `{${Object.entries(i).map(([e, t]) => `${e}:${t}`).join(",")}}`);
          let p = null;
          return c && (p = `{${Object.entries(a).map(([e, t]) => `${e}:[${t.join(",")}]`).join(",")}}`), {
            flatInstructions: l,
            jumpTargets: d,
            exceptionHandlers: p
          }
        }

        serializeConstants(e) {
          const t = e.map(e => "bigint" == typeof e ? `${e.toString()}n` : e);
          return JSON.stringify(t)
        }

        serializeOpcodeMapping() {
          const e = this.vmOpcodeMapStorage.getMappingObject();
          return `{${Object.entries(e).map(([e, t]) => `${e}:${t}`).join(",")}}`
        }

        buildBytecodeObject(e, t, r, o, n) {
          const i = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.i : "i",
            a = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.c : "c",
            s = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.p : "p",
            c = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.l : "l",
            l = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.j : "j",
            d = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.x : "x",
            p = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.a : "a",
            u = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.s : "s",
            f = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.g : "g",
            m = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.ni : "ni",
            g = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.os : "os",
            h = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.o : "o",
            y = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.jk : "jk",
            S = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.bk : "bk",
            N = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.smSeed : "smSeed",
            b = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.smState : "smState",
            _ = this.bytecodeKeyMapping ? this.bytecodeKeyMapping.seKey : "seKey", v = new Function(`return ${t}`)(),
            I = r ? new Function(`return ${r}`)() : void 0, O = o ? new Function(`return ${o}`)() : void 0,
            C = e.constants.map(e => "bigint" == typeof e ? `${e.toString()}n` : e),
            E = { [i]: v, [a]: C, [s]: e.params, [c]: e.locals };
          return I && (E[l] = I), O && (E[d] = O), e.isArrow && (E[p] = 1), e.isAsync && (E[u] = 1), e.isGenerator && (E[f] = 1), void 0 !== e.functionNameIndex && (E[m] = e.functionNameIndex), void 0 !== e.opcodeSeed && this.options.vmRuntimeOpcodeDerivation ? E[g] = e.opcodeSeed : e.opcodeMap && (E[h] = e.opcodeMap), void 0 !== e.jumpKey && (E[y] = e.jumpKey), void 0 !== e.bytecodeKey && (E[S] = e.bytecodeKey), void 0 !== e.smSeed && (E[N] = e.smSeed), void 0 !== e.smState && (E[b] = e.smState), void 0 !== e.seKey && (E[_] = e.seKey), E
        }

        getBinaryWithRC4EncodingTemplate() {
          return "\n            // Environment-based key derivation (must match compile-time computeEnvironmentKey)\n            function _envKey() {\n                var key = 0;\n                try {\n                    key ^= (Function.prototype.toString.call(Array.prototype.push).length << 16);\n                    key ^= (Function.prototype.toString.call(Object.keys).length << 8);\n                    key ^= Function.prototype.toString.call(Math.abs).length;\n                } catch (e) {\n                    key ^= 0x12345678;\n                }\n                key ^= (Array.prototype.slice.length << 24);\n                key ^= (String.prototype.charAt.length << 20);\n                // Mix bits (MurmurHash3 finalizer)\n                key ^= (key >>> 16);\n                key = Math.imul(key, 0x85EBCA6B) >>> 0;\n                key ^= (key >>> 13);\n                key = Math.imul(key, 0xC2B2AE35) >>> 0;\n                key ^= (key >>> 16);\n                return key >>> 0;\n            }\n\n            // RC4 decrypt\n            function _rc4Dec(str, key) {\n                var s = [], j = 0, x, res = '';\n                for (var i = 0; i < 256; i++) s[i] = i;\n                for (var i = 0; i < 256; i++) {\n                    j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                    x = s[i]; s[i] = s[j]; s[j] = x;\n                }\n                var i = 0; j = 0;\n                for (var y = 0; y < str.length; y++) {\n                    i = (i + 1) % 256;\n                    j = (j + s[i]) % 256;\n                    x = s[i]; s[i] = s[j]; s[j] = x;\n                    res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n                }\n                return res;\n            }\n\n            // Base64 decode (to binary string, preserving byte values)\n            function _b64Dec(str) {\n                if (typeof Buffer !== 'undefined') {\n                    // Use latin1 to preserve byte values (not utf8 which corrupts binary data)\n                    return Buffer.from(str, 'base64').toString('latin1');\n                }\n                // Browser: atob returns a binary string with byte values preserved\n                return atob(str);\n            }\n\n            // Lazy decryption with binary decode\n            var _decKey = _envKey().toString(16);\n            var _bcCache = {};\n            function _getBytecode(id) {\n                if (_bcCache[id]) return _bcCache[id];\n                var raw = {vmBytecodeArrayName}[id];\n                if (typeof raw === 'string') {\n                    // First RC4 decrypt\n                    var decrypted = _rc4Dec(_b64Dec(raw), _decKey);\n                    // Then binary decode (decrypted is base64 of binary data)\n                    // Note: BigInt is handled natively by _decodeBinary via CT_BIGINT type tag\n                    _bcCache[id] = _decodeBinary(decrypted, {keyMappingRef});\n                } else {\n                    _bcCache[id] = raw;\n                }\n                return _bcCache[id];\n            }\n"
        }

        buildBinaryBytecodeObject(e, t) {
          const r = [];
          e.instructions.forEach((o, n) => {
            const i = o.op;
            let a = i;
            if (t) {
              const e = (0, A.computeState)(t.seed, n);
              a = t.stateMaps[e][i]
            }
            void 0 !== e.bytecodeKey && (a ^= e.bytecodeKey);
            const s = { op: a };
            void 0 !== o.arg && (void 0 !== o.arg2 && "number" == typeof o.arg ? (s.arg = o.arg, s.arg2 = o.arg2, void 0 !== e.bytecodeKey && (s.arg = s.arg ^ e.bytecodeKey, s.arg2 = s.arg2)) : "string" == typeof o.arg ? s.arg = o.arg : "number" == typeof o.arg && void 0 !== e.bytecodeKey ? s.arg = o.arg ^ e.bytecodeKey : s.arg = o.arg), void 0 !== o.target && (s.target = o.target), void 0 === o.catchIndex && void 0 === o.finallyIndex && void 0 === o.endIndex || (void 0 !== o.catchIndex && (s.catchIndex = o.catchIndex), void 0 !== o.finallyIndex && (s.finallyIndex = o.finallyIndex), void 0 !== o.endIndex && (s.endIndex = o.endIndex)), r.push(s)
          });
          const o = e.constants.map(e => {
            if ("string" == typeof e && /^-?\d+n$/.test(e)) try {
              return BigInt(e.slice(0, -1))
            } catch (t) {
              return e
            }
            return e
          }), n = { params: e.params, locals: e.locals, constants: o, instructions: r };
          return e.isArrow && (n.isArrow = !0), e.isAsync && (n.isAsync = !0), e.isGenerator && (n.isGenerator = !0), void 0 !== e.functionNameIndex && (n.functionNameIndex = e.functionNameIndex), void 0 !== e.opcodeSeed && this.options.vmRuntimeOpcodeDerivation ? n.opcodeSeed = e.opcodeSeed : e.opcodeMap && (n.opcodeMap = e.opcodeMap), void 0 !== e.jumpKey && (n.jumpKey = e.jumpKey), void 0 !== e.bytecodeKey && (n.bytecodeKey = e.bytecodeKey), void 0 !== e.smSeed && (n.smSeed = e.smSeed), void 0 !== e.smState && (n.smState = e.smState), void 0 !== e.seKey && (n.seKey = e.seKey), n
        }
      };
      t.VMRuntimeCodeHelper = V, d([(0, v.initializable)(), p("design:type", "function" == typeof (c = void 0 !== b.IVMBytecodeStorage && b.IVMBytecodeStorage) ? c : Object)], V.prototype, "vmBytecodeStorage", void 0), d([(0, v.initializable)(), p("design:type", "function" == typeof (l = void 0 !== _.IVMOpcodeMapStorage && _.IVMOpcodeMapStorage) ? l : Object)], V.prototype, "vmOpcodeMapStorage", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmExecutorName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmAsyncExecutorName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmSyncExecutorName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmGeneratorExecutorName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmGlobalsName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmBytecodeArrayName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmOpcodeMapName", void 0), d([(0, v.initializable)(), p("design:type", String)], V.prototype, "vmModuleVarsName", void 0), t.VMRuntimeCodeHelper = V = d([(0, f.injectable)(), u(0, (0, f.inject)(m.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), u(1, (0, f.inject)(m.ServiceIdentifiers.ICustomCodeHelperFormatter)), u(2, (0, f.inject)(m.ServiceIdentifiers.ICustomCodeHelperObfuscator)), u(3, (0, f.inject)(m.ServiceIdentifiers.IRandomGenerator)), u(4, (0, f.inject)(m.ServiceIdentifiers.IOptions)), p("design:paramtypes", ["function" == typeof (o = void 0 !== g.TIdentifierNamesGeneratorFactory && g.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== h.ICustomCodeHelperFormatter && h.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== y.ICustomCodeHelperObfuscator && y.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== N.IRandomGenerator && N.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== S.IOptions && S.IOptions) ? s : Object])], V)
    }, 80053: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BlockStatementSimplifyTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(92486), f = r(75716), m = r(24698),
        g = r(27391), h = r(93571), y = r(33056);
      let S = class extends m.AbstractStatementSimplifyTransformer {
        constructor(e, t) {
          super(e, t), this.runAfter = [u.NodeTransformer.VariableDeclarationsMergeTransformer]
        }

        getVisitor(e) {
          return e === f.NodeTransformationStage.Simplifying ? {
            leave: (e, t) => {
              if (t && g.NodeGuards.isBlockStatementNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          const r = this.getStatementSimplifyData(e);
          if (!r) return e;
          const o = this.getPartialStatement(r),
            n = g.NodeGuards.isBlockStatementNode(o) ? o : h.NodeFactory.blockStatementNode([o]);
          return y.NodeUtils.parentizeNode(n, t)
        }
      };
      t.BlockStatementSimplifyTransformer = S, t.BlockStatementSimplifyTransformer = S = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], S)
    }, 80225: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IsDomainLockRedirectUrl = void 0;
      const o = r(97403), n = r(98151), i = r(45887), a = r(4057);
      t.IsDomainLockRedirectUrl = () => (e, t) => {
        (0, o.ValidateIf)(({ domainLockRedirectUrl: e }) => e !== i.DEFAULT_PRESET.domainLockRedirectUrl)(e, t), (0, o.IsUrl)({
          require_protocol: !1,
          require_host: !1
        })(e, t), (0, a.IsAllowedForObfuscationTargets)([n.ObfuscationTarget.Browser, n.ObfuscationTarget.BrowserNoEval])(e, t)
      }
    }, 80299: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomainLockCustomCodeHelperGroup = void 0;
      const p = r(45337), u = r(31391), f = r(58544), m = r(18741), g = r(76393), h = r(31142), y = r(50164),
        S = r(51875), N = r(75716), b = r(26455), _ = r(47250), v = r(75096);
      let I = class extends b.AbstractCustomCodeHelperGroup {
        constructor(e, t, r, o) {
          super(t, r, o), this.customCodeHelperFactory = e
        }

        appendOnPreparingStage(e, t) {
          var r;
          if (!this.options.domainLock.length) return;
          const o = this.getRandomCallsGraphIndex(t.length),
            n = t.length ? _.NodeAppender.getOptimalBlockScope(t, o) : e,
            i = t.length ? _.NodeAppender.getOptimalBlockScope(t, o, 1) : e,
            a = null !== (r = v.NodeLexicalScopeUtils.getLexicalScope(n)) && void 0 !== r ? r : null,
            s = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext(),
            c = a ? this.identifierNamesGenerator.generate(a) : this.identifierNamesGenerator.generateNext();
          this.appendCustomNodeIfExist(S.CustomCodeHelper.DomainLock, e => {
            e.initialize(c, s), _.NodeAppender.prepend(n, e.getNode())
          }), this.appendCustomNodeIfExist(S.CustomCodeHelper.CallsControllerFunction, e => {
            e.initialize(N.NodeTransformationStage.Preparing, c), _.NodeAppender.prepend(i, e.getNode())
          })
        }

        initialize() {
          if (this.customCodeHelpers = new Map, !this.options.domainLock.length) return;
          const e = this.customCodeHelperFactory(S.CustomCodeHelper.DomainLock),
            t = this.customCodeHelperFactory(S.CustomCodeHelper.CallsControllerFunction);
          this.customCodeHelpers.set(S.CustomCodeHelper.DomainLock, e), this.customCodeHelpers.set(S.CustomCodeHelper.CallsControllerFunction, t)
        }
      };
      t.DomainLockCustomCodeHelperGroup = I, c([(0, y.initializable)(), l("design:type", "function" == typeof (s = "undefined" != typeof Map && Map) ? s : Object)], I.prototype, "customCodeHelpers", void 0), t.DomainLockCustomCodeHelperGroup = I = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__ICustomCodeHelper)), d(1, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(2, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TCustomCodeHelperFactory && f.TCustomCodeHelperFactory) ? o : Object, "function" == typeof (n = void 0 !== m.TIdentifierNamesGeneratorFactory && m.TIdentifierNamesGeneratorFactory) ? n : Object, "function" == typeof (i = void 0 !== h.IRandomGenerator && h.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== g.IOptions && g.IOptions) ? a : Object])], I)
    }, 80323: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), l = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && c(t, e, r[n]);
        return l(t, e), t
      }), u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionKeysTransformer = void 0;
      const m = r(45337), g = r(31391), h = p(r(31659)), y = r(44637), S = r(76393), N = r(31142), b = r(75716),
        _ = r(21559), v = r(13245), I = r(27391), O = r(43243);
      let C = n = class extends v.AbstractNodeTransformer {
        constructor(e, t, r) {
          super(t, r), this.objectExpressionExtractorFactory = e
        }

        static isProhibitedObjectExpressionNode(e, t, r) {
          return n.isReferencedIdentifierName(e, r) || n.isProhibitedArrowFunctionExpression(e, t) || n.isObjectExpressionWithCallExpression(e) || n.isProhibitedSequenceExpression(e, r)
        }

        static getReferencedIdentifierName(e) {
          return I.NodeGuards.isIdentifierNode(e) ? e.name : n.thisIdentifierName
        }

        static isReferencedIdentifierName(e, t) {
          const r = new Set;
          let o = !1, i = !1;
          return h.traverse(t, {
            enter: t => {
              if (t === e && (i = !0), I.NodeGuards.isIdentifierNode(t) || I.NodeGuards.isThisExpressionNode(t)) {
                if (i) return r.has(n.getReferencedIdentifierName(t)) ? (o = !0, h.VisitorOption.Break) : void 0;
                r.add(n.getReferencedIdentifierName(t))
              }
            }, leave: t => {
              if (t === e) return i = !1, h.VisitorOption.Break
            }
          }), o
        }

        static isProhibitedArrowFunctionExpression(e, t) {
          return I.NodeGuards.isArrowFunctionExpressionNode(t) && t.body === e
        }

        static isObjectExpressionWithCallExpression(e) {
          let t = !1;
          return h.traverse(e, {
            enter: e => {
              if (I.NodeGuards.isCallExpressionNode(e) || I.NodeGuards.isNewExpressionNode(e)) return t = !0, h.VisitorOption.Break
            }
          }), t
        }

        static isProhibitedSequenceExpression(e, t) {
          return I.NodeGuards.isExpressionStatementNode(t) && I.NodeGuards.isSequenceExpressionNode(t.expression) && t.expression.expressions.some(e => I.NodeGuards.isCallExpressionNode(e) && I.NodeGuards.isSuperNode(e.callee))
        }

        getVisitor(e) {
          return this.options.transformObjectKeys && e === b.NodeTransformationStage.Converting ? {
            leave: (e, t) => {
              if (t && I.NodeGuards.isObjectExpressionNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (!e.properties.length) return e;
          const r = O.NodeStatementUtils.getRootStatementOfNode(e);
          return n.isProhibitedObjectExpressionNode(e, t, r) ? e : this.applyObjectExpressionKeysExtractorsRecursive(n.objectExpressionExtractorNames, e, r)
        }

        applyObjectExpressionKeysExtractorsRecursive(e, t, r) {
          const o = [...e], n = o.shift();
          if (!n) return t;
          const {
            nodeToReplace: i,
            objectExpressionHostStatement: a,
            objectExpressionNode: s
          } = this.objectExpressionExtractorFactory(n).extract(t, r);
          return this.applyObjectExpressionKeysExtractorsRecursive(o, s, a), i
        }
      };
      t.ObjectExpressionKeysTransformer = C, C.thisIdentifierName = "this", C.objectExpressionExtractorNames = [_.ObjectExpressionExtractor.ObjectExpressionToVariableDeclarationExtractor, _.ObjectExpressionExtractor.BasePropertiesExtractor], t.ObjectExpressionKeysTransformer = C = n = d([(0, m.injectable)(), f(0, (0, m.inject)(g.ServiceIdentifiers.Factory__IObjectExpressionExtractor)), f(1, (0, m.inject)(g.ServiceIdentifiers.IRandomGenerator)), f(2, (0, m.inject)(g.ServiceIdentifiers.IOptions)), u("design:paramtypes", ["function" == typeof (i = void 0 !== y.TObjectExpressionExtractorFactory && y.TObjectExpressionExtractorFactory) ? i : Object, "function" == typeof (a = void 0 !== N.IRandomGenerator && N.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== S.IOptions && S.IOptions) ? s : Object])], C)
    }, 80388: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebugProtectionFunctionIntervalCodeHelper = void 0;
      const p = r(45337), u = r(31391), f = r(18741), m = r(39032), g = r(25714), h = r(76393), y = r(31142),
        S = r(98151), N = r(50164), b = r(47788), _ = r(14698), v = r(48222), I = r(33056);
      let O = class extends v.AbstractCustomCodeHelper {
        constructor(e, t, r, o, n) {
          super(e, t, r, o, n)
        }

        initialize(e, t) {
          this.debugProtectionFunctionName = e, this.debugProtectionInterval = t
        }

        getNodeStructure(e) {
          return I.NodeUtils.convertCodeToStructure(e)
        }

        getCodeHelperTemplate() {
          const e = this.options.target !== S.ObfuscationTarget.BrowserNoEval ? this.getGlobalVariableTemplate() : (0, _.GlobalVariableNoEvalTemplate)();
          return this.customCodeHelperFormatter.formatTemplate((0, b.DebugProtectionFunctionIntervalTemplate)(), {
            debugProtectionFunctionName: this.debugProtectionFunctionName,
            debugProtectionInterval: this.debugProtectionInterval,
            globalVariableTemplate: e
          })
        }
      };
      t.DebugProtectionFunctionIntervalCodeHelper = O, c([(0, N.initializable)(), l("design:type", String)], O.prototype, "debugProtectionFunctionName", void 0), c([(0, N.initializable)(), l("design:type", Number)], O.prototype, "debugProtectionInterval", void 0), t.DebugProtectionFunctionIntervalCodeHelper = O = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), d(1, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperFormatter)), d(2, (0, p.inject)(u.ServiceIdentifiers.ICustomCodeHelperObfuscator)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== f.TIdentifierNamesGeneratorFactory && f.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== m.ICustomCodeHelperFormatter && m.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.ICustomCodeHelperObfuscator && g.ICustomCodeHelperObfuscator) ? i : Object, "function" == typeof (a = void 0 !== y.IRandomGenerator && y.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== h.IOptions && h.IOptions) ? s : Object])], O)
    }, 80540: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 80904: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMLiteralBytecodeCompiler = void 0;
      const c = r(45337), l = r(20924), d = r(25560), p = r(31391), u = r(43636), f = r(27391), m = r(59805),
        g = r(25115);
      let h = class {
        constructor(e, t) {
          this.vmCompilerUtils = e, this.variableResolver = t
        }

        compileLiteral(e, t) {
          const r = this.vmCompilerUtils.createInstructionBuilder(t);
          if (null === e.value) r.pushNull(); else if (void 0 === e.value) r.pushUndefined(); else if ("regex" in e) {
            const t = e, o = t.regex.pattern, n = t.regex.flags;
            r.newRegex(o, n)
          } else if ("bigint" in e) {
            const t = `${e.bigint}n`;
            r.loadConst(t)
          } else r.loadConst(e.value)
        }

        compileIdentifier(e, t) {
          var r, o, n;
          const i = this.vmCompilerUtils.createInstructionBuilder(t), a = e.name;
          if ("arguments" === a) return t.isArrowFunction ? (t.capturedArguments = !0, t.capturedVars.add(m.VM_SPECIAL_VARS.capturedArguments), void i.loadFromEnvByName(m.VM_SPECIAL_VARS.capturedArguments)) : void i.emitRaw({
            op: g.VMOpCode.ARGUMENTS,
            arg: 0
          });
          if (null === (r = t.classExpressionNameAliases) || void 0 === r ? void 0 : r.has(a)) {
            const e = t.classExpressionNameAliases.get(a);
            return void i.loadFromEnvByName(e)
          }
          if (t.functionName && a === t.functionName) {
            const e = t.localVariables.has(a), r = t.parameters.has(a);
            if (!e && !r) return void i.loadFromEnvByName(a);
            if (r) {
              const e = t.parameters.get(a);
              return void i.loadArg(e)
            }
          }
          const s = this.variableResolver.resolve(a, t);
          switch (s.location) {
            case d.VariableLocation.Environment:
              this.isVariableInParentScope(a, t) && !this.hasLocalDeclaration(a, t) && (t.capturedVars.add(a), t.parentContext && !t.parentContext.envVars.has(a) && t.parentContext.envVars.add(a)), i.loadFromEnv(s.index);
              break;
            case d.VariableLocation.Parameter:
              i.loadArg(s.index);
              break;
            case d.VariableLocation.Local: {
              const e = this.vmCompilerUtils.getActualLocalIndex(s.index, t);
              i.loadLocal(e);
              break
            }
            case d.VariableLocation.TDZ:
              i.throwError("ReferenceError", `Cannot access '${a}' before initialization`);
              break;
            case d.VariableLocation.Global: {
              const e = this.isVariableInParentScope(a, t),
                r = null !== (n = null === (o = t.declaredVariables) || void 0 === o ? void 0 : o.has(a)) && void 0 !== n && n;
              e || void 0 !== t.parentContext && r ? (this.hasLocalDeclaration(a, t) || (t.capturedVars.add(a), t.parentContext && !t.parentContext.envVars.has(a) && t.parentContext.envVars.add(a)), i.loadFromEnvByName(a)) : i.loadGlobal(s.index);
              break
            }
          }
        }

        compileArrayExpression(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          n.newArray();
          for (const i of e.elements) null === i ? (n.pushUndefined(), n.arrayPush()) : f.NodeGuards.isSpreadElementNode(i) ? (null === (r = t.dispatch) || void 0 === r || r.expression(i.argument), n.arraySpreadPush()) : (null === (o = t.dispatch) || void 0 === o || o.expression(i), n.arrayPush())
        }

        compileObjectExpression(e, t) {
          this.vmCompilerUtils.createInstructionBuilder(t).newObject();
          for (const r of e.properties) this.compileObjectProperty(r, t)
        }

        compileTemplateLiteral(e, t) {
          var r;
          0 !== e.quasis.length ? 0 !== e.expressions.length ? this.compileTemplateLiteralParts(e, t) : this.pushConstantString(null !== (r = e.quasis[0].value.cooked) && void 0 !== r ? r : "", t) : this.pushConstantString("", t)
        }

        compileTaggedTemplateExpression(e, t) {
          var r, o, n;
          const i = this.vmCompilerUtils.createInstructionBuilder(t);
          i.newArray();
          for (const t of e.quasi.quasis) {
            const e = null !== (r = t.value.cooked) && void 0 !== r ? r : t.value.raw;
            i.loadConst(e), i.arrayPush()
          }
          for (const r of e.quasi.expressions) null === (o = t.dispatch) || void 0 === o || o.expression(r);
          null === (n = t.dispatch) || void 0 === n || n.expression(e.tag);
          const a = 1 + e.quasi.expressions.length;
          i.loadConst(a), i.call(a)
        }

        compileObjectProperty(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          if (f.NodeGuards.isSpreadElementNode(e)) return null === (r = t.dispatch) || void 0 === r || r.expression(e.argument), void n.objectSpread();
          const i = e;
          if ("get" !== i.kind) if ("set" !== i.kind) {
            if (n.dup(), i.computed) return null === (o = t.dispatch) || void 0 === o || o.expression(i.key), this.compileObjectPropertyValue(i, t) ? (n.setComputed(), void n.pop()) : (n.pop(), void n.pop());
            this.compileObjectPropertyValue(i, t) ? (this.compileObjectPropertyKey(i, t), n.pop()) : n.pop()
          } else this.compileObjectSetter(i, t); else this.compileObjectGetter(i, t)
        }

        compileObjectGetter(e, t) {
          this.compileObjectAccessor(e, t, !0)
        }

        compileObjectSetter(e, t) {
          this.compileObjectAccessor(e, t, !1)
        }

        compileObjectAccessor(e, t, r) {
          var o, n, i;
          const a = this.vmCompilerUtils.createInstructionBuilder(t);
          if (!f.NodeGuards.isFunctionExpressionNode(e.value)) return;
          if (e.computed) return null === (o = t.dispatch) || void 0 === o || o.expression(e.key), null === (n = t.dispatch) || void 0 === n || n.expression(e.value), void (r ? a.emitRaw({ op: g.VMOpCode.DEFINE_GETTER_COMPUTED }) : a.emitRaw({ op: g.VMOpCode.DEFINE_SETTER_COMPUTED }));
          null === (i = t.dispatch) || void 0 === i || i.expression(e.value);
          const s = this.getPropertyName(e);
          if (!s) return void a.pop();
          const c = t.constantPool.add(s);
          r ? a.defineGetter(c) : a.defineSetter(c)
        }

        compileObjectPropertyValue(e, t) {
          var r, o, n;
          return e.method ? !!f.NodeGuards.isFunctionExpressionNode(e.value) && (null === (r = t.dispatch) || void 0 === r || r.expression(e.value), !0) : e.shorthand ? !!f.NodeGuards.isIdentifierNode(e.key) && (null === (o = t.dispatch) || void 0 === o || o.expression(e.key), !0) : (null === (n = t.dispatch) || void 0 === n || n.expression(e.value), !0)
        }

        compileObjectPropertyKey(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          if (e.computed) return null === (r = t.dispatch) || void 0 === r || r.expression(e.key), void o.setComputed();
          let n;
          if (f.NodeGuards.isIdentifierNode(e.key)) n = e.key.name; else {
            if (!f.NodeGuards.isLiteralNode(e.key)) return o.pop(), void o.pop();
            n = String(e.key.value)
          }
          const i = t.constantPool.add(n);
          o.setProperty(i)
        }

        getPropertyName(e) {
          return e.computed ? null : f.NodeGuards.isIdentifierNode(e.key) ? e.key.name : f.NodeGuards.isLiteralNode(e.key) ? String(e.key.value) : null
        }

        compileTemplateLiteralParts(e, t) {
          var r;
          const o = null !== (r = e.quasis[0].value.cooked) && void 0 !== r ? r : "";
          this.pushConstantString(o, t);
          for (let r = 0; r < e.expressions.length; r++) this.compileTemplateLiteralExpression(r, e, t)
        }

        compileTemplateLiteralExpression(e, t, r) {
          var o, n;
          const i = this.vmCompilerUtils.createInstructionBuilder(r);
          null === (o = r.dispatch) || void 0 === o || o.expression(t.expressions[e]), i.add();
          const a = null !== (n = t.quasis[e + 1].value.cooked) && void 0 !== n ? n : "";
          a.length > 0 && (this.pushConstantString(a, r), i.add())
        }

        pushConstantString(e, t) {
          this.vmCompilerUtils.createInstructionBuilder(t).loadConst(e)
        }

        isVariableInParentScope(e, t) {
          let r = t.parentContext;
          for (; r;) {
            if (r.parameters.has(e) && !r.parametersInTDZ.has(e)) return !0;
            if (r.localVariables.has(e)) return !0;
            for (const [t] of r.localVariables) if (t.startsWith(`${e}${m.VM_SEPARATORS.blockScope}`)) return !0;
            r = r.parentContext
          }
          return !1
        }

        hasLocalDeclaration(e, t) {
          var r, o;
          return t.localVariables.has(e) || t.parameters.has(e) || null !== (o = null === (r = t.perIterationLoopVars) || void 0 === r ? void 0 : r.has(e)) && void 0 !== o && o || Array.from(t.localVariables.keys()).some(t => t.startsWith(`${e}${m.VM_SEPARATORS.blockScope}`))
        }
      };
      t.VMLiteralBytecodeCompiler = h, t.VMLiteralBytecodeCompiler = h = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IVMCompilerUtils)), s(1, (0, c.inject)(p.ServiceIdentifiers.IVMVariableResolver)), a("design:paramtypes", ["function" == typeof (o = void 0 !== l.IVMCompilerUtils && l.IVMCompilerUtils) ? o : Object, "function" == typeof (n = void 0 !== u.VMVariableResolver && u.VMVariableResolver) ? n : Object])], h)
    }, 80935: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ControlFlowReplacer = void 0, function (e) {
        e.BinaryExpressionControlFlowReplacer = "BinaryExpressionControlFlowReplacer", e.CallExpressionControlFlowReplacer = "CallExpressionControlFlowReplacer", e.LogicalExpressionControlFlowReplacer = "LogicalExpressionControlFlowReplacer", e.StringArrayCallControlFlowReplacer = "StringArrayCallControlFlowReplacer", e.StringLiteralControlFlowReplacer = "StringLiteralControlFlowReplacer"
      }(r || (t.ControlFlowReplacer = r = {}))
    }, 81077: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.utilsModule = void 0;
      const o = r(45337), n = r(31391), i = r(98858), a = r(95225), s = r(72083), c = r(69684), l = r(46391),
        d = r(3734), p = r(71389);
      t.utilsModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.IArrayUtils).to(i.ArrayUtils).inSingletonScope(), e(n.ServiceIdentifiers.IRandomGenerator).to(d.RandomGenerator).inSingletonScope(), e(n.ServiceIdentifiers.ICryptUtils).to(a.CryptUtils).inSingletonScope(), e(n.ServiceIdentifiers.ICryptUtilsStringArray).to(s.CryptUtilsStringArray).inSingletonScope(), e(n.ServiceIdentifiers.IEscapeSequenceEncoder).to(c.EscapeSequenceEncoder).inSingletonScope(), e(n.ServiceIdentifiers.ILevelledTopologicalSorter).to(l.LevelledTopologicalSorter), e(n.ServiceIdentifiers.ISetUtils).to(p.SetUtils).inSingletonScope()
      })
    }, 81102: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 81131: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractStringArrayIndexNode = void 0;
      const c = r(45337), l = r(76393), d = r(31142), p = r(31391);
      let u = class {
        constructor(e, t) {
          this.randomGenerator = e, this.options = t
        }
      };
      t.AbstractStringArrayIndexNode = u, t.AbstractStringArrayIndexNode = u = i([(0, c.injectable)(), s(0, (0, c.inject)(p.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(p.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== d.IRandomGenerator && d.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== l.IOptions && l.IOptions) ? n : Object])], u)
    }, 81600: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.WeakMapStorage = void 0;
      const l = r(45337), d = r(31391), p = r(76393), u = r(31142), f = r(50164);
      let m = class {
        constructor(e, t) {
          this.randomGenerator = e, this.options = t
        }

        initialize() {
          this.storage = new Map, this.storageId = this.randomGenerator.getRandomString(6)
        }

        get(e) {
          return this.storage.get(e)
        }

        getOrThrow(e) {
          const t = this.get(e);
          if (!t) throw new Error(`No value found in weak map storage with key \`${e}\``);
          return t
        }

        getStorage() {
          return this.storage
        }

        getStorageId() {
          return this.storageId
        }

        has(e) {
          return this.storage.has(e)
        }

        set(e, t) {
          this.storage.set(e, t)
        }
      };
      t.WeakMapStorage = m, a([(0, f.initializable)(), s("design:type", String)], m.prototype, "storageId", void 0), a([(0, f.initializable)(), s("design:type", "function" == typeof (i = "undefined" != typeof WeakMap && WeakMap) ? i : Object)], m.prototype, "storage", void 0), a([(0, l.postConstruct)(), s("design:type", Function), s("design:paramtypes", []), s("design:returntype", void 0)], m.prototype, "initialize", null), t.WeakMapStorage = m = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(1, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (o = void 0 !== u.IRandomGenerator && u.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== p.IOptions && p.IOptions) ? n : Object])], m)
    }, 82038: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.OptionsPreset = void 0;
      const o = r(39079);
      t.OptionsPreset = o.Utils.makeEnum({
        Default: "default",
        LowObfuscation: "low-obfuscation",
        MediumObfuscation: "medium-obfuscation",
        HighObfuscation: "high-obfuscation",
        VMLowObfuscation: "vm-low-obfuscation",
        VMMediumObfuscation: "vm-medium-obfuscation"
      })
    }, 82232: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VM_LOW_OBFUSCATION_PRESET = t.VM_LOW_OBFUSCATION_PRESET_VM_OPTIONS = void 0;
      const o = r(82038), n = r(6335), i = r(76436), a = r(84133);
      t.VM_LOW_OBFUSCATION_PRESET_VM_OPTIONS = {
        vmObfuscation: !0,
        vmObfuscationThreshold: 1,
        vmOpcodeShuffle: !1,
        vmBytecodeEncoding: !1,
        vmBytecodeArrayEncoding: !1,
        vmJumpsEncoding: !1,
        vmDecoyOpcodes: !1,
        vmDeadCodeInjection: !1,
        vmSplitDispatcher: !1,
        vmMacroOps: !1,
        vmDebugProtection: !1,
        vmRuntimeOpcodeDerivation: !1,
        vmStatefulOpcodes: !1,
        vmStackEncoding: !1,
        vmRandomizeKeys: !1,
        vmIndirectDispatch: !1,
        vmBytecodeFormat: a.VMBytecodeFormat.Json
      }, t.VM_LOW_OBFUSCATION_PRESET = Object.freeze({
        ...n.NO_ADDITIONAL_NODES_PRESET, ...t.VM_LOW_OBFUSCATION_PRESET_VM_OPTIONS,
        optionsPreset: o.OptionsPreset.VMLowObfuscation,
        compact: !0,
        simplify: !0,
        identifierNamesGenerator: i.IdentifierNamesGenerator.MangledShuffledIdentifierNamesGenerator
      })
    }, 82247: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), u = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), f = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, m = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && p(t, e, r[n]);
        return u(t, e), t
      }), g = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, h = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.JavaScriptObfuscator = void 0;
      const y = r(45337), S = r(31391), N = m(r(65850)), b = r(88320), _ = r(85498), v = r(41525), I = r(76393),
        O = r(31142), C = r(80540), E = r(78550), T = r(14932), R = r(128), M = r(92486), A = r(75716), F = r(57088),
        P = r(51168), D = r(63989), j = r(27391), x = r(39079);
      let V = n = class {
        constructor(e, t, r, o, n, i) {
          this.codeTransformersRunner = e, this.nodeTransformersRunner = t, this.randomGenerator = r, this.obfuscationResultFactory = o, this.logger = n, this.options = i
        }

        obfuscate(e) {
          var t, r;
          "string" != typeof e && (e = "");
          const o = Date.now();
          this.logger.info(R.LoggingMessage.Version, x.Utils.buildVersionMessage(null === (t = null === process || void 0 === process ? void 0 : process.env) || void 0 === t ? void 0 : t.VERSION, null === (r = null === process || void 0 === process ? void 0 : process.env) || void 0 === r ? void 0 : r.BUILD_TIMESTAMP)), this.logger.info(R.LoggingMessage.ObfuscationStarted), this.logger.info(R.LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getInputSeed()), e = this.runCodeTransformationStage(e, T.CodeTransformationStage.PreparingTransformers);
          const n = this.parseCode(e), i = this.transformAstTree(n), a = this.generateCode(e, i);
          a.code = this.runCodeTransformationStage(a.code, T.CodeTransformationStage.FinalizingTransformers);
          const s = (Date.now() - o) / 1e3;
          return this.logger.success(R.LoggingMessage.ObfuscationCompleted, s), this.getObfuscationResult(a)
        }

        parseCode(e) {
          return D.ASTParserFacade.parse(e, n.parseOptions)
        }

        transformAstTree(e) {
          return e = this.runNodeTransformationStage(e, A.NodeTransformationStage.Initializing), !j.NodeGuards.isProgramNode(e) || e.body.length || e.leadingComments || e.trailingComments ? (e = this.runNodeTransformationStage(e, A.NodeTransformationStage.Preparing), this.options.vmObfuscation && (e = this.runNodeTransformationStage(e, A.NodeTransformationStage.VMObfuscation)), this.options.deadCodeInjection && (e = this.runNodeTransformationStage(e, A.NodeTransformationStage.DeadCodeInjection)), e = this.runNodeTransformationStage(e, A.NodeTransformationStage.ControlFlowFlattening), this.options.renameProperties && (e = this.runNodeTransformationStage(e, A.NodeTransformationStage.RenameProperties)), e = this.runNodeTransformationStage(e, A.NodeTransformationStage.Converting), e = this.runNodeTransformationStage(e, A.NodeTransformationStage.RenameIdentifiers), e = this.runNodeTransformationStage(e, A.NodeTransformationStage.StringArray), this.options.simplify && (e = this.runNodeTransformationStage(e, A.NodeTransformationStage.Simplifying)), e = this.runNodeTransformationStage(e, A.NodeTransformationStage.Finalizing)) : (this.logger.warn(R.LoggingMessage.EmptySourceCode), e)
        }

        generateCode(e, t) {
          const r = {
            ...n.escodegenParams,
            format: { compact: this.options.compact }, ...this.options.sourceMap && {
              ...this.options.sourceMapSourcesMode === F.SourceMapSourcesMode.SourcesContent ? {
                sourceMap: "sourceMap",
                sourceContent: e
              } : { sourceMap: this.options.inputFileName || "sourceMap" }
            }
          }, o = N.generate(t, r);
          return o.map = o.map ? o.map.toString() : "", o
        }

        getObfuscationResult(e) {
          return this.obfuscationResultFactory(e.code, e.map)
        }

        runCodeTransformationStage(e, t) {
          return this.logger.info(R.LoggingMessage.CodeTransformationStage, t), this.codeTransformersRunner.transform(e, n.codeTransformersList, t)
        }

        runNodeTransformationStage(e, t) {
          return this.logger.info(R.LoggingMessage.NodeTransformationStage, t), this.nodeTransformersRunner.transform(e, n.nodeTransformersList, t)
        }
      };
      t.JavaScriptObfuscator = V, V.parseOptions = {
        ecmaVersion: P.ecmaVersion,
        allowHashBang: !0,
        allowImportExportEverywhere: !0,
        allowReturnOutsideFunction: !0,
        locations: !0,
        ranges: !0
      }, V.escodegenParams = {
        comment: !0,
        verbatim: "x-verbatim-property",
        sourceMapWithCode: !0
      }, V.codeTransformersList = [E.CodeTransformer.HashbangOperatorTransformer], V.nodeTransformersList = [M.NodeTransformer.BooleanLiteralTransformer, M.NodeTransformer.BlockStatementControlFlowTransformer, M.NodeTransformer.BlockStatementSimplifyTransformer, M.NodeTransformer.ClassFieldTransformer, M.NodeTransformer.CommentsTransformer, M.NodeTransformer.CustomCodeHelpersTransformer, M.NodeTransformer.DeadCodeInjectionTransformer, M.NodeTransformer.EscapeSequenceTransformer, M.NodeTransformer.EvalCallExpressionTransformer, M.NodeTransformer.ExportSpecifierTransformer, M.NodeTransformer.ExpressionStatementsMergeTransformer, M.NodeTransformer.FunctionControlFlowTransformer, M.NodeTransformer.IfStatementSimplifyTransformer, M.NodeTransformer.LabeledStatementTransformer, M.NodeTransformer.RenamePropertiesTransformer, M.NodeTransformer.MemberExpressionTransformer, M.NodeTransformer.MetadataTransformer, M.NodeTransformer.NumberLiteralTransformer, M.NodeTransformer.NumberToNumericalExpressionTransformer, M.NodeTransformer.ObfuscatingGuardsTransformer, M.NodeTransformer.ObjectExpressionKeysTransformer, M.NodeTransformer.ObjectExpressionTransformer, M.NodeTransformer.ObjectPatternPropertiesTransformer, M.NodeTransformer.ParentificationTransformer, M.NodeTransformer.ScopeIdentifiersTransformer, M.NodeTransformer.ScopeThroughIdentifiersTransformer, M.NodeTransformer.SplitStringTransformer, M.NodeTransformer.StringArrayControlFlowTransformer, M.NodeTransformer.StringArrayRotateFunctionTransformer, M.NodeTransformer.StringArrayScopeCallsWrapperTransformer, M.NodeTransformer.StringArrayTransformer, M.NodeTransformer.TemplateLiteralTransformer, M.NodeTransformer.DirectivePlacementTransformer, M.NodeTransformer.VariableDeclarationsMergeTransformer, M.NodeTransformer.VariablePreserveTransformer, M.NodeTransformer.VMTransformer], t.JavaScriptObfuscator = V = n = f([(0, y.injectable)(), h(0, (0, y.inject)(S.ServiceIdentifiers.ICodeTransformersRunner)), h(1, (0, y.inject)(S.ServiceIdentifiers.INodeTransformersRunner)), h(2, (0, y.inject)(S.ServiceIdentifiers.IRandomGenerator)), h(3, (0, y.inject)(S.ServiceIdentifiers.Factory__IObfuscationResult)), h(4, (0, y.inject)(S.ServiceIdentifiers.ILogger)), h(5, (0, y.inject)(S.ServiceIdentifiers.IOptions)), g("design:paramtypes", ["function" == typeof (i = void 0 !== _.ICodeTransformersRunner && _.ICodeTransformersRunner) ? i : Object, "function" == typeof (a = void 0 !== C.INodeTransformersRunner && C.INodeTransformersRunner) ? a : Object, "function" == typeof (s = void 0 !== O.IRandomGenerator && O.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== b.TObfuscationResultFactory && b.TObfuscationResultFactory) ? c : Object, "function" == typeof (l = void 0 !== v.ILogger && v.ILogger) ? l : Object, "function" == typeof (d = void 0 !== I.IOptions && I.IOptions) ? d : Object])], V)
    }, 82380: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallsWrapperBase64CodeHelper = void 0;
      const n = r(45337), i = r(7962), a = r(63191), s = r(54867);
      let c = class extends s.StringArrayCallsWrapperCodeHelper {
        getDecodeStringArrayTemplate() {
          const e = this.randomGenerator.getRandomString(6),
            t = this.customCodeHelperFormatter.formatTemplate((0, i.AtobTemplate)(this.options.selfDefending), { atobFunctionName: e }),
            r = this.getSelfDefendingTemplate();
          return this.customCodeHelperFormatter.formatTemplate((0, a.StringArrayBase64DecodeTemplate)(this.randomGenerator), {
            atobPolyfill: t,
            atobFunctionName: e,
            selfDefendingCode: r,
            stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,
            stringArrayFunctionName: this.stringArrayFunctionName
          })
        }
      };
      t.StringArrayCallsWrapperBase64CodeHelper = c, t.StringArrayCallsWrapperBase64CodeHelper = c = o([(0, n.injectable)()], c)
    }, 82660: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, c = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NumberToNumericalExpressionTransformer = void 0;
      const l = r(45337), d = r(31391), p = r(45432), u = r(76393), f = r(31142), m = r(75716), g = r(13245),
        h = r(27391), y = r(93571), S = r(59228), N = r(24660), b = r(32238);
      let _ = class extends g.AbstractNodeTransformer {
        constructor(e, t, r) {
          super(t, r), this.numberNumericalExpressionAnalyzer = e
        }

        getVisitor(e) {
          return this.options.numbersToExpressions && e === m.NodeTransformationStage.Converting ? {
            leave: (e, t) => {
              if (t && h.NodeGuards.isLiteralNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if ("number" != typeof e.value) return e;
          if (h.NodeGuards.isPropertyNode(t) && !t.computed) return e;
          const r = e.value, [o, n] = N.NumberUtils.extractIntegerAndDecimalParts(r),
            i = this.numberNumericalExpressionAnalyzer.analyze(o, S.NumberNumericalExpressionAnalyzer.defaultAdditionalPartsCount);
          return n ? b.NumericalExpressionDataToNodeConverter.convertFloatNumberData(i, n, this.getNumberNumericalExpressionLiteralNode) : b.NumericalExpressionDataToNodeConverter.convertIntegerNumberData(i, this.getNumberNumericalExpressionLiteralNode)
        }

        getNumberNumericalExpressionLiteralNode(e, t) {
          const r = y.NodeFactory.literalNode(e);
          return t ? r : y.NodeFactory.unaryExpressionNode("-", r)
        }
      };
      t.NumberToNumericalExpressionTransformer = _, t.NumberToNumericalExpressionTransformer = _ = a([(0, l.injectable)(), c(0, (0, l.inject)(d.ServiceIdentifiers.INumberNumericalExpressionAnalyzer)), c(1, (0, l.inject)(d.ServiceIdentifiers.IRandomGenerator)), c(2, (0, l.inject)(d.ServiceIdentifiers.IOptions)), s("design:paramtypes", ["function" == typeof (o = void 0 !== p.INumberNumericalExpressionAnalyzer && p.INumberNumericalExpressionAnalyzer) ? o : Object, "function" == typeof (n = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== u.IOptions && u.IOptions) ? i : Object])], _)
    }, 82797: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 83779: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMJumpBuilder = void 0, t.VMJumpBuilder = class {
        constructor(e, t) {
          this.jumpIndex = t, this.context = e
        }

        patchToHere() {
          this.patchTo(this.context.instructions.length)
        }

        patchTo(e) {
          const t = this.context.instructions[this.jumpIndex];
          if (!t || !("target" in t)) throw new Error(`Invalid jump instruction at index ${this.jumpIndex}`);
          t.target = e
        }

        getIndex() {
          return this.jumpIndex
        }
      }
    }, 84011: function (e, t, r) {
      var o = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMGlobalStorageUtils = void 0;
      const n = r(45337), i = r(27391), a = r(93571), s = r(33056), c = r(47250);
      let l = class {
        wrapClassDeclarationWithGlobalStorage(e, t, r) {
          if (!e.id) return;
          if (!e.id.name || "string" != typeof e.id.name) return;
          const o = e.id.name;
          if ("undefined" === o) return;
          const n = a.NodeFactory.expressionStatementNode(a.NodeFactory.assignmentExpressionNode("=", a.NodeFactory.memberExpressionNode(a.NodeFactory.identifierNode(r), a.NodeFactory.literalNode(o), !0), a.NodeFactory.identifierNode(o)));
          s.NodeUtils.parentizeAst(n), c.NodeAppender.insertAfter(t, [n], e)
        }

        wrapFunctionDeclarationWithGlobalStorage(e, t, r) {
          if (!e.id) return;
          if (!e.id.name || "string" != typeof e.id.name) return;
          const o = e.id.name;
          if ("undefined" === o) return;
          const n = a.NodeFactory.expressionStatementNode(a.NodeFactory.assignmentExpressionNode("=", a.NodeFactory.memberExpressionNode(a.NodeFactory.identifierNode(r), a.NodeFactory.literalNode(o), !0), a.NodeFactory.identifierNode(o)));
          s.NodeUtils.parentizeAst(n), s.NodeUtils.parentizeNode(n, t);
          const i = this.findInsertIndexForGlobalStorage(t);
          t.body.splice(i, 0, n)
        }

        findInsertIndexForGlobalStorage(e) {
          return Math.min(3, e.body.length)
        }

        wrapVariableDeclarationWithGlobalStorage(e, t, r) {
          for (const o of e.declarations) if (i.NodeGuards.isIdentifierNode(o.id) && o.init) {
            const n = o.id.name;
            if (!n || "undefined" === n) continue;
            const i = a.NodeFactory.expressionStatementNode(a.NodeFactory.assignmentExpressionNode("=", a.NodeFactory.memberExpressionNode(a.NodeFactory.identifierNode(r), a.NodeFactory.literalNode(n), !0), a.NodeFactory.identifierNode(n)));
            s.NodeUtils.parentizeAst(i), c.NodeAppender.insertAfter(t, [i], e)
          }
        }

        transformTopLevelDeclarations(e, t) {
          const r = this.findVMRuntimeIndex(e), o = new Set, n = new Set;
          for (let t = r; t < e.body.length; t++) {
            const r = e.body[t];
            if (i.NodeGuards.isVariableDeclarationNode(r)) for (const e of r.declarations) i.NodeGuards.isIdentifierNode(e.id) && o.add(e.id.name); else i.NodeGuards.isFunctionDeclarationNode(r) && r.id && n.add(r.id.name)
          }
          for (const e of n) o.delete(e);
          for (let n = r; n < e.body.length; n++) {
            const r = e.body[n];
            if (!i.NodeGuards.isVariableDeclarationNode(r) || "const" !== r.kind && "let" !== r.kind) {
              if (i.NodeGuards.isExpressionStatementNode(r)) {
                const i = this.transformTopLevelAssignment(r, o, t, e);
                i && (e.body[n] = i)
              }
            } else for (const o of r.declarations) if (i.NodeGuards.isIdentifierNode(o.id) && o.init) {
              const r = this.createVMGlobalsAssignment(t, o.id.name, e);
              e.body.splice(n + 1, 0, r), n++
            }
          }
          if (o.size > 0) for (let n = r; n < e.body.length; n++) {
            const r = e.body[n];
            if (!i.NodeGuards.isFunctionDeclarationNode(r)) if (i.NodeGuards.isVariableDeclarationNode(r)) for (const e of r.declarations) e.init && this.replaceIdentifiersInExpression(e.init, o, t); else this.replaceIdentifierReadsWithVMGlobals(r, o, t)
          }
          return o
        }

        findVMRuntimeIndex(e) {
          for (let t = 0; t < e.body.length; t++) {
            const r = e.body[t];
            if (i.NodeGuards.isVariableDeclarationNode(r) && "const" === r.kind) return t + 1
          }
          return 0
        }

        createVMGlobalsAssignment(e, t, r) {
          const o = a.NodeFactory.expressionStatementNode(a.NodeFactory.assignmentExpressionNode("=", a.NodeFactory.memberExpressionNode(a.NodeFactory.identifierNode(e), a.NodeFactory.identifierNode(t)), a.NodeFactory.identifierNode(t)));
          return s.NodeUtils.parentizeAst(o), s.NodeUtils.parentizeNode(o, r), o
        }

        replaceIdentifierReadsWithVMGlobals(e, t, r) {
          if (e) if (i.NodeGuards.isExpressionStatementNode(e)) this.replaceIdentifiersInExpression(e.expression, t, r); else if (i.NodeGuards.isReturnStatementNode(e)) e.argument && this.replaceIdentifiersInExpression(e.argument, t, r); else if (i.NodeGuards.isIfStatementNode(e)) this.replaceIdentifiersInExpression(e.test, t, r), this.replaceIdentifierReadsWithVMGlobals(e.consequent, t, r), e.alternate && this.replaceIdentifierReadsWithVMGlobals(e.alternate, t, r); else if (i.NodeGuards.isBlockStatementNode(e)) for (const o of e.body) this.replaceIdentifierReadsWithVMGlobals(o, t, r); else if (i.NodeGuards.isTryStatementNode(e)) {
            const o = e;
            this.replaceIdentifierReadsWithVMGlobals(o.block, t, r), o.handler && this.replaceIdentifierReadsWithVMGlobals(o.handler.body, t, r), o.finalizer && this.replaceIdentifierReadsWithVMGlobals(o.finalizer, t, r)
          }
        }

        replaceIdentifiersInExpression(e, t, r) {
          if (e) if (i.NodeGuards.isAssignmentExpressionNode(e)) {
            if (i.NodeGuards.isIdentifierNode(e.left) && t.has(e.left.name)) {
              const t = e.left.name;
              e.left.type = "MemberExpression", e.left.object = a.NodeFactory.identifierNode(r), e.left.property = a.NodeFactory.literalNode(t), e.left.computed = !0, delete e.left.name
            }
            this.replaceIdentifiersInExpression(e.right, t, r)
          } else if (i.NodeGuards.isSequenceExpressionNode(e)) for (const o of e.expressions) this.replaceIdentifiersInExpression(o, t, r); else {
            if (i.NodeGuards.isBinaryExpressionNode(e) || i.NodeGuards.isLogicalExpressionNode(e)) {
              const o = e;
              return this.replaceIdentifiersInExpression(o.left, t, r), void this.replaceIdentifiersInExpression(o.right, t, r)
            }
            if (i.NodeGuards.isConditionalExpressionNode(e)) return this.replaceIdentifiersInExpression(e.test, t, r), this.replaceIdentifiersInExpression(e.consequent, t, r), void this.replaceIdentifiersInExpression(e.alternate, t, r);
            if (i.NodeGuards.isNewExpressionNode(e)) {
              "Super" !== e.callee.type && this.replaceIdentifiersInExpression(e.callee, t, r);
              for (const o of e.arguments) i.NodeGuards.isSpreadElementNode(o) ? this.replaceIdentifiersInExpression(o.argument, t, r) : this.replaceIdentifiersInExpression(o, t, r)
            } else if (i.NodeGuards.isCallExpressionNode(e)) {
              "Super" !== e.callee.type && this.replaceIdentifiersInExpression(e.callee, t, r);
              for (const o of e.arguments) i.NodeGuards.isSpreadElementNode(o) ? this.replaceIdentifiersInExpression(o.argument, t, r) : this.replaceIdentifiersInExpression(o, t, r)
            } else {
              if (i.NodeGuards.isMemberExpressionNode(e)) return "Super" !== e.object.type && this.replaceIdentifiersInExpression(e.object, t, r), void (e.computed && "PrivateIdentifier" !== e.property.type && this.replaceIdentifiersInExpression(e.property, t, r));
              if (i.NodeGuards.isUnaryExpressionNode(e)) this.replaceIdentifiersInExpression(e.argument, t, r); else if (!i.NodeGuards.isUpdateExpressionNode(e)) if (i.NodeGuards.isArrayExpressionNode(e)) for (const o of e.elements) o && "SpreadElement" === o.type ? this.replaceIdentifiersInExpression(o.argument, t, r) : o && this.replaceIdentifiersInExpression(o, t, r); else if (i.NodeGuards.isObjectExpressionNode(e)) for (const o of e.properties) "Property" === o.type ? (o.computed && "PrivateIdentifier" !== o.key.type && this.replaceIdentifiersInExpression(o.key, t, r), "ObjectPattern" !== o.value.type && "ArrayPattern" !== o.value.type && "RestElement" !== o.value.type && "AssignmentPattern" !== o.value.type && this.replaceIdentifiersInExpression(o.value, t, r)) : "SpreadElement" === o.type && this.replaceIdentifiersInExpression(o.argument, t, r); else if (i.NodeGuards.isTemplateLiteralNode(e)) for (const o of e.expressions) this.replaceIdentifiersInExpression(o, t, r); else if (i.NodeGuards.isIdentifierNode(e)) {
                const o = e.name;
                t.has(o) && (e.type = "MemberExpression", e.object = a.NodeFactory.identifierNode(r), e.property = a.NodeFactory.literalNode(o), e.computed = !0, delete e.name)
              }
            }
          }
        }

        transformTopLevelAssignment(e, t, r, o) {
          const n = e.expression;
          if (i.NodeGuards.isSequenceExpressionNode(n)) {
            let e = !1;
            const i = n.expressions.map(o => {
              const n = this.wrapAssignmentWithGlobalStorage(o, t, r);
              return n ? (e = !0, n) : o
            });
            if (e) {
              const e = a.NodeFactory.expressionStatementNode(a.NodeFactory.sequenceExpressionNode(i));
              return s.NodeUtils.parentizeAst(e), s.NodeUtils.parentizeNode(e, o), e
            }
            return null
          }
          const c = this.wrapAssignmentWithGlobalStorage(n, t, r);
          if (c) {
            const e = a.NodeFactory.expressionStatementNode(c);
            return s.NodeUtils.parentizeAst(e), s.NodeUtils.parentizeNode(e, o), e
          }
          return null
        }

        wrapAssignmentWithGlobalStorage(e, t, r) {
          if (!i.NodeGuards.isAssignmentExpressionNode(e)) return null;
          if (!i.NodeGuards.isIdentifierNode(e.left)) return null;
          const o = e.left.name;
          return t.has(o) ? a.NodeFactory.assignmentExpressionNode("=", a.NodeFactory.memberExpressionNode(a.NodeFactory.identifierNode(r), a.NodeFactory.literalNode(o), !0), e) : null
        }
      };
      t.VMGlobalStorageUtils = l, t.VMGlobalStorageUtils = l = o([(0, n.injectable)()], l)
    }, 84072: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MemberExpressionTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(75716), f = r(13245), m = r(93571),
        g = r(27391), h = r(4592);
      let y = class extends f.AbstractNodeTransformer {
        constructor(e, t) {
          super(e, t)
        }

        getVisitor(e) {
          return e === u.NodeTransformationStage.Converting ? {
            enter: (e, t) => {
              if (t && g.NodeGuards.isMemberExpressionNode(e)) return this.transformNode(e, t)
            }
          } : null
        }

        transformNode(e, t) {
          if (h.NodeMetadata.isIgnoredNode(e.object) || h.NodeMetadata.isIgnoredNode(e.property)) return e;
          if (g.NodeGuards.isIdentifierNode(e.property)) {
            if (e.computed) return e;
            e.computed = !0, e.property = m.NodeFactory.literalNode(e.property.name)
          }
          return e
        }
      };
      t.MemberExpressionTransformer = y, t.MemberExpressionTransformer = y = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], y)
    }, 84133: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMBytecodeFormat = void 0;
      const o = r(39079);
      t.VMBytecodeFormat = o.Utils.makeEnum({ Json: "json", Binary: "binary" })
    }, 84640: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MEDIUM_OBFUSCATION_PRESET = void 0;
      const o = r(82038), n = r(20965), i = r(48344), a = r(32121);
      t.MEDIUM_OBFUSCATION_PRESET = Object.freeze({
        ...a.LOW_OBFUSCATION_PRESET,
        controlFlowFlattening: !0,
        deadCodeInjection: !0,
        numbersToExpressions: !0,
        optionsPreset: o.OptionsPreset.MediumObfuscation,
        splitStrings: !0,
        splitStringsChunkLength: 10,
        stringArrayCallsTransformThreshold: .75,
        stringArrayEncoding: [n.StringArrayEncoding.Base64],
        stringArrayWrappersCount: 2,
        stringArrayWrappersParametersMaxCount: 4,
        stringArrayWrappersType: i.StringArrayWrappersType.Function,
        transformObjectKeys: !0
      })
    }, 84885: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 85183: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LoggingPrefix = void 0, function (e) {
        e.Base = "[javascript-obfuscator]", e.CLI = "[javascript-obfuscator-cli]"
      }(r || (t.LoggingPrefix = r = {}))
    }, 85406: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCallsWrapperTemplate = function () {
        return "\n        function {stringArrayCallsWrapperName} (index, key) {\n            index = index - {indexShiftAmount};\n\n            const stringArray = {stringArrayFunctionName}();\n            let value = stringArray[index];\n                \n            {decodeCodeHelperTemplate}\n\n            return value;\n        }\n    "
      }
    }, 85418: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.HashbangOperatorTransformer = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(14932), f = r(27757);
      let m = class extends f.AbstractCodeTransformer {
        constructor(e, t) {
          super(e, t), this.hashbangOperatorLine = null
        }

        transformCode(e, t) {
          switch (t) {
            case u.CodeTransformationStage.PreparingTransformers:
              return this.removeAndSaveHashbangOperatorLine(e);
            case u.CodeTransformationStage.FinalizingTransformers:
              return this.appendSavedHashbangOperatorLine(e);
            default:
              return e
          }
        }

        removeAndSaveHashbangOperatorLine(e) {
          return e.replace(/^#!.*$(\r?\n)*/m, e => (e && (this.hashbangOperatorLine = e), "")).trim()
        }

        appendSavedHashbangOperatorLine(e) {
          var t;
          return `${null !== (t = this.hashbangOperatorLine) && void 0 !== t ? t : ""}${e}`
        }
      };
      t.HashbangOperatorTransformer = m, t.HashbangOperatorTransformer = m = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], m)
    }, 85498: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 85869: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.initializingTransformersModule = void 0;
      const o = r(45337), n = r(31391), i = r(92486), a = r(13014);
      t.initializingTransformersModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.INodeTransformer).to(a.CommentsTransformer).whenTargetNamed(i.NodeTransformer.CommentsTransformer)
      })
    }, 86004: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.IsInputFileName = void 0;
      const o = r(97403), n = r(57088);
      t.IsInputFileName = () => (e, t) => {
        (0, o.IsString)()(e, t), (0, o.ValidateIf)(({ sourceMapSourcesMode: e }) => e === n.SourceMapSourcesMode.Sources)(e, t), (0, o.IsNotEmpty)()(e, t)
      }
    }, 86173: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 86249: function (e, t, r) {
      var o, n, i = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), a = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && i(t, e, r[n]);
        return a(t, e), t
      });
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionCalleeDataExtractor = void 0;
      const l = r(45337), d = c(r(31659)), p = r(75476), u = r(27391), f = r(43243);
      let m = n = class extends p.AbstractCalleeDataExtractor {
        static isValidTargetPropertyNode(e, t) {
          if (!e.key) return !1;
          const r = u.NodeGuards.isIdentifierNode(e.key) && e.key.name === t,
            o = u.NodeGuards.isLiteralNode(e.key) && Boolean(e.key.value) && e.key.value === t;
          return r || o
        }

        extract(e, t) {
          if (!u.NodeGuards.isMemberExpressionNode(t)) return null;
          const r = this.createObjectMembersCallsChain([], t);
          if (!r.length) return null;
          const o = r[r.length - 1],
            n = this.getCalleeBlockStatement(f.NodeStatementUtils.getParentNodeWithStatements(e[0]), r);
          return n ? { callee: n, name: o } : null
        }

        createObjectMembersCallsChain(e, t) {
          if (u.NodeGuards.isIdentifierNode(t.property) && !t.computed) e.unshift(t.property.name); else {
            if (!u.NodeGuards.isLiteralNode(t.property) || "string" != typeof t.property.value && "number" != typeof t.property.value) return e;
            e.unshift(t.property.value)
          }
          return u.NodeGuards.isMemberExpressionNode(t.object) ? this.createObjectMembersCallsChain(e, t.object) : (u.NodeGuards.isIdentifierNode(t.object) && e.unshift(t.object.name), e)
        }

        getCalleeBlockStatement(e, t) {
          const r = t.shift();
          if (!r) return null;
          let o = null;
          return d.traverse(e, {
            enter: e => {
              if (u.NodeGuards.isVariableDeclaratorNode(e) && u.NodeGuards.isIdentifierNode(e.id) && e.init && u.NodeGuards.isObjectExpressionNode(e.init) && e.id.name === r) return o = this.findCalleeBlockStatement(e.init.properties, t), d.VisitorOption.Break
            }
          }), o
        }

        findCalleeBlockStatement(e, t) {
          const r = t.shift();
          if (!r) return null;
          for (const o of e) if (u.NodeGuards.isPropertyNode(o) && n.isValidTargetPropertyNode(o, r)) {
            if (u.NodeGuards.isObjectExpressionNode(o.value)) return this.findCalleeBlockStatement(o.value.properties, t);
            if (u.NodeGuards.isFunctionExpressionNode(o.value)) return o.value.body
          }
          return null
        }
      };
      t.ObjectExpressionCalleeDataExtractor = m, t.ObjectExpressionCalleeDataExtractor = m = n = s([(0, l.injectable)()], m)
    }, 86552: function (e, t, r) {
      var o, n, i, a, s, c, l, d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, u = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayCodeHelperGroup = void 0;
      const f = r(45337), m = r(31391), g = r(58544), h = r(18741), y = r(76393), S = r(31142), N = r(28523),
        b = r(50164), _ = r(51875), v = r(20965), I = r(26455), O = r(47250);
      let C = o = class extends I.AbstractCustomCodeHelperGroup {
        constructor(e, t, r, o, n) {
          super(r, o, n), this.customCodeHelperFactory = e, this.stringArrayStorage = t
        }

        appendOnFinalizingStage(e, t) {
          if (!this.stringArrayStorage.getLength()) return;
          const r = O.NodeAppender.getScopeStatements(e);
          this.appendCustomNodeIfExist(_.CustomCodeHelper.StringArray, t => {
            O.NodeAppender.insertAtIndex(e, t.getNode(), this.getScopeStatementRandomIndex(r))
          });
          for (const t of this.options.stringArrayEncoding) {
            const o = this.getStringArrayCallsWrapperCodeHelperName(t);
            this.appendCustomNodeIfExist(o, t => {
              O.NodeAppender.insertAtIndex(e, t.getNode(), this.getScopeStatementRandomIndex(r))
            })
          }
        }

        initialize() {
          if (this.customCodeHelpers = new Map, !this.options.stringArray) return;
          const e = this.stringArrayStorage.getStorageName(),
            t = this.customCodeHelperFactory(_.CustomCodeHelper.StringArray);
          t.initialize(this.stringArrayStorage, e), this.customCodeHelpers.set(_.CustomCodeHelper.StringArray, t);
          for (const t of this.options.stringArrayEncoding) {
            const r = this.getStringArrayCallsWrapperCodeHelperName(t), o = this.customCodeHelperFactory(r),
              n = this.stringArrayStorage.getStorageCallsWrapperName(t);
            o.initialize(e, n, this.stringArrayStorage.getIndexShiftAmount()), this.customCodeHelpers.set(r, o)
          }
        }

        getStringArrayCallsWrapperCodeHelperName(e) {
          var t;
          return null !== (t = o.stringArrayCallsWrapperCodeHelperMap.get(e)) && void 0 !== t ? t : _.CustomCodeHelper.StringArrayCallsWrapper
        }

        getScopeStatementRandomIndex(e) {
          return this.randomGenerator.getRandomInteger(0, Math.max(0, e.length))
        }
      };
      t.StringArrayCodeHelperGroup = C, C.stringArrayCallsWrapperCodeHelperMap = new Map([[v.StringArrayEncoding.None, _.CustomCodeHelper.StringArrayCallsWrapper], [v.StringArrayEncoding.Base64, _.CustomCodeHelper.StringArrayCallsWrapperBase64], [v.StringArrayEncoding.Rc4, _.CustomCodeHelper.StringArrayCallsWrapperRc4]]), d([(0, b.initializable)(), p("design:type", "function" == typeof (l = "undefined" != typeof Map && Map) ? l : Object)], C.prototype, "customCodeHelpers", void 0), t.StringArrayCodeHelperGroup = C = o = d([(0, f.injectable)(), u(0, (0, f.inject)(m.ServiceIdentifiers.Factory__ICustomCodeHelper)), u(1, (0, f.inject)(m.ServiceIdentifiers.IStringArrayStorage)), u(2, (0, f.inject)(m.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), u(3, (0, f.inject)(m.ServiceIdentifiers.IRandomGenerator)), u(4, (0, f.inject)(m.ServiceIdentifiers.IOptions)), p("design:paramtypes", ["function" == typeof (n = void 0 !== g.TCustomCodeHelperFactory && g.TCustomCodeHelperFactory) ? n : Object, "function" == typeof (i = void 0 !== N.IStringArrayStorage && N.IStringArrayStorage) ? i : Object, "function" == typeof (a = void 0 !== h.TIdentifierNamesGeneratorFactory && h.TIdentifierNamesGeneratorFactory) ? a : Object, "function" == typeof (s = void 0 !== S.IRandomGenerator && S.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== y.IOptions && y.IOptions) ? c : Object])], C)
    }, 87575: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 87652: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractTransformerNamesGroupsBuilder = void 0;
      const s = r(45337), c = r(31391), l = r(49991);
      let d = class {
        constructor(e) {
          this.levelledTopologicalSorter = e
        }

        build(e) {
          const t = Object.keys(e), r = this.buildTransformersRelationEdges(t, e);
          for (const [e, t] of r) this.levelledTopologicalSorter.add(e, t);
          return this.levelledTopologicalSorter.sortByGroups()
        }

        buildTransformersRelationEdges(e, t) {
          const r = [];
          for (const o of e) {
            const e = t[o].runAfter;
            if (null == e ? void 0 : e.length) for (const n of e) void 0 === t[n] ? r.push([o, null]) : r.push([n, o]); else r.push([o, null])
          }
          return r
        }
      };
      t.AbstractTransformerNamesGroupsBuilder = d, t.AbstractTransformerNamesGroupsBuilder = d = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.ILevelledTopologicalSorter)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.ILevelledTopologicalSorter && l.ILevelledTopologicalSorter) ? o : Object])], d)
    }, 87906: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayEncodingRule = void 0;
      const o = r(20965);
      t.StringArrayEncodingRule = e => (e.stringArrayEncoding.length || (e = {
        ...e,
        stringArrayEncoding: [o.StringArrayEncoding.None]
      }), e)
    }, 87972: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getStackOpcodeTemplates = function () {
        return "\n                        // Stack Operations\n                        case opMap[0]: { // PUSH_CONST\n                            stack.push(constants[arg]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[1]: { // PUSH_UNDEFINED\n                            stack.push(undefined);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[2]: { // PUSH_NULL\n                            stack.push(null);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[3]: { // POP\n                            stack.pop();\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[4]: { // DUP\n                            // Pop (decodes if stack encoding enabled), then push twice (encodes each)\n                            // This ensures proper encoding behavior when vmStackEncoding is active\n                            let dupVal = stack.pop();\n                            stack.push(dupVal);\n                            stack.push(dupVal);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[5]: { // SWAP\n                            let stackLen = stack.length;\n                            let tmp = stack[stackLen - 1];\n                            stack[stackLen - 1] = stack[stackLen - 2];\n                            stack[stackLen - 2] = tmp;\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[6]: { // LOAD_LOCAL\n                            stack.push(locals[arg]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[7]: { // STORE_LOCAL\n                            locals[arg] = stack.pop();\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[8]: { // LOAD_ARG\n                            stack.push(args[arg]);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[9]: { // STORE_ARG\n                            args[arg] = stack.pop();\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 88320: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 88527: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMVariableCollector = void 0;
      const s = r(45337), c = r(20924), l = r(31391), d = r(27391);
      let p = class {
        constructor(e) {
          this.vmCompilerUtils = e
        }

        collectParameterNames(e) {
          const t = new Set;
          if (e.params) for (const r of e.params) d.NodeGuards.isIdentifierNode(r) ? t.add(r.name) : d.NodeGuards.isAssignmentPatternNode(r) ? d.NodeGuards.isIdentifierNode(r.left) && t.add(r.left.name) : d.NodeGuards.isRestElementNode(r) && d.NodeGuards.isIdentifierNode(r.argument) && t.add(r.argument.name);
          return t
        }

        collectAllParameterNames(e) {
          const t = new Set;
          for (const r of e.params) this.collectNamesFromPattern(r, t);
          return t
        }

        collectDeclaredVariables(e) {
          const t = new Set;
          return this.vmCompilerUtils.traverseStatements(e, e => {
            if (d.NodeGuards.isVariableDeclarationNode(e)) for (const r of e.declarations) this.collectFromDeclarator(r, t); else if (d.NodeGuards.isFunctionDeclarationNode(e) && e.id) t.add(e.id.name); else if (d.NodeGuards.isClassDeclarationNode(e) && e.id) t.add(e.id.name); else if ((d.NodeGuards.isForOfStatementNode(e) || d.NodeGuards.isForInStatementNode(e)) && d.NodeGuards.isVariableDeclarationNode(e.left)) for (const r of e.left.declarations) this.collectFromDeclarator(r, t)
          }), t
        }

        scanForLexicalDeclarations(e) {
          const t = new Set;
          for (const r of e) if (d.NodeGuards.isVariableDeclarationNode(r) && ("let" === r.kind || "const" === r.kind)) for (const e of r.declarations) this.collectFromDeclarator(e, t);
          return t
        }

        collectFunctionLevelDeclaredVariables(e) {
          const t = new Set;
          for (const r of e) if (d.NodeGuards.isVariableDeclarationNode(r)) for (const e of r.declarations) this.collectFromDeclarator(e, t); else (d.NodeGuards.isFunctionDeclarationNode(r) && r.id || d.NodeGuards.isClassDeclarationNode(r) && r.id) && t.add(r.id.name);
          return t
        }

        collectFromPattern(e, t) {
          d.NodeGuards.isIdentifierNode(e) ? t.add(e.name) : d.NodeGuards.isArrayPatternNode(e) ? this.collectFromArrayPattern(e, t) : d.NodeGuards.isObjectPatternNode(e) ? this.collectFromObjectPattern(e, t) : d.NodeGuards.isAssignmentPatternNode(e) ? this.collectFromPattern(e.left, t) : d.NodeGuards.isRestElementNode(e) && this.collectFromPattern(e.argument, t)
        }

        collectFromArrayPattern(e, t) {
          for (const r of e.elements) r && (d.NodeGuards.isRestElementNode(r) ? this.collectFromPattern(r.argument, t) : this.collectFromPattern(r, t))
        }

        collectFromObjectPattern(e, t) {
          for (const r of e.properties) d.NodeGuards.isRestElementNode(r) ? this.collectFromPattern(r.argument, t) : d.NodeGuards.isPropertyNode(r) && this.collectFromPattern(r.value, t)
        }

        collectFromDeclarator(e, t) {
          d.NodeGuards.isIdentifierNode(e.id) ? t.add(e.id.name) : (d.NodeGuards.isArrayPatternNode(e.id) || d.NodeGuards.isObjectPatternNode(e.id)) && this.collectFromPattern(e.id, t)
        }

        collectNamesFromPattern(e, t) {
          this.collectFromPattern(e, t)
        }
      };
      t.VMVariableCollector = p, t.VMVariableCollector = p = n([(0, s.injectable)(), a(0, (0, s.inject)(l.ServiceIdentifiers.IVMCompilerUtils)), i("design:paramtypes", ["function" == typeof (o = void 0 !== c.IVMCompilerUtils && c.IVMCompilerUtils) ? o : Object])], p)
    }, 88711: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.controlFlowTransformersModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(80935), s = r(92486), c = r(51069), l = r(36656),
        d = r(6518), p = r(73534), u = r(30283), f = r(55066), m = r(68418), g = r(42748);
      t.controlFlowTransformersModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.INodeTransformer).to(l.BlockStatementControlFlowTransformer).whenTargetNamed(s.NodeTransformer.BlockStatementControlFlowTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(p.FunctionControlFlowTransformer).whenTargetNamed(s.NodeTransformer.FunctionControlFlowTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(m.StringArrayControlFlowTransformer).whenTargetNamed(s.NodeTransformer.StringArrayControlFlowTransformer), e(i.ServiceIdentifiers.IControlFlowReplacer).to(c.BinaryExpressionControlFlowReplacer).whenTargetNamed(a.ControlFlowReplacer.BinaryExpressionControlFlowReplacer), e(i.ServiceIdentifiers.IControlFlowReplacer).to(d.CallExpressionControlFlowReplacer).whenTargetNamed(a.ControlFlowReplacer.CallExpressionControlFlowReplacer), e(i.ServiceIdentifiers.IControlFlowReplacer).to(u.LogicalExpressionControlFlowReplacer).whenTargetNamed(a.ControlFlowReplacer.LogicalExpressionControlFlowReplacer), e(i.ServiceIdentifiers.IControlFlowReplacer).to(f.StringArrayCallControlFlowReplacer).whenTargetNamed(a.ControlFlowReplacer.StringArrayCallControlFlowReplacer), e(i.ServiceIdentifiers.IControlFlowReplacer).to(g.StringLiteralControlFlowReplacer).whenTargetNamed(a.ControlFlowReplacer.StringLiteralControlFlowReplacer), e(i.ServiceIdentifiers.Factory__IControlFlowReplacer).toFactory(o.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.IControlFlowReplacer))
      })
    }, 88847: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 89438: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), l = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), d = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, p = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && c(t, e, r[n]);
        return l(t, e), t
      }), u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ScopeIdentifiersTransformer = void 0;
      const m = r(45337), g = r(31391), h = p(r(31659)), y = r(51353), S = r(76393), N = r(31142), b = r(57809),
        _ = r(75716), v = r(13245), I = r(27391), O = r(4592);
      let C = class extends v.AbstractNodeTransformer {
        constructor(e, t, r, o) {
          super(t, r), this.lexicalScopesWithObjectPatternWithoutDeclarationMap = new WeakMap, this.identifierReplacer = e, this.scopeIdentifiersTraverser = o
        }

        getVisitor(e) {
          switch (e) {
            case _.NodeTransformationStage.Preparing:
            case _.NodeTransformationStage.RenameIdentifiers:
              return {
                enter: (e, t) => {
                  if (t && I.NodeGuards.isProgramNode(e)) return this.transformNode(e, t)
                }
              };
            default:
              return null
          }
        }

        transformNode(e, t) {
          return this.scopeIdentifiersTraverser.traverseScopeIdentifiers(e, t, e => {
            const { isGlobalDeclaration: t, variable: r, variableLexicalScopeNode: o } = e;
            (this.options.renameGlobals || !t || r.defs.every(e => "ImportBinding" === e.type || "CatchClause" === e.type)) && this.transformScopeVariableIdentifiers(r, o, t)
          }), e
        }

        transformScopeVariableIdentifiers(e, t, r) {
          var o;
          const n = null !== (o = e.identifiers[0]) && void 0 !== o ? o : null;
          n && this.isReplaceableIdentifierNode(n, t, e) && (this.storeIdentifierName(n, t, r), this.replaceIdentifierName(n, t, e))
        }

        storeIdentifierName(e, t, r) {
          r ? this.identifierReplacer.storeGlobalName(e, t) : this.identifierReplacer.storeLocalName(e, t)
        }

        replaceIdentifierName(e, t, r) {
          const o = this.identifierReplacer.replace(e, t);
          r.identifiers.forEach(e => {
            e.name = o.name
          }), r.references.forEach(e => {
            e.identifier.name = o.name
          })
        }

        isReplaceableIdentifierNode(e, t, r) {
          const o = e.parentNode;
          return !(!o || O.NodeMetadata.isIgnoredNode(e) || this.isProhibitedPropertyIdentifierNode(e, o) || this.isProhibitedPropertyAssignmentPatternIdentifierNode(e, o) || this.isProhibitedClassDeclarationNameIdentifierNode(r, e, o) || this.isProhibitedExportNamedClassDeclarationIdentifierNode(e, o) || this.isProhibitedExportNamedFunctionDeclarationIdentifierNode(e, o) || this.isProhibitedExportNamedVariableDeclarationIdentifierNode(e, o) || this.isProhibitedImportSpecifierNode(e, o) || this.isProhibitedVariableNameUsedInObjectPatternNode(r, e, t) || I.NodeGuards.isLabelIdentifierNode(e, o))
        }

        isProhibitedClassDeclarationNameIdentifierNode(e, t, r) {
          return I.NodeGuards.isClassDeclarationNode(e.scope.block) && I.NodeGuards.isClassDeclarationNode(r) && r.id === t
        }

        isProhibitedExportNamedClassDeclarationIdentifierNode(e, t) {
          return I.NodeGuards.isClassDeclarationNode(t) && t.id === e && !!t.parentNode && I.NodeGuards.isExportNamedDeclarationNode(t.parentNode)
        }

        isProhibitedExportNamedFunctionDeclarationIdentifierNode(e, t) {
          return I.NodeGuards.isFunctionDeclarationNode(t) && t.id === e && !!t.parentNode && I.NodeGuards.isExportNamedDeclarationNode(t.parentNode)
        }

        isProhibitedExportNamedVariableDeclarationIdentifierNode(e, t) {
          return I.NodeGuards.isVariableDeclaratorNode(t) && t.id === e && !!t.parentNode && I.NodeGuards.isVariableDeclarationNode(t.parentNode) && !!t.parentNode.parentNode && I.NodeGuards.isExportNamedDeclarationNode(t.parentNode.parentNode)
        }

        isProhibitedImportSpecifierNode(e, t) {
          return I.NodeGuards.isImportSpecifierNode(t) && t.imported.name === t.local.name
        }

        isProhibitedPropertyIdentifierNode(e, t) {
          return I.NodeGuards.isPropertyNode(t) && !t.computed && I.NodeGuards.isIdentifierNode(t.key) && I.NodeGuards.isIdentifierNode(e) && t.shorthand && t.key.name === e.name
        }

        isProhibitedPropertyAssignmentPatternIdentifierNode(e, t) {
          return I.NodeGuards.isAssignmentPatternNode(t) && t.left === e && !!t.parentNode && I.NodeGuards.isPropertyNode(t.parentNode) && I.NodeGuards.isIdentifierNode(t.left) && I.NodeGuards.isIdentifierNode(t.parentNode.key) && t.left.name === t.parentNode.key.name
        }

        isProhibitedVariableNameUsedInObjectPatternNode(e, t, r) {
          let o = this.lexicalScopesWithObjectPatternWithoutDeclarationMap.get(r);
          if (!1 === o) return !1;
          if (!e.defs.some(e => "var" === e.kind)) return !1;
          let n = !1;
          return h.traverse(r, {
            enter: (e, r) => {
              if (I.NodeGuards.isObjectPatternNode(e) && r && I.NodeGuards.isAssignmentExpressionNode(r)) {
                o = !0;
                const r = e.properties;
                for (const e of r) if (n = I.NodeGuards.isPropertyNode(e) && !e.computed && e.shorthand && I.NodeGuards.isIdentifierNode(e.key) && t.name === e.key.name, n) return h.VisitorOption.Break
              }
            }
          }), this.lexicalScopesWithObjectPatternWithoutDeclarationMap.set(r, null != o && o), n
        }
      };
      t.ScopeIdentifiersTransformer = C, t.ScopeIdentifiersTransformer = C = d([(0, m.injectable)(), f(0, (0, m.inject)(g.ServiceIdentifiers.IIdentifierReplacer)), f(1, (0, m.inject)(g.ServiceIdentifiers.IRandomGenerator)), f(2, (0, m.inject)(g.ServiceIdentifiers.IOptions)), f(3, (0, m.inject)(g.ServiceIdentifiers.IScopeIdentifiersTraverser)), u("design:paramtypes", ["function" == typeof (n = void 0 !== y.IIdentifierReplacer && y.IIdentifierReplacer) ? n : Object, "function" == typeof (i = void 0 !== N.IRandomGenerator && N.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== S.IOptions && S.IOptions) ? a : Object, "function" == typeof (s = void 0 !== b.IScopeIdentifiersTraverser && b.IScopeIdentifiersTraverser) ? s : Object])], C)
    }, 89467: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.storagesModule = void 0;
      const o = r(45337), n = r(31391), i = r(16868), a = r(16737), s = r(8041), c = r(26046), l = r(31081),
        d = r(29992), p = r(94554), u = r(31352), f = r(45045), m = r(8492);
      t.storagesModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.TCustomNodeGroupStorage).to(a.CustomCodeHelperGroupStorage).inSingletonScope(), e(n.ServiceIdentifiers.IControlFlowStorage).to(s.FunctionControlFlowStorage).whenTargetNamed(i.ControlFlowStorage.FunctionControlFlowStorage), e(n.ServiceIdentifiers.IGlobalIdentifierNamesCacheStorage).to(c.GlobalIdentifierNamesCacheStorage).inSingletonScope(), e(n.ServiceIdentifiers.ILiteralNodesCacheStorage).to(l.LiteralNodesCacheStorage).inSingletonScope(), e(n.ServiceIdentifiers.IPropertyIdentifierNamesCacheStorage).to(d.PropertyIdentifierNamesCacheStorage).inSingletonScope(), e(n.ServiceIdentifiers.IStringArrayStorage).to(f.StringArrayStorage).inSingletonScope(), e(n.ServiceIdentifiers.IStringArrayScopeCallsWrappersDataStorage).to(p.StringArrayScopeCallsWrappersDataStorage).inSingletonScope(), e(n.ServiceIdentifiers.IControlFlowStorage).to(u.StringControlFlowStorage).whenTargetNamed(i.ControlFlowStorage.StringControlFlowStorage), e(n.ServiceIdentifiers.IVisitedLexicalScopeNodesStackStorage).to(m.VisitedLexicalScopeNodesStackStorage).inSingletonScope(), e(n.ServiceIdentifiers.Factory__TControlFlowStorage).toFactory(e => t => () => e.container.getNamed(n.ServiceIdentifiers.IControlFlowStorage, t))
      })
    }, 89492: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMMemberAccessCompiler = void 0;
      const a = r(45337), s = r(20924), c = r(31391), l = r(25115), d = r(27391);
      let p = class {
        compileMemberExpression(e, t) {
          var r, o, n;
          const i = this.vmCompilerUtils.createInstructionBuilder(t);
          if (d.NodeGuards.isSuperNode(e.object)) return i.this(), e.computed ? null === (r = t.dispatch) || void 0 === r || r.expression(e.property) : d.NodeGuards.isIdentifierNode(e.property) && i.loadConst(e.property.name), void i.emitRaw({
            op: l.VMOpCode.GET_SUPER_PROP,
            arg: 0
          });
          if (null === (o = t.dispatch) || void 0 === o || o.expression(e.object), e.computed) null === (n = t.dispatch) || void 0 === n || n.expression(e.property), e.optional ? i.getComputedOptional() : i.getComputed(); else if (d.NodeGuards.isIdentifierNode(e.property)) {
            const r = t.constantPool.add(e.property.name),
              o = e.optional ? l.VMOpCode.GET_OPTIONAL : l.VMOpCode.GET_PROP;
            i.emitRaw({ op: o, arg: r })
          }
        }
      };
      t.VMMemberAccessCompiler = p, n([(0, a.inject)(c.ServiceIdentifiers.IVMCompilerUtils), i("design:type", "function" == typeof (o = void 0 !== s.IVMCompilerUtils && s.IVMCompilerUtils) ? o : Object)], p.prototype, "vmCompilerUtils", void 0), t.VMMemberAccessCompiler = p = n([(0, a.injectable)()], p)
    }, 90211: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 90388: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObjectExpressionToVariableDeclarationExtractor = void 0;
      const s = r(45337), c = r(31391), l = r(50523), d = r(55054), p = r(47250), u = r(27391), f = r(43243),
        m = r(33056), g = r(75096);
      let h = class {
        constructor(e) {
          this.objectExpressionKeysTransformerCustomNodeFactory = e
        }

        extract(e, t) {
          return this.transformObjectExpressionToVariableDeclaration(e, t)
        }

        transformObjectExpressionToVariableDeclaration(e, t) {
          var r;
          const o = f.NodeStatementUtils.getScopeOfNode(t),
            n = u.NodeGuards.isNodeWithLexicalScope(o) ? o : null !== (r = g.NodeLexicalScopeUtils.getLexicalScope(o)) && void 0 !== r ? r : null;
          if (!n) throw new Error("Cannot find lexical scope node for the host statement node");
          const i = e.properties, a = this.getObjectExpressionHostNode(n, i), s = [a];
          return p.NodeAppender.insertBefore(o, s, t), m.NodeUtils.parentizeAst(a), m.NodeUtils.parentizeNode(a, o), {
            nodeToReplace: this.getObjectExpressionIdentifierNode(a),
            objectExpressionHostStatement: a,
            objectExpressionNode: this.getObjectExpressionNode(a)
          }
        }

        getObjectExpressionHostNode(e, t) {
          const r = this.objectExpressionKeysTransformerCustomNodeFactory(d.ObjectExpressionKeysTransformerCustomNode.ObjectExpressionVariableDeclarationHostNode);
          r.initialize(e, t);
          const o = r.getNode()[0];
          if (!o || !u.NodeGuards.isVariableDeclarationNode(o)) throw new Error("`objectExpressionHostCustomNode.getNode()[0]` should returns array with `VariableDeclaration` node");
          return o
        }

        getObjectExpressionIdentifierNode(e) {
          const t = e.declarations[0].id;
          if (!u.NodeGuards.isIdentifierNode(t)) throw new Error("`objectExpressionHostNode` should contain `VariableDeclarator` node with `Identifier` id property");
          return t
        }

        getObjectExpressionNode(e) {
          var t;
          const r = null !== (t = e.declarations[0].init) && void 0 !== t ? t : null;
          if (!r || !u.NodeGuards.isObjectExpressionNode(r)) throw new Error("`objectExpressionHostNode` should contain `VariableDeclarator` node with `ObjectExpression` init property");
          return r
        }
      };
      t.ObjectExpressionToVariableDeclarationExtractor = h, t.ObjectExpressionToVariableDeclarationExtractor = h = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.Factory__IObjectExpressionKeysTransformerCustomNode)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.TObjectExpressionKeysTransformerCustomNodeFactory && l.TObjectExpressionKeysTransformerCustomNodeFactory) ? o : Object])], h)
    }, 90979: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getComparisonOpcodeTemplates = function () {
        return "\n                        // Logical Operations\n                        case opMap[32]: // LOGICAL_NOT\n                            stack.push(!stack.pop());\n                            pc++;\n                            break;\n\n                        // Comparison Operations\n                        case opMap[40]: { // EQ\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a == b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[41]: { // NEQ\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a != b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[42]: { // STRICT_EQ\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a === b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[43]: { // STRICT_NEQ\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a !== b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[44]: { // LT\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a < b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[45]: { // LTE\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a <= b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[46]: { // GT\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a > b);\n                            pc++;\n                            break;\n                        }\n\n                        case opMap[47]: { // GTE\n                            let b = stack.pop();\n                            let a = stack.pop();\n                            stack.push(a >= b);\n                            pc++;\n                            break;\n                        }\n    "
      }
    }, 91015: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 91098: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMExceptionCompiler = void 0;
      const c = r(45337), l = r(20924), d = r(94487), p = r(31391), u = r(27391), f = r(79148);
      let m = class {
        compileThrowStatement(e, t) {
          var r;
          const o = this.vmCompilerUtils.createInstructionBuilder(t);
          null === (r = t.dispatch) || void 0 === r || r.expression(e.argument), o.throw()
        }

        compileTryStatement(e, t) {
          var r, o, n;
          const i = this.vmCompilerUtils.createInstructionBuilder(t), a = t.instructions.length;
          i.tryStart(void 0, void 0, 0), null === (r = t.dispatch) || void 0 === r || r.statement(e.block), i.tryEnd();
          const s = i.jump();
          let c, l, d, p = null;
          if (e.handler) {
            c = t.instructions.length;
            const r = [];
            if (e.handler.param) if (u.NodeGuards.isIdentifierNode(e.handler.param)) {
              const o = e.handler.param.name;
              this.vmCompilerUtils.isDeclaredInParentScope(o, t) && (p = this.scopeManager.enterEnv(t, i)), t.envVars.has(o) || r.push(o), t.envVars.add(o);
              const n = t.constantPool.add(o);
              i.catchStart(n)
            } else if (u.NodeGuards.isObjectPatternNode(e.handler.param) || u.NodeGuards.isArrayPatternNode(e.handler.param)) {
              const o = this.vmCompilerUtils.extractIdentifiersFromPattern(e.handler.param);
              let n = !1;
              for (const e of o) if (this.vmCompilerUtils.isDeclaredInParentScope(e, t)) {
                n = !0;
                break
              }
              n && (p = this.scopeManager.enterEnv(t, i));
              const a = `__exception_${t.instructions.length}`;
              t.envVars.add(a);
              const s = t.constantPool.add(a);
              i.catchStart(s), this.vmCompilerUtils.emitLoadVariable(a, t);
              for (const e of o) t.envVars.has(e) || r.push(e), t.envVars.add(e);
              const c = t._declarationKind;
              t._declarationKind = "const", this.destructuringCompiler.compileDestructuringPattern(e.handler.param, t, !0), t._declarationKind = c
            } else i.catchStart(-1); else i.catchStart(-1);
            if (null === (o = t.dispatch) || void 0 === o || o.statement(e.handler.body), p) {
              this.scopeManager.exitEnv(t, i, p);
              for (const e of r) t.envVars.delete(e)
            }
            l = i.jump()
          }
          e.finalizer ? (s.patchToHere(), void 0 !== l && l.patchToHere(), d = t.instructions.length, i.finallyStart(), null === (n = t.dispatch) || void 0 === n || n.statement(e.finalizer), i.finallyEnd()) : (s.patchToHere(), void 0 !== l && l.patchToHere());
          const f = t.instructions.length, m = t.instructions[a];
          m.catchIndex = c, m.finallyIndex = d, m.endIndex = f
        }
      };
      t.VMExceptionCompiler = m, a([(0, c.inject)(p.ServiceIdentifiers.IVMCompilerUtils), s("design:type", "function" == typeof (o = void 0 !== l.IVMCompilerUtils && l.IVMCompilerUtils) ? o : Object)], m.prototype, "vmCompilerUtils", void 0), a([(0, c.inject)(p.ServiceIdentifiers.IVMScopeManager), s("design:type", "function" == typeof (n = void 0 !== d.IVMScopeManager && d.IVMScopeManager) ? n : Object)], m.prototype, "scopeManager", void 0), a([(0, c.inject)(p.ServiceIdentifiers.IVMDestructuringBytecodeCompiler), s("design:type", "function" == typeof (i = void 0 !== f.VMDestructuringBytecodeCompiler && f.VMDestructuringBytecodeCompiler) ? i : Object)], m.prototype, "destructuringCompiler", void 0), t.VMExceptionCompiler = m = a([(0, c.injectable)()], m)
    }, 92037: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.LogicalExpressionFunctionNode = void 0;
      const d = r(45337), p = r(31391), u = r(18741), f = r(39032), m = r(76393), g = r(31142), h = r(8053),
        y = r(93571), S = r(33056);
      let N = class extends h.AbstractCustomNode {
        constructor(e, t, r, o) {
          super(e, t, r, o)
        }

        initialize(e) {
          this.operator = e
        }

        getNodeStructure() {
          const e = y.NodeFactory.expressionStatementNode(y.NodeFactory.functionExpressionNode([y.NodeFactory.identifierNode("x"), y.NodeFactory.identifierNode("y")], y.NodeFactory.blockStatementNode([y.NodeFactory.returnStatementNode(y.NodeFactory.logicalExpressionNode(this.operator, y.NodeFactory.identifierNode("x"), y.NodeFactory.identifierNode("y")))])));
          return S.NodeUtils.parentizeAst(e), [e]
        }
      };
      t.LogicalExpressionFunctionNode = N, t.LogicalExpressionFunctionNode = N = s([(0, d.injectable)(), l(0, (0, d.inject)(p.ServiceIdentifiers.Factory__IIdentifierNamesGenerator)), l(1, (0, d.inject)(p.ServiceIdentifiers.ICustomCodeHelperFormatter)), l(2, (0, d.inject)(p.ServiceIdentifiers.IRandomGenerator)), l(3, (0, d.inject)(p.ServiceIdentifiers.IOptions)), c("design:paramtypes", ["function" == typeof (o = void 0 !== u.TIdentifierNamesGeneratorFactory && u.TIdentifierNamesGeneratorFactory) ? o : Object, "function" == typeof (n = void 0 !== f.ICustomCodeHelperFormatter && f.ICustomCodeHelperFormatter) ? n : Object, "function" == typeof (i = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? i : Object, "function" == typeof (a = void 0 !== m.IOptions && m.IOptions) ? a : Object])], N)
    }, 92486: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeTransformer = void 0, function (e) {
        e.BooleanLiteralTransformer = "BooleanLiteralTransformer", e.BlockStatementControlFlowTransformer = "BlockStatementControlFlowTransformer", e.BlockStatementSimplifyTransformer = "BlockStatementSimplifyTransformer", e.ClassFieldTransformer = "ClassFieldTransformer", e.CommentsTransformer = "CommentsTransformer", e.CustomCodeHelpersTransformer = "CustomCodeHelpersTransformer", e.DeadCodeInjectionIdentifiersTransformer = "DeadCodeInjectionIdentifiersTransformer", e.DeadCodeInjectionTransformer = "DeadCodeInjectionTransformer", e.DirectivePlacementTransformer = "DirectivePlacementTransformer", e.EscapeSequenceTransformer = "EscapeSequenceTransformer", e.EvalCallExpressionTransformer = "EvalCallExpressionTransformer", e.ExportSpecifierTransformer = "ExportSpecifierTransformer", e.ExpressionStatementsMergeTransformer = "ExpressionStatementsMergeTransformer", e.FunctionControlFlowTransformer = "FunctionControlFlowTransformer", e.IfStatementSimplifyTransformer = "IfStatementSimplifyTransformer", e.LabeledStatementTransformer = "LabeledStatementTransformer", e.MemberExpressionTransformer = "MemberExpressionTransformer", e.MetadataTransformer = "MetadataTransformer", e.NumberLiteralTransformer = "NumberLiteralTransformer", e.NumberToNumericalExpressionTransformer = "NumberToNumericalExpressionTransformer", e.ObfuscatingGuardsTransformer = "ObfuscatingGuardsTransformer", e.ObjectExpressionKeysTransformer = "ObjectExpressionKeysTransformer", e.ObjectExpressionTransformer = "ObjectExpressionTransformer", e.ObjectPatternPropertiesTransformer = "ObjectPatternPropertiesTransformer", e.ParentificationTransformer = "ParentificationTransformer", e.RenamePropertiesTransformer = "RenamePropertiesTransformer", e.ScopeIdentifiersTransformer = "ScopeIdentifiersTransformer", e.ScopeThroughIdentifiersTransformer = "ScopeThroughIdentifiersTransformer", e.SplitStringTransformer = "SplitStringTransformer", e.StringArrayControlFlowTransformer = "StringArrayControlFlowTransformer", e.StringArrayTransformer = "StringArrayTransformer", e.StringArrayRotateFunctionTransformer = "StringArrayRotateFunctionTransformer", e.StringArrayScopeCallsWrapperTransformer = "StringArrayScopeCallsWrapperTransformer", e.TemplateLiteralTransformer = "TemplateLiteralTransformer", e.VariableDeclarationsMergeTransformer = "VariableDeclarationsMergeTransformer", e.VariablePreserveTransformer = "VariablePreserveTransformer", e.VMTransformer = "VMTransformer"
      }(r || (t.NodeTransformer = r = {}))
    }, 92891: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 92905: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 93141: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.getNodeModuleVarsCaptureTemplate = function () {
        return "\n        // Capture Node.js module-scoped variables (require, module, exports, __filename, __dirname)\n        (function() {\n            if (!{vmGlobalsName}.require) {\n                try { {vmGlobalsName}.require = require; } catch (e) {}\n            }\n            if (!{vmGlobalsName}.module) {\n                try { {vmGlobalsName}.module = module; } catch (e) {}\n            }\n            if (!{vmGlobalsName}.exports) {\n                try { {vmGlobalsName}.exports = exports; } catch (e) {}\n            }\n            if (!{vmGlobalsName}.__filename) {\n                try { {vmGlobalsName}.__filename = __filename; } catch (e) {}\n            }\n            if (!{vmGlobalsName}.__dirname) {\n                try { {vmGlobalsName}.__dirname = __dirname; } catch (e) {}\n            }\n        })();"
      }
    }, 93184: (e, t) => {
      var r;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeType = void 0, function (e) {
        e.ArrayExpression = "ArrayExpression", e.ArrayPattern = "ArrayPattern", e.ArrowFunctionExpression = "ArrowFunctionExpression", e.AssignmentExpression = "AssignmentExpression", e.AssignmentPattern = "AssignmentPattern", e.AwaitExpression = "AwaitExpression", e.BinaryExpression = "BinaryExpression", e.BlockStatement = "BlockStatement", e.BreakStatement = "BreakStatement", e.CallExpression = "CallExpression", e.CatchClause = "CatchClause", e.ChainExpression = "ChainExpression", e.ClassBody = "ClassBody", e.ClassDeclaration = "ClassDeclaration", e.ClassExpression = "ClassExpression", e.ConditionalExpression = "ConditionalExpression", e.ContinueStatement = "ContinueStatement", e.DoWhileStatement = "DoWhileStatement", e.ExportAllDeclaration = "ExportAllDeclaration", e.ExportNamedDeclaration = "ExportNamedDeclaration", e.ExportSpecifier = "ExportSpecifier", e.ExpressionStatement = "ExpressionStatement", e.ForStatement = "ForStatement", e.ForInStatement = "ForInStatement", e.ForOfStatement = "ForOfStatement", e.FunctionDeclaration = "FunctionDeclaration", e.FunctionExpression = "FunctionExpression", e.Identifier = "Identifier", e.IfStatement = "IfStatement", e.ImportDeclaration = "ImportDeclaration", e.ImportExpression = "ImportExpression", e.ImportDefaultSpecifier = "ImportDefaultSpecifier", e.ImportNamespaceSpecifier = "ImportNamespaceSpecifier", e.ImportSpecifier = "ImportSpecifier", e.LabeledStatement = "LabeledStatement", e.Literal = "Literal", e.LogicalExpression = "LogicalExpression", e.MemberExpression = "MemberExpression", e.MetaProperty = "MetaProperty", e.MethodDefinition = "MethodDefinition", e.NewExpression = "NewExpression", e.ObjectExpression = "ObjectExpression", e.ObjectPattern = "ObjectPattern", e.PrivateIdentifier = "PrivateIdentifier", e.Program = "Program", e.Property = "Property", e.PropertyDefinition = "PropertyDefinition", e.RestElement = "RestElement", e.ReturnStatement = "ReturnStatement", e.SequenceExpression = "SequenceExpression", e.SpreadElement = "SpreadElement", e.StaticBlock = "StaticBlock", e.Super = "Super", e.SwitchCase = "SwitchCase", e.SwitchStatement = "SwitchStatement", e.TaggedTemplateExpression = "TaggedTemplateExpression", e.TemplateElement = "TemplateElement", e.TemplateLiteral = "TemplateLiteral", e.ThisExpression = "ThisExpression", e.ThrowStatement = "ThrowStatement", e.TryStatement = "TryStatement", e.UnaryExpression = "UnaryExpression", e.UpdateExpression = "UpdateExpression", e.VariableDeclaration = "VariableDeclaration", e.VariableDeclarator = "VariableDeclarator", e.WithStatement = "WithStatement", e.WhileStatement = "WhileStatement", e.YieldExpression = "YieldExpression"
      }(r || (t.NodeType = r = {}))
    }, 93313: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.convertingTransformersModule = void 0;
      const o = r(45337), n = r(74572), i = r(31391), a = r(92486), s = r(21559), c = r(24446), l = r(5605),
        d = r(50474), p = r(84072), u = r(53856), f = r(39056), m = r(82660), g = r(80323), h = r(90388), y = r(30451),
        S = r(31030), N = r(44375), b = r(52263);
      t.convertingTransformersModule = new o.ContainerModule(e => {
        e(i.ServiceIdentifiers.INodeTransformer).to(l.BooleanLiteralTransformer).whenTargetNamed(a.NodeTransformer.BooleanLiteralTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(d.ExportSpecifierTransformer).whenTargetNamed(a.NodeTransformer.ExportSpecifierTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(p.MemberExpressionTransformer).whenTargetNamed(a.NodeTransformer.MemberExpressionTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(u.ClassFieldTransformer).whenTargetNamed(a.NodeTransformer.ClassFieldTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(f.NumberLiteralTransformer).whenTargetNamed(a.NodeTransformer.NumberLiteralTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(m.NumberToNumericalExpressionTransformer).whenTargetNamed(a.NodeTransformer.NumberToNumericalExpressionTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(g.ObjectExpressionKeysTransformer).whenTargetNamed(a.NodeTransformer.ObjectExpressionKeysTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(y.ObjectExpressionTransformer).whenTargetNamed(a.NodeTransformer.ObjectExpressionTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(S.ObjectPatternPropertiesTransformer).whenTargetNamed(a.NodeTransformer.ObjectPatternPropertiesTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(N.SplitStringTransformer).whenTargetNamed(a.NodeTransformer.SplitStringTransformer), e(i.ServiceIdentifiers.INodeTransformer).to(b.TemplateLiteralTransformer).whenTargetNamed(a.NodeTransformer.TemplateLiteralTransformer), e(i.ServiceIdentifiers.IObjectExpressionExtractor).to(h.ObjectExpressionToVariableDeclarationExtractor).whenTargetNamed(s.ObjectExpressionExtractor.ObjectExpressionToVariableDeclarationExtractor), e(i.ServiceIdentifiers.IObjectExpressionExtractor).to(c.BasePropertiesExtractor).whenTargetNamed(s.ObjectExpressionExtractor.BasePropertiesExtractor), e(i.ServiceIdentifiers.Factory__IObjectExpressionExtractor).toFactory(n.InversifyContainerFacade.getCacheFactory(i.ServiceIdentifiers.IObjectExpressionExtractor))
      })
    }, 93571: function (e, t, r) {
      var o, n = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), a = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), a = 0; a < r.length; a++) "default" !== r[a] && n(t, e, r[a]);
        return i(t, e), t
      });
      Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeFactory = void 0;
      const s = a(r(65850)), c = r(93184);

      class l {
        static programNode(e = []) {
          return { type: c.NodeType.Program, body: e, sourceType: "script", metadata: { ignoredNode: !1 } }
        }

        static arrayExpressionNode(e = []) {
          return { type: c.NodeType.ArrayExpression, elements: e, metadata: { ignoredNode: !1 } }
        }

        static assignmentExpressionNode(e, t, r) {
          return {
            type: c.NodeType.AssignmentExpression,
            operator: e,
            left: t,
            right: r,
            metadata: { ignoredNode: !1 }
          }
        }

        static binaryExpressionNode(e, t, r) {
          return { type: c.NodeType.BinaryExpression, operator: e, left: t, right: r, metadata: { ignoredNode: !1 } }
        }

        static blockStatementNode(e = []) {
          return { type: c.NodeType.BlockStatement, body: e, metadata: { ignoredNode: !1 } }
        }

        static breakStatement(e) {
          return { type: c.NodeType.BreakStatement, label: e, metadata: { ignoredNode: !1 } }
        }

        static callExpressionNode(e, t = [], r = !1) {
          return {
            type: c.NodeType.CallExpression,
            callee: e,
            optional: r,
            arguments: t,
            metadata: { ignoredNode: !1 }
          }
        }

        static chainExpressionNode(e) {
          return { type: c.NodeType.ChainExpression, expression: e, metadata: { ignoredNode: !1 } }
        }

        static conditionalExpressionNode(e, t, r) {
          return {
            type: c.NodeType.ConditionalExpression,
            test: e,
            consequent: t,
            alternate: r,
            metadata: { ignoredNode: !1 }
          }
        }

        static continueStatement(e) {
          return { type: c.NodeType.ContinueStatement, label: e, metadata: { ignoredNode: !1 } }
        }

        static directiveNode(e, t) {
          return { type: c.NodeType.ExpressionStatement, expression: e, directive: t, metadata: { ignoredNode: !1 } }
        }

        static doWhileStatementNode(e, t) {
          return { type: c.NodeType.DoWhileStatement, body: e, test: t, metadata: { ignoredNode: !1 } }
        }

        static exportAllDeclarationNode(e, t) {
          return { type: c.NodeType.ExportAllDeclaration, exported: t, source: e, metadata: { ignoredNode: !1 } }
        }

        static exportNamedDeclarationNode(e, t) {
          return { type: c.NodeType.ExportNamedDeclaration, specifiers: e, source: t, metadata: { ignoredNode: !1 } }
        }

        static expressionStatementNode(e) {
          return { type: c.NodeType.ExpressionStatement, expression: e, metadata: { ignoredNode: !1 } }
        }

        static forStatementNode(e, t, r, o) {
          return { type: c.NodeType.ForStatement, init: e, test: t, update: r, body: o, metadata: { ignoredNode: !1 } }
        }

        static forInStatementNode(e, t, r) {
          return { type: c.NodeType.ForInStatement, left: e, right: t, body: r, metadata: { ignoredNode: !1 } }
        }

        static forOfStatementNode(e, t, r, o) {
          return {
            type: c.NodeType.ForOfStatement,
            await: e,
            left: t,
            right: r,
            body: o,
            metadata: { ignoredNode: !1 }
          }
        }

        static functionDeclarationNode(e, t, r) {
          return {
            type: c.NodeType.FunctionDeclaration,
            id: l.identifierNode(e),
            params: t,
            body: r,
            generator: !1,
            metadata: { ignoredNode: !1 }
          }
        }

        static functionExpressionNode(e, t) {
          return {
            type: c.NodeType.FunctionExpression,
            params: e,
            body: t,
            generator: !1,
            metadata: { ignoredNode: !1 }
          }
        }

        static ifStatementNode(e, t, r) {
          return {
            type: c.NodeType.IfStatement,
            test: e,
            consequent: t, ...r && { alternate: r },
            metadata: { ignoredNode: !1 }
          }
        }

        static identifierNode(e) {
          return { type: c.NodeType.Identifier, name: e, metadata: { ignoredNode: !1 } }
        }

        static importDeclarationNode(e, t) {
          return { type: c.NodeType.ImportDeclaration, specifiers: e, source: t, metadata: { ignoredNode: !1 } }
        }

        static labeledStatementNode(e, t) {
          return { type: c.NodeType.LabeledStatement, label: e, body: t, metadata: { ignoredNode: !1 } }
        }

        static literalNode(e, t) {
          return t = null != t ? t : `'${e}'`, {
            type: c.NodeType.Literal,
            value: e,
            raw: t,
            "x-verbatim-property": { content: t, precedence: s.Precedence.Primary },
            metadata: { ignoredNode: !1 }
          }
        }

        static logicalExpressionNode(e, t, r) {
          return { type: c.NodeType.LogicalExpression, operator: e, left: t, right: r, metadata: { ignoredNode: !1 } }
        }

        static memberExpressionNode(e, t, r = !1, o = !1) {
          return {
            type: c.NodeType.MemberExpression,
            computed: r,
            object: e,
            optional: o,
            property: t,
            metadata: { ignoredNode: !1 }
          }
        }

        static metaPropertyNode(e, t) {
          return { type: c.NodeType.MetaProperty, meta: e, property: t, metadata: { ignoredNode: !1 } }
        }

        static objectExpressionNode(e) {
          return { type: c.NodeType.ObjectExpression, properties: e, metadata: { ignoredNode: !1 } }
        }

        static propertyNode(e, t, r = !1) {
          return {
            type: c.NodeType.Property,
            key: e,
            value: t,
            kind: "init",
            method: !1,
            shorthand: !1,
            computed: r,
            metadata: { ignoredNode: !1 }
          }
        }

        static restElementNode(e) {
          return { type: c.NodeType.RestElement, argument: e, metadata: { ignoredNode: !1 } }
        }

        static returnStatementNode(e) {
          return { type: c.NodeType.ReturnStatement, argument: e, metadata: { ignoredNode: !1 } }
        }

        static sequenceExpressionNode(e) {
          return { type: c.NodeType.SequenceExpression, expressions: e, metadata: { ignoredNode: !1 } }
        }

        static spreadElementNode(e) {
          return { type: c.NodeType.SpreadElement, argument: e, metadata: { ignoredNode: !1 } }
        }

        static staticBlockNode(e = []) {
          return { type: c.NodeType.StaticBlock, body: e, metadata: { ignoredNode: !1 } }
        }

        static switchStatementNode(e, t) {
          return { type: c.NodeType.SwitchStatement, discriminant: e, cases: t, metadata: { ignoredNode: !1 } }
        }

        static switchCaseNode(e, t) {
          return { type: c.NodeType.SwitchCase, test: e, consequent: t, metadata: { ignoredNode: !1 } }
        }

        static superNode() {
          return { type: c.NodeType.Super, metadata: { ignoredNode: !1 } }
        }

        static thisExpressionNode() {
          return { type: c.NodeType.ThisExpression, metadata: { ignoredNode: !1 } }
        }

        static unaryExpressionNode(e, t, r = !0) {
          return {
            type: c.NodeType.UnaryExpression,
            operator: e,
            argument: t,
            prefix: r,
            metadata: { ignoredNode: !1 }
          }
        }

        static updateExpressionNode(e, t) {
          return {
            type: c.NodeType.UpdateExpression,
            operator: e,
            argument: t,
            prefix: !1,
            metadata: { ignoredNode: !1 }
          }
        }

        static variableDeclarationNode(e = [], t = "var") {
          return { type: c.NodeType.VariableDeclaration, declarations: e, kind: t, metadata: { ignoredNode: !1 } }
        }

        static variableDeclaratorNode(e, t) {
          return { type: c.NodeType.VariableDeclarator, id: e, init: t, metadata: { ignoredNode: !1 } }
        }

        static whileStatementNode(e, t) {
          return { type: c.NodeType.WhileStatement, test: e, body: t, metadata: { ignoredNode: !1 } }
        }
      }

      t.NodeFactory = l
    }, 94472: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.BlackListObfuscatingGuard = void 0;
      const a = r(45337), s = r(62467), c = r(27391);
      let l = o = class {
        constructor() {
          this.blackListGuardsLength = o.blackListGuards.length
        }

        check(e) {
          for (let t = 0; t < this.blackListGuardsLength; t++) if (o.blackListGuards[t](e)) return s.ObfuscatingGuardResult.Ignore;
          return s.ObfuscatingGuardResult.Transform
        }
      };
      t.BlackListObfuscatingGuard = l, l.blackListGuards = [c.NodeGuards.isDirectiveNode], t.BlackListObfuscatingGuard = l = o = n([(0, a.injectable)(), i("design:paramtypes", [])], l)
    }, 94487: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 94554: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.StringArrayScopeCallsWrappersDataStorage = void 0;
      const c = r(45337), l = r(31391), d = r(76393), p = r(31142), u = r(81600);
      let f = class extends u.WeakMapStorage {
        constructor(e, t) {
          super(e, t)
        }
      };
      t.StringArrayScopeCallsWrappersDataStorage = f, t.StringArrayScopeCallsWrappersDataStorage = f = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IRandomGenerator)), s(1, (0, c.inject)(l.ServiceIdentifiers.IOptions)), a("design:paramtypes", ["function" == typeof (o = void 0 !== p.IRandomGenerator && p.IRandomGenerator) ? o : Object, "function" == typeof (n = void 0 !== d.IOptions && d.IOptions) ? n : Object])], f)
    }, 94991: function (e, t, r) {
      var o, n, i, a, s, c, l = this && this.__createBinding || (Object.create ? function (e, t, r, o) {
        void 0 === o && (o = r);
        var n = Object.getOwnPropertyDescriptor(t, r);
        n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0, get: function () {
            return t[r]
          }
        }), Object.defineProperty(e, o, n)
      } : function (e, t, r, o) {
        void 0 === o && (o = r), e[o] = t[r]
      }), d = this && this.__setModuleDefault || (Object.create ? function (e, t) {
        Object.defineProperty(e, "default", { enumerable: !0, value: t })
      } : function (e, t) {
        e.default = t
      }), p = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, u = this && this.__importStar || (o = function (e) {
        return o = Object.getOwnPropertyNames || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t
        }, o(e)
      }, function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var r = o(e), n = 0; n < r.length; n++) "default" !== r[n] && l(t, e, r[n]);
        return d(t, e), t
      }), f = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, m = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DeadCodeInjectionTransformer = void 0;
      const g = r(45337), h = r(31391), y = u(r(31659)), S = r(64134), N = r(76393), b = r(31142), _ = r(80540),
        v = r(29154), I = r(92486), O = r(93184), C = r(75716), E = r(13245), T = r(93571), R = r(27391), M = r(4592),
        A = r(43243), F = r(33056);
      let P = n = class extends E.AbstractNodeTransformer {
        constructor(e, t, r, o) {
          super(r, o), this.deadCodeInjectionRootAstHostNodeSet = new WeakSet, this.collectedBlockStatements = [], this.collectedBlockStatementsTotalLength = 0, this.deadCodeInjectionCustomNodeFactory = e, this.transformersRunner = t
        }

        static isProhibitedNodeInsideCollectedBlockStatement(e) {
          return R.NodeGuards.isFunctionDeclarationNode(e) || R.NodeGuards.isBreakStatementNode(e) || R.NodeGuards.isContinueStatementNode(e) || R.NodeGuards.isAwaitExpressionNode(e) || R.NodeGuards.isYieldExpressionNode(e) || R.NodeGuards.isSuperNode(e) || R.NodeGuards.isForOfStatementNode(e) && e.await || R.NodeGuards.isPrivateIdentifierNode(e)
        }

        static isScopeHoistingFunctionDeclaration(e) {
          if (!R.NodeGuards.isFunctionDeclarationNode(e)) return !1;
          const t = A.NodeStatementUtils.getScopeOfNode(e),
            r = R.NodeGuards.isSwitchCaseNode(t) ? t.consequent : t.body, o = r.indexOf(e);
          if (0 === o) return !1;
          const n = r.slice(0, o), i = T.NodeFactory.blockStatementNode(n), a = e.id.name;
          let s = !1;
          return y.traverse(i, {
            enter: e => {
              if (R.NodeGuards.isIdentifierNode(e) && e.name === a) return s = !0, y.VisitorOption.Break
            }
          }), s
        }

        static isValidCollectedBlockStatementNode(e) {
          if (!e.body.length) return !1;
          let t = 0, r = !0;
          return y.traverse(e, {
            enter: e => {
              if (R.NodeGuards.isBlockStatementNode(e) && t++, t > n.maxNestedBlockStatementsCount || n.isProhibitedNodeInsideCollectedBlockStatement(e) || n.isScopeHoistingFunctionDeclaration(e)) return r = !1, y.VisitorOption.Break
            }
          }), r
        }

        static isValidWrappedBlockStatementNode(e, t) {
          if (M.NodeMetadata.isEvalHostNode(t)) return !1;
          if (!e.body.length) return !1;
          let r = !0;
          return y.traverse(e, {
            enter: e => {
              if (n.isScopeHoistingFunctionDeclaration(e)) return r = !1, y.VisitorOption.Break
            }
          }), !!r && A.NodeStatementUtils.getParentNodeWithStatements(e).type !== O.NodeType.Program
        }

        getVisitor(e) {
          switch (e) {
            case C.NodeTransformationStage.DeadCodeInjection:
              return {
                enter: (e, t) => {
                  if (t && R.NodeGuards.isProgramNode(e)) return this.prepareNode(e, t), e
                }, leave: (e, t) => {
                  if (t && R.NodeGuards.isBlockStatementNode(e)) return this.transformNode(e, t)
                }
              };
            case C.NodeTransformationStage.StringArray:
              return {
                enter: (e, t) => {
                  if (t && this.isDeadCodeInjectionRootAstHostNode(e)) return this.restoreNode(e, t)
                }
              };
            default:
              return null
          }
        }

        prepareNode(e, t) {
          y.traverse(e, {
            enter: e => {
              if (!R.NodeGuards.isBlockStatementNode(e)) return;
              const t = F.NodeUtils.clone(e);
              if (!n.isValidCollectedBlockStatementNode(t)) return;
              const r = this.makeClonedBlockStatementNodeUnique(t);
              this.collectedBlockStatements.push(r)
            }
          }), this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length
        }

        transformNode(e, t) {
          if (!this.collectedBlockStatements.length || this.collectedBlockStatementsTotalLength < n.minCollectedBlockStatementsCount) return y.VisitorOption.Break;
          if (this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold || !n.isValidWrappedBlockStatementNode(e, t)) return e;
          const r = this.collectedBlockStatements.length - 1, o = this.randomGenerator.getRandomInteger(0, r),
            i = this.collectedBlockStatements.splice(o, 1)[0];
          return i === e ? e : this.replaceBlockStatementNode(e, i, t)
        }

        restoreNode(e, t) {
          const r = e.body[0];
          if (!R.NodeGuards.isFunctionDeclarationNode(r)) throw new Error("Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node");
          return r.body
        }

        isDeadCodeInjectionRootAstHostNode(e) {
          const t = R.NodeGuards.isBlockStatementNode(e) && this.deadCodeInjectionRootAstHostNodeSet.has(e);
          return t && this.deadCodeInjectionRootAstHostNodeSet.delete(e), t
        }

        makeClonedBlockStatementNodeUnique(e) {
          const t = T.NodeFactory.programNode([T.NodeFactory.expressionStatementNode(T.NodeFactory.functionExpressionNode([], e))]);
          return F.NodeUtils.parentizeAst(t), F.NodeUtils.parentizeNode(t, t), this.transformersRunner.transform(t, n.transformersToRenameBlockScopeIdentifiers, C.NodeTransformationStage.RenameIdentifiers), e
        }

        replaceBlockStatementNode(e, t, r) {
          const o = T.NodeFactory.blockStatementNode([T.NodeFactory.functionDeclarationNode(n.deadCodeInjectionRootAstHostNodeName, [], t)]);
          this.deadCodeInjectionRootAstHostNodeSet.add(o);
          const i = this.deadCodeInjectionCustomNodeFactory(v.DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);
          i.initialize(e, o);
          const a = i.getNode()[0];
          return F.NodeUtils.parentizeNode(a, r), a
        }
      };
      t.DeadCodeInjectionTransformer = P, P.deadCodeInjectionRootAstHostNodeName = "deadCodeInjectionRootAstHostNode", P.maxNestedBlockStatementsCount = 4, P.minCollectedBlockStatementsCount = 5, P.transformersToRenameBlockScopeIdentifiers = [I.NodeTransformer.DeadCodeInjectionIdentifiersTransformer, I.NodeTransformer.LabeledStatementTransformer, I.NodeTransformer.ScopeIdentifiersTransformer], t.DeadCodeInjectionTransformer = P = n = p([(0, g.injectable)(), m(0, (0, g.inject)(h.ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)), m(1, (0, g.inject)(h.ServiceIdentifiers.INodeTransformersRunner)), m(2, (0, g.inject)(h.ServiceIdentifiers.IRandomGenerator)), m(3, (0, g.inject)(h.ServiceIdentifiers.IOptions)), f("design:paramtypes", ["function" == typeof (i = void 0 !== S.TDeadNodeInjectionCustomNodeFactory && S.TDeadNodeInjectionCustomNodeFactory) ? i : Object, "function" == typeof (a = void 0 !== _.INodeTransformersRunner && _.INodeTransformersRunner) ? a : Object, "function" == typeof (s = void 0 !== b.IRandomGenerator && b.IRandomGenerator) ? s : Object, "function" == typeof (c = void 0 !== N.IOptions && N.IOptions) ? c : Object])], P)
    }, 95129: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.optionsModule = void 0;
      const o = r(45337), n = r(31391), i = r(26251), a = r(40104);
      t.optionsModule = new o.ContainerModule(e => {
        e(n.ServiceIdentifiers.IOptions).to(i.Options).inSingletonScope(), e(n.ServiceIdentifiers.IOptionsNormalizer).to(a.OptionsNormalizer).inSingletonScope()
      })
    }, 95225: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CryptUtils = void 0;
      const s = r(45337), c = r(31391), l = r(31142), d = r(63512), p = r(3734), u = r(39079);
      let f = class {
        constructor(e) {
          this.base64Alphabet = d.base64alphabet, this.randomGenerator = e
        }

        btoa(e) {
          const t = this.base64Alphabet;
          let r = "";
          e = encodeURIComponent(e).replace(/%([0-9A-F]{2})/g, (e, t) => String.fromCharCode(parseInt(`${u.Utils.hexadecimalPrefix}${t}`, 16)));
          for (let o, n, i = 0, a = t; e.charAt(0 | i) || (a = "=", i % 1); r += a.charAt(63 & o >> 8 - i % 1 * 8)) {
            if (n = e.charCodeAt(i += 3 / 4), n > 255) throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
            o = o << 8 | n
          }
          return r
        }

        hideString(e, t) {
          let r = this.randomGenerator.getRandomGenerator().string({
            length: t,
            pool: p.RandomGenerator.randomGeneratorPool
          }).replace(new RegExp(`[${o=e,o.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}]`, "g"), "");
          var o;
          const n = r.split("");
          return this.randomGenerator.getRandomGenerator().shuffle(n), r = n.join(""), [((e, t) => {
            let r = -1, o = -1, n = "";
            for (; r < e.length || o < t.length;) this.randomGenerator.getMathRandom() < .5 && o < t.length ? n += t.charAt(++o) : n += e.charAt(++r);
            return n
          })(e, r), r]
        }

        rc4(e, t) {
          const r = [];
          let o, n = 0, i = "";
          for (var a = 0; a < 256; a++) r[a] = a;
          for (a = 0; a < 256; a++) n = (n + r[a] + t.charCodeAt(a % t.length)) % 256, o = r[a], r[a] = r[n], r[n] = o;
          a = 0, n = 0;
          for (let t = 0; t < e.length; t++) n = (n + r[a = (a + 1) % 256]) % 256, o = r[a], r[a] = r[n], r[n] = o, i += String.fromCharCode(e.charCodeAt(t) ^ r[(r[a] + r[n]) % 256]);
          return i
        }
      };
      t.CryptUtils = f, t.CryptUtils = f = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.IRandomGenerator)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.IRandomGenerator && l.IRandomGenerator) ? o : Object])], f)
    }, 95309: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.customCodeHelpersModule = void 0;
      const o = r(74572), n = r(45337), i = r(31391), a = r(51875), s = r(52100), c = r(65714), l = r(6014),
        d = r(80299), p = r(41426), u = r(86552), f = r(21071), m = r(56831), g = r(63016), h = r(55842), y = r(12457),
        S = r(80388), N = r(25653), b = r(17845), _ = r(70881), v = r(78005), I = r(54867), O = r(82380), C = r(66540),
        E = r(56651), T = r(13328), R = r(80050);
      t.customCodeHelpersModule = new n.ContainerModule(e => {
        e(i.ServiceIdentifiers.ICustomCodeHelper).to(m.ConsoleOutputDisableCodeHelper).whenTargetNamed(a.CustomCodeHelper.ConsoleOutputDisable), e(i.ServiceIdentifiers.ICustomCodeHelper).to(y.DebugProtectionFunctionCallCodeHelper).whenTargetNamed(a.CustomCodeHelper.DebugProtectionFunctionCall), e(i.ServiceIdentifiers.ICustomCodeHelper).to(S.DebugProtectionFunctionIntervalCodeHelper).whenTargetNamed(a.CustomCodeHelper.DebugProtectionFunctionInterval), e(i.ServiceIdentifiers.ICustomCodeHelper).to(N.DebugProtectionFunctionCodeHelper).whenTargetNamed(a.CustomCodeHelper.DebugProtectionFunction), e(i.ServiceIdentifiers.ICustomCodeHelper).to(b.DomainLockCodeHelper).whenTargetNamed(a.CustomCodeHelper.DomainLock), e(i.ServiceIdentifiers.ICustomCodeHelper).to(_.CallsControllerFunctionCodeHelper).whenTargetNamed(a.CustomCodeHelper.CallsControllerFunction), e(i.ServiceIdentifiers.ICustomCodeHelper).to(v.SelfDefendingCodeHelper).whenTargetNamed(a.CustomCodeHelper.SelfDefending), e(i.ServiceIdentifiers.ICustomCodeHelper).to(I.StringArrayCallsWrapperCodeHelper).whenTargetNamed(a.CustomCodeHelper.StringArrayCallsWrapper), e(i.ServiceIdentifiers.ICustomCodeHelper).to(O.StringArrayCallsWrapperBase64CodeHelper).whenTargetNamed(a.CustomCodeHelper.StringArrayCallsWrapperBase64), e(i.ServiceIdentifiers.ICustomCodeHelper).to(C.StringArrayCallsWrapperRc4CodeHelper).whenTargetNamed(a.CustomCodeHelper.StringArrayCallsWrapperRc4), e(i.ServiceIdentifiers.ICustomCodeHelper).to(E.StringArrayCodeHelper).whenTargetNamed(a.CustomCodeHelper.StringArray), e(i.ServiceIdentifiers.ICustomCodeHelper).to(T.StringArrayRotateFunctionCodeHelper).whenTargetNamed(a.CustomCodeHelper.StringArrayRotateFunction), e(i.ServiceIdentifiers.ICustomCodeHelper).to(R.VMRuntimeCodeHelper).whenTargetNamed(a.CustomCodeHelper.VMRuntime), e(i.ServiceIdentifiers.ICustomCodeHelperGroup).to(c.ConsoleOutputCodeHelperGroup).whenTargetNamed(s.CustomCodeHelperGroup.ConsoleOutput), e(i.ServiceIdentifiers.ICustomCodeHelperGroup).to(l.DebugProtectionCodeHelperGroup).whenTargetNamed(s.CustomCodeHelperGroup.DebugProtection), e(i.ServiceIdentifiers.ICustomCodeHelperGroup).to(d.DomainLockCustomCodeHelperGroup).whenTargetNamed(s.CustomCodeHelperGroup.DomainLock), e(i.ServiceIdentifiers.ICustomCodeHelperGroup).to(p.SelfDefendingCodeHelperGroup).whenTargetNamed(s.CustomCodeHelperGroup.SelfDefending), e(i.ServiceIdentifiers.ICustomCodeHelperGroup).to(u.StringArrayCodeHelperGroup).whenTargetNamed(s.CustomCodeHelperGroup.StringArray), e(i.ServiceIdentifiers.ICustomCodeHelperGroup).to(f.VMCodeHelperGroup).whenTargetNamed(s.CustomCodeHelperGroup.VM), e(i.ServiceIdentifiers.Factory__ICustomCodeHelper).toFactory(o.InversifyContainerFacade.getFactory(i.ServiceIdentifiers.ICustomCodeHelper)), e(i.ServiceIdentifiers.Factory__ICustomCodeHelperGroup).toFactory(o.InversifyContainerFacade.getFactory(i.ServiceIdentifiers.ICustomCodeHelperGroup)), e(i.ServiceIdentifiers.ICustomCodeHelperFormatter).to(g.CustomCodeHelperFormatter).inSingletonScope(), e(i.ServiceIdentifiers.ICustomCodeHelperObfuscator).to(h.CustomCodeHelperObfuscator).inSingletonScope()
      })
    }, 95325: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.Rc4Template = function () {
        return "\n        const {rc4FunctionName} = function (str, key) {\n            let s = [], j = 0, x, output = '';\n           \n            str = {atobFunctionName}(str);\n                \n            let i;\n                    \t        \n            for (i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (let y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                output += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return output;\n        }\n    "
      }
    }, 96678: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DebuggerTemplate = function () {
        return "\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    "
      }
    }, 96884: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 })
    }, 96889: function (e, t, r) {
      var o, n, i, a, s = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, c = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, l = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VariablePreserveTransformer = void 0;
      const d = r(45337), p = r(51353), u = r(76393), f = r(31142), m = r(57809), g = r(92486), h = r(31391),
        y = r(75716), S = r(13245), N = r(27391);
      let b = class extends S.AbstractNodeTransformer {
        constructor(e, t, r, o) {
          super(t, r), this.runAfter = [g.NodeTransformer.ParentificationTransformer], this.identifierReplacer = e, this.scopeIdentifiersTraverser = o, this.preserveScopeVariableIdentifiers = this.preserveScopeVariableIdentifiers.bind(this)
        }

        getVisitor(e) {
          switch (e) {
            case y.NodeTransformationStage.Preparing:
            case y.NodeTransformationStage.Converting:
            case y.NodeTransformationStage.RenameIdentifiers:
              return {
                enter: (e, t) => {
                  if (t && N.NodeGuards.isProgramNode(e)) return this.transformNode(e, t)
                }
              };
            default:
              return null
          }
        }

        transformNode(e, t) {
          return this.scopeIdentifiersTraverser.traverseScopeIdentifiers(e, t, this.preserveScopeVariableIdentifiers), e
        }

        preserveScopeVariableIdentifiers(e) {
          const { isGlobalDeclaration: t, isBubblingDeclaration: r, variable: o, variableScope: n } = e;
          for (const e of o.identifiers) t || r ? this.preserveIdentifierNameForRootLexicalScope(e) : this.preserveIdentifierNameForLexicalScope(e, n)
        }

        preserveIdentifierNameForRootLexicalScope(e) {
          this.identifierReplacer.preserveName(e)
        }

        preserveIdentifierNameForLexicalScope(e, t) {
          const r = N.NodeGuards.isNodeWithLexicalScope(t.block) ? t.block : null;
          r && this.identifierReplacer.preserveNameForLexicalScope(e, r)
        }
      };
      t.VariablePreserveTransformer = b, t.VariablePreserveTransformer = b = s([(0, d.injectable)(), l(0, (0, d.inject)(h.ServiceIdentifiers.IIdentifierReplacer)), l(1, (0, d.inject)(h.ServiceIdentifiers.IRandomGenerator)), l(2, (0, d.inject)(h.ServiceIdentifiers.IOptions)), l(3, (0, d.inject)(h.ServiceIdentifiers.IScopeIdentifiersTraverser)), c("design:paramtypes", ["function" == typeof (o = void 0 !== p.IIdentifierReplacer && p.IIdentifierReplacer) ? o : Object, "function" == typeof (n = void 0 !== f.IRandomGenerator && f.IRandomGenerator) ? n : Object, "function" == typeof (i = void 0 !== u.IOptions && u.IOptions) ? i : Object, "function" == typeof (a = void 0 !== m.IScopeIdentifiersTraverser && m.IScopeIdentifiersTraverser) ? a : Object])], b)
    }, 96895: e => {
      e.exports = require("chalk")
    }, 96974: function (e, t, r) {
      var o, n, i, a = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, s = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMOperatorCompiler = void 0;
      const c = r(45337), l = r(20924), d = r(31391), p = r(25115), u = r(27391), f = r(43636), m = r(25560);
      let g = o = class {
        compileBinaryExpression(e, t) {
          var r, n;
          null === (r = t.dispatch) || void 0 === r || r.expression(e.left), null === (n = t.dispatch) || void 0 === n || n.expression(e.right);
          const i = this.vmCompilerUtils.createInstructionBuilder(t), a = o.binaryOpMap[e.operator];
          void 0 !== a ? i.emitRaw({ op: a }) : i.pop().pushUndefined()
        }

        compileUnaryExpression(e, t) {
          var r;
          if ("delete" === e.operator) return void this.compileDeleteExpression(e, t);
          if ("typeof" === e.operator && u.NodeGuards.isIdentifierNode(e.argument)) {
            const r = e.argument.name;
            if ("arguments" !== r) {
              const e = this.variableResolver.resolve(r, t);
              if (e.location === m.VariableLocation.Global) return void this.vmCompilerUtils.createInstructionBuilder(t).typeofGlobal(e.index)
            }
          }
          null === (r = t.dispatch) || void 0 === r || r.expression(e.argument);
          const n = o.unaryOpMap[e.operator];
          void 0 !== n && this.vmCompilerUtils.createInstructionBuilder(t).emitRaw({ op: n })
        }

        compileLogicalExpression(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          null === (r = t.dispatch) || void 0 === r || r.expression(e.left), n.dup();
          const i = "&&" === e.operator ? p.VMOpCode.JUMP_IF_FALSE : "||" === e.operator ? p.VMOpCode.JUMP_IF_TRUE : p.VMOpCode.JUMP_NULLISH,
            a = this.vmCompilerUtils.emitConditionalJump(i, t);
          n.pop(), null === (o = t.dispatch) || void 0 === o || o.expression(e.right), this.vmCompilerUtils.patchJump(a, t)
        }

        compileUpdateExpression(e, t) {
          const r = this.vmCompilerUtils.createInstructionBuilder(t);
          if (u.NodeGuards.isMemberExpressionNode(e.argument)) return void this.compileUpdateMemberExpression(e, t);
          if (!u.NodeGuards.isIdentifierNode(e.argument)) return void r.pushUndefined();
          const o = e.argument.name;
          this.vmCompilerUtils.emitLoadVariable(o, t), e.prefix || r.dup(), r.loadConst(1), "++" === e.operator ? r.add() : r.subtract(), e.prefix && r.dup(), this.vmCompilerUtils.emitStoreVariable(o, t)
        }

        compileDeleteExpression(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          if (u.NodeGuards.isMemberExpressionNode(e.argument)) {
            const i = e.argument;
            if ("Super" === i.object.type) return void n.pushFalse();
            if (null === (r = t.dispatch) || void 0 === r || r.expression(i.object), i.computed) {
              if ("PrivateIdentifier" === i.property.type) return n.pop(), void n.pushFalse();
              null === (o = t.dispatch) || void 0 === o || o.expression(i.property), n.emitRaw({ op: p.VMOpCode.DELETE_PROP })
            } else {
              if (!u.NodeGuards.isIdentifierNode(i.property)) return n.pop(), void n.pushFalse();
              {
                const e = t.constantPool.add(i.property.name);
                n.emitRaw({ op: p.VMOpCode.DELETE_PROP, arg: e })
              }
            }
          } else n.pushTrue()
        }

        compileUpdateMemberExpression(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t), i = e.argument;
          if (i.computed || !u.NodeGuards.isIdentifierNode(i.property)) return void n.pushUndefined();
          const a = i.property.name, s = t.constantPool.add(a);
          null === (r = t.dispatch) || void 0 === r || r.expression(i.object), n.getPropertyByName(s), e.prefix || n.dup(), n.loadConst(1), "++" === e.operator ? n.add() : n.subtract(), null === (o = t.dispatch) || void 0 === o || o.expression(i.object), n.swap(), n.setProperty(s), e.prefix || n.pop()
        }
      };
      t.VMOperatorCompiler = g, g.binaryOpMap = {
        "+": p.VMOpCode.ADD,
        "-": p.VMOpCode.SUB,
        "*": p.VMOpCode.MUL,
        "/": p.VMOpCode.DIV,
        "%": p.VMOpCode.MOD,
        "**": p.VMOpCode.EXPONENT,
        "==": p.VMOpCode.EQ,
        "!=": p.VMOpCode.NEQ,
        "===": p.VMOpCode.STRICT_EQ,
        "!==": p.VMOpCode.STRICT_NEQ,
        "<": p.VMOpCode.LT,
        "<=": p.VMOpCode.LTE,
        ">": p.VMOpCode.GT,
        ">=": p.VMOpCode.GTE,
        "&": p.VMOpCode.BIT_AND,
        "|": p.VMOpCode.BIT_OR,
        "^": p.VMOpCode.BIT_XOR,
        "<<": p.VMOpCode.SHL,
        ">>": p.VMOpCode.SHR,
        ">>>": p.VMOpCode.USHR,
        in: p.VMOpCode.IN,
        instanceof: p.VMOpCode.INSTANCEOF
      }, g.unaryOpMap = {
        "+": p.VMOpCode.UNARY_PLUS,
        "-": p.VMOpCode.NEG,
        "!": p.VMOpCode.LOGICAL_NOT,
        "~": p.VMOpCode.BIT_NOT,
        typeof: p.VMOpCode.TYPEOF,
        void: p.VMOpCode.VOID
      }, a([(0, c.inject)(d.ServiceIdentifiers.IVMCompilerUtils), s("design:type", "function" == typeof (n = void 0 !== l.IVMCompilerUtils && l.IVMCompilerUtils) ? n : Object)], g.prototype, "vmCompilerUtils", void 0), a([(0, c.inject)(d.ServiceIdentifiers.IVMVariableResolver), s("design:type", "function" == typeof (i = void 0 !== f.VMVariableResolver && f.VMVariableResolver) ? i : Object)], g.prototype, "variableResolver", void 0), t.VMOperatorCompiler = g = o = a([(0, c.injectable)()], g)
    }, 97114: function (e, t, r) {
      var o, n, i, a, s, c = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, l = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, d = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomCodeHelpersTransformer = void 0;
      const p = r(45337), u = r(31391), f = r(92891), m = r(76393), g = r(31142), h = r(61933), y = r(1561),
        S = r(92486), N = r(75716), b = r(13245), _ = r(27391);
      let v = class extends b.AbstractNodeTransformer {
        constructor(e, t, r, o, n) {
          super(o, n), this.runAfter = [S.NodeTransformer.ParentificationTransformer, S.NodeTransformer.VariablePreserveTransformer], this.callsGraphData = [], this.callsGraphAnalyzer = e, this.prevailingKindOfVariablesAnalyzer = t, this.customCodeHelperGroupStorage = r
        }

        getVisitor(e) {
          return e === N.NodeTransformationStage.Preparing ? {
            leave: (e, t) => {
              if (_.NodeGuards.isProgramNode(e)) return this.prepareNode(e, t), this.appendCustomNodesForPreparingStage(e, t), this.transformNode(e, t)
            }
          } : { leave: (t, r) => (_.NodeGuards.isProgramNode(t) && this.appendCustomNodesForStage(e, t, r), t) }
        }

        prepareNode(e, t) {
          this.callsGraphData = this.callsGraphAnalyzer.analyze(e), this.prevailingKindOfVariablesAnalyzer.analyze(e)
        }

        transformNode(e, t) {
          return e
        }

        appendCustomNodesForPreparingStage(e, t) {
          this.customCodeHelperGroupStorage.getStorage().forEach(t => {
            var r;
            t.initialize(), null === (r = t.appendOnPreparingStage) || void 0 === r || r.call(t, e, this.callsGraphData)
          })
        }

        appendCustomNodesForStage(e, t, r) {
          this.customCodeHelperGroupStorage.getStorage().forEach(r => {
            var o;
            null === (o = r[`appendOn${e}Stage`]) || void 0 === o || o.call(r, t, this.callsGraphData)
          })
        }
      };
      t.CustomCodeHelpersTransformer = v, t.CustomCodeHelpersTransformer = v = c([(0, p.injectable)(), d(0, (0, p.inject)(u.ServiceIdentifiers.ICallsGraphAnalyzer)), d(1, (0, p.inject)(u.ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)), d(2, (0, p.inject)(u.ServiceIdentifiers.TCustomNodeGroupStorage)), d(3, (0, p.inject)(u.ServiceIdentifiers.IRandomGenerator)), d(4, (0, p.inject)(u.ServiceIdentifiers.IOptions)), l("design:paramtypes", ["function" == typeof (o = void 0 !== h.ICallsGraphAnalyzer && h.ICallsGraphAnalyzer) ? o : Object, "function" == typeof (n = void 0 !== y.IPrevailingKindOfVariablesAnalyzer && y.IPrevailingKindOfVariablesAnalyzer) ? n : Object, "function" == typeof (i = void 0 !== f.TCustomCodeHelperGroupStorage && f.TCustomCodeHelperGroupStorage) ? i : Object, "function" == typeof (a = void 0 !== g.IRandomGenerator && g.IRandomGenerator) ? a : Object, "function" == typeof (s = void 0 !== m.IOptions && m.IOptions) ? s : Object])], v)
    }, 97403: e => {
      e.exports = require("class-validator")
    }, 97897: e => {
      e.exports = require("js-string-escape")
    }, 97910: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMAssignmentCompiler = void 0;
      const s = r(45337), c = r(20924), l = r(31391), d = r(27391), p = r(25115);
      let u = class {
        constructor(e) {
          this.vmCompilerUtils = e
        }

        compileAssignmentExpression(e, t) {
          var r, o, n, i, a;
          if ("??=" !== e.operator && "||=" !== e.operator && "&&=" !== e.operator) {
            if ("=" !== e.operator) {
              if (d.NodeGuards.isIdentifierNode(e.left)) {
                const r = e.left.name;
                this.vmCompilerUtils.emitLoadVariable(r, t)
              } else d.NodeGuards.isMemberExpressionNode(e.left) && this.emitLoadMemberForCompoundAssignment(e.left, t);
              null === (r = t.dispatch) || void 0 === r || r.expression(e.right), null === (o = t.dispatch) || void 0 === o || o.compoundOperator(e.operator)
            }
            if (d.NodeGuards.isIdentifierNode(e.left)) {
              const r = e.left.name;
              "=" === e.operator && (null === (n = t.dispatch) || void 0 === n || n.expression(e.right)), this.vmCompilerUtils.createInstructionBuilder(t).dup(), this.vmCompilerUtils.emitStoreVariable(r, t)
            } else if (d.NodeGuards.isMemberExpressionNode(e.left)) this.emitStoreMember(e.left, "=" === e.operator, e.right, t); else if (d.NodeGuards.isArrayPatternNode(e.left) || d.NodeGuards.isObjectPatternNode(e.left)) {
              if ("=" !== e.operator) throw new Error("Compound assignment with destructuring patterns is not supported");
              null === (i = t.dispatch) || void 0 === i || i.expression(e.right), this.vmCompilerUtils.createInstructionBuilder(t).dup(), null === (a = t.dispatch) || void 0 === a || a.destructuring(e.left, !1, !0)
            }
          } else this.compileLogicalAssignment(e, t)
        }

        compileLogicalAssignment(e, t) {
          var r, o, n, i, a, s, c, l, u;
          const f = this.vmCompilerUtils.createInstructionBuilder(t);
          if (d.NodeGuards.isIdentifierNode(e.left)) {
            const o = e.left.name;
            this.vmCompilerUtils.emitLoadVariable(o, t), f.dup();
            const n = "??=" === e.operator ? p.VMOpCode.JUMP_NULLISH : "||=" === e.operator ? p.VMOpCode.JUMP_IF_TRUE : p.VMOpCode.JUMP_IF_FALSE,
              i = this.vmCompilerUtils.emitConditionalJump(n, t);
            f.pop(), null === (r = t.dispatch) || void 0 === r || r.expression(e.right), f.dup(), this.vmCompilerUtils.emitStoreVariable(o, t), this.vmCompilerUtils.patchJump(i, t)
          } else if (d.NodeGuards.isMemberExpressionNode(e.left)) {
            const r = e.left;
            if (r.computed) {
              null === (o = t.dispatch) || void 0 === o || o.expression(r.object), null === (n = t.dispatch) || void 0 === n || n.expression(r.property), f.getComputed(), f.dup();
              const c = "??=" === e.operator ? p.VMOpCode.JUMP_NULLISH : "||=" === e.operator ? p.VMOpCode.JUMP_IF_TRUE : p.VMOpCode.JUMP_IF_FALSE,
                l = this.vmCompilerUtils.emitConditionalJump(c, t);
              f.pop(), null === (i = t.dispatch) || void 0 === i || i.expression(r.object), null === (a = t.dispatch) || void 0 === a || a.expression(r.property), null === (s = t.dispatch) || void 0 === s || s.expression(e.right), f.setComputed(), this.vmCompilerUtils.patchJump(l, t)
            } else if (d.NodeGuards.isIdentifierNode(r.property)) {
              const o = r.property.name, n = t.constantPool.add(o);
              null === (c = t.dispatch) || void 0 === c || c.expression(r.object), f.getPropertyByName(n), f.dup();
              const i = "??=" === e.operator ? p.VMOpCode.JUMP_NULLISH : "||=" === e.operator ? p.VMOpCode.JUMP_IF_TRUE : p.VMOpCode.JUMP_IF_FALSE,
                a = this.vmCompilerUtils.emitConditionalJump(i, t);
              f.pop(), null === (l = t.dispatch) || void 0 === l || l.expression(r.object), null === (u = t.dispatch) || void 0 === u || u.expression(e.right), f.setProperty(n), this.vmCompilerUtils.patchJump(a, t)
            }
          }
        }

        emitLoadMemberForCompoundAssignment(e, t) {
          var r, o;
          const n = this.vmCompilerUtils.createInstructionBuilder(t);
          if (null === (r = t.dispatch) || void 0 === r || r.expression(e.object), e.computed) null === (o = t.dispatch) || void 0 === o || o.expression(e.property), n.dup(), n.getComputed(); else if (d.NodeGuards.isIdentifierNode(e.property)) {
            const r = t.constantPool.add(e.property.name);
            n.dup(), n.getPropertyByName(r)
          }
        }

        emitStoreMember(e, t, r, o) {
          var n, i, a, s, c;
          const l = this.vmCompilerUtils.createInstructionBuilder(o);
          if (e.computed) t && (null === (n = o.dispatch) || void 0 === n || n.expression(e.object), null === (i = o.dispatch) || void 0 === i || i.expression(e.property), null === (a = o.dispatch) || void 0 === a || a.expression(r)), l.setComputed(); else if (t && (null === (s = o.dispatch) || void 0 === s || s.expression(e.object), null === (c = o.dispatch) || void 0 === c || c.expression(r)), d.NodeGuards.isIdentifierNode(e.property)) {
            const t = o.constantPool.add(e.property.name);
            l.setProperty(t)
          }
        }
      };
      t.VMAssignmentCompiler = u, t.VMAssignmentCompiler = u = n([(0, s.injectable)(), a(0, (0, s.inject)(l.ServiceIdentifiers.IVMCompilerUtils)), i("design:paramtypes", ["function" == typeof (o = void 0 !== c.IVMCompilerUtils && c.IVMCompilerUtils) ? o : Object])], u)
    }, 98081: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomainLockRedirectUrlRule = void 0;
      const o = r(45887);
      t.DomainLockRedirectUrlRule = e => (e.domainLock.length || (e = {
        ...e,
        domainLockRedirectUrl: o.DEFAULT_PRESET.domainLockRedirectUrl
      }), e)
    }, 98151: (e, t, r) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ObfuscationTarget = void 0;
      const o = r(39079);
      t.ObfuscationTarget = o.Utils.makeEnum({
        Browser: "browser",
        BrowserNoEval: "browser-no-eval",
        Node: "node",
        ServiceWorker: "service-worker"
      })
    }, 98811: (e, t) => {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.reservedIdentifierNames = void 0, t.reservedIdentifierNames = ["byte", "case", "char", "do", "else", "enum", "eval", "for", "goto", "if", "in", "int", "let", "long", "new", "null", "this", "true", "try", "var", "void", "with", "Array", "Attr", "Audio", "Blob", "Cache", "Date", "Error", "Event", "Feed", "File", "Hz", "Image", "Intl", "Lock", "Map", "Math", "Node", "Proxy", "Range", "Rect", "Set", "Table", "Text", "Touch"]
    }, 98858: function (e, t, r) {
      var o, n = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, i = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, a = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ArrayUtils = void 0;
      const s = r(45337), c = r(31391), l = r(31142);
      let d = class {
        constructor(e) {
          this.randomGenerator = e
        }

        createWithRange(e) {
          const t = [];
          for (let r = 0; r < e; r++) t.push(r);
          return t
        }

        fillWithRange(e, t) {
          const r = [];
          for (let o = 0; o < e; o++) r.push(t(o));
          return r
        }

        findMostOccurringElement(e) {
          var t;
          if (!e.length) return null;
          const r = {};
          let o = e[0], n = 1;
          for (const i of e) {
            const e = (null !== (t = r[i]) && void 0 !== t ? t : 0) + 1;
            e > n && (o = i, n = e), r[i] = e
          }
          return o
        }

        getLastElement(e) {
          return this.getLastElementByIndex(e, 0)
        }

        getLastElementByIndex(e, t) {
          var r;
          return null !== (r = e[e.length - 1 - t]) && void 0 !== r ? r : void 0
        }

        rotate(e, t) {
          if (!e.length) throw new ReferenceError("Cannot rotate empty array.");
          if (t <= 0) return e;
          const r = e;
          let o;
          for (; t--;) o = r.pop(), o && r.unshift(o);
          return r
        }

        shuffle(e) {
          const t = [...e];
          for (let e = t.length; e; e--) {
            const r = Math.floor(this.randomGenerator.getMathRandom() * e);
            [t[e - 1], t[r]] = [t[r], t[e - 1]]
          }
          return t
        }
      };
      t.ArrayUtils = d, t.ArrayUtils = d = n([(0, s.injectable)(), a(0, (0, s.inject)(c.ServiceIdentifiers.IRandomGenerator)), i("design:paramtypes", ["function" == typeof (o = void 0 !== l.IRandomGenerator && l.IRandomGenerator) ? o : Object])], d)
    }, 99097: function (e, t, r) {
      var o, n, i = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, a = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, s = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.ScopeIdentifiersTraverser = void 0;
      const c = r(45337), l = r(31391), d = r(64544), p = r(27391);
      let u = o = class {
        constructor(e) {
          this.scopeAnalyzer = e
        }

        traverseScopeIdentifiers(e, t, r) {
          this.scopeAnalyzer.analyze(e);
          const o = this.scopeAnalyzer.acquireScope(e);
          this.traverseScopeIdentifiersRecursive(o, o, r)
        }

        traverseScopeThroughIdentifiers(e, t, r) {
          this.scopeAnalyzer.analyze(e);
          const o = this.scopeAnalyzer.acquireScope(e);
          this.traverseScopeThroughIdentifiersRecursive(o, o, r)
        }

        traverseScopeIdentifiersRecursive(e, t, r) {
          const n = t.variableScope, i = p.NodeGuards.isNodeWithBlockLexicalScope(n.block) ? n.block : null,
            a = o.globalScopeNames.includes(n.type);
          if (i) {
            for (const s of t.variables) s.name !== o.argumentsVariableName && r({
              isGlobalDeclaration: a,
              isBubblingDeclaration: s.identifiers.some(e => e.parentNode && p.NodeGuards.isPropertyNode(e.parentNode) && e.parentNode.shorthand),
              rootScope: e,
              variable: s,
              variableScope: n,
              variableLexicalScopeNode: i
            });
            for (const o of t.childScopes) this.traverseScopeIdentifiersRecursive(e, o, r)
          }
        }

        traverseScopeThroughIdentifiersRecursive(e, t, r) {
          const n = t.variableScope, i = p.NodeGuards.isNodeWithBlockLexicalScope(n.block) ? n.block : null,
            a = o.globalScopeNames.includes(n.type);
          if (i) {
            for (const e of t.through) r({ isGlobalDeclaration: a, reference: e, variableLexicalScopeNode: i });
            for (const o of t.childScopes) this.traverseScopeThroughIdentifiersRecursive(e, o, r)
          }
        }
      };
      t.ScopeIdentifiersTraverser = u, u.argumentsVariableName = "arguments", u.globalScopeNames = ["global", "module"], t.ScopeIdentifiersTraverser = u = o = i([(0, c.injectable)(), s(0, (0, c.inject)(l.ServiceIdentifiers.IScopeAnalyzer)), a("design:paramtypes", ["function" == typeof (n = void 0 !== d.IScopeAnalyzer && d.IScopeAnalyzer) ? n : Object])], u)
    }, 99176: function (e, t, r) {
      var o, n, i, a, s, c, l, d, p = this && this.__decorate || function (e, t, r, o) {
        var n, i = arguments.length, a = i < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (a = (i < 3 ? n(a) : i > 3 ? n(t, r, a) : n(t, r)) || a);
        return i > 3 && a && Object.defineProperty(t, r, a), a
      }, u = this && this.__metadata || function (e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
      }, f = this && this.__param || function (e, t) {
        return function (r, o) {
          t(r, o, e)
        }
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.VMBytecodeCompiler = void 0;
      const m = r(45337), g = r(2784), h = r(63705), y = r(49703), S = r(75500), N = r(6946), b = r(20924),
        _ = r(94487), v = r(86173), I = r(31391), O = r(25115), C = r(27391), E = r(59805);
      let T = class {
        constructor(e, t, r, o, n, i, a, s) {
          this.destructuringCompiler = e, this.expressionCompiler = t, this.functionCompiler = r, this.parameterCompiler = o, this.statementCompiler = n, this.vmCompilerUtils = i, this.closureAnalyzer = a, this.scopeManager = s
        }

        createDispatchForContext(e) {
          return {
            expression: t => this.compileExpression(t, e),
            statement: t => this.compileStatement(t, e),
            destructuring: (t, r, o) => this.compileDestructuringPattern(t, e, r, o),
            function: e => this.compile(e),
            functionExpression: t => this.compileFunctionExpression(t, e),
            compoundOperator: t => this.compileCompoundOperator(t, e)
          }
        }

        compile(e, t) {
          var r, o, n, i, a, s, c, l;
          const d = this.vmCompilerUtils.createContext(void 0, !1, t);
          d.dispatchFactory = this.createDispatchForContext.bind(this), d.dispatch = d.dispatchFactory(d), (C.NodeGuards.isFunctionExpressionNode(e) && (null === (r = e.id) || void 0 === r ? void 0 : r.name) || C.NodeGuards.isFunctionDeclarationNode(e) && (null === (o = e.id) || void 0 === o ? void 0 : o.name)) && (d.functionName = e.id.name), C.NodeGuards.isBlockStatementNode(e.body) && this.preRegisterFunctionDeclarations(e.body, d), this.closureAnalyzer.analyzeEnvironmentVariables(e, d);
          let p = null;
          if (Array.from(d.envVars).some(e => !d.parameters.has(e))) {
            const e = this.vmCompilerUtils.createInstructionBuilder(d);
            p = this.scopeManager.enterEnv(d, e, !d.parentContext), d.needsEnvRestoreAtEnd = !0
          }
          this.parameterCompiler.compileParameters(e.params, d);
          const u = d.instructions.length;
          if (C.NodeGuards.isBlockStatementNode(e.body) && this.hoistVarDeclarations(e.body, d), C.NodeGuards.isBlockStatementNode(e.body) && d.declaredVariables && this.scanVariableDeclarations(e.body, d), C.NodeGuards.isBlockStatementNode(e.body) && this.hoistFunctionDeclarations(e.body, d), C.NodeGuards.isBlockStatementNode(e.body) && this.functionCompiler.initializeHoistedVarEnvVariables(e.body, d), C.NodeGuards.isBlockStatementNode(e.body)) {
            const t = this.scanForLexicalDeclarations(e.body.body);
            t.size > 0 && this.scopeManager.enterLocalsTDZ(d, [...t]);
            const r = this.vmCompilerUtils.createInstructionBuilder(d);
            for (const e of t) d.envVars.has(e) && r.declareTDZ(e)
          }
          if (C.NodeGuards.isBlockStatementNode(e.body)) for (const t of e.body.body) this.compileStatement(t, d); else this.compileExpression(e.body, d), this.vmCompilerUtils.createInstructionBuilder(d).return();
          if (!C.NodeGuards.isArrowFunctionExpressionNode(e)) {
            let e = !1, t = !1;
            for (const [, r] of d.nestedFunctions) if ((null === (n = r.capturedVars) || void 0 === n ? void 0 : n.includes(E.VM_SPECIAL_VARS.capturedThis)) && (e = !0), (null === (i = r.capturedVars) || void 0 === i ? void 0 : i.includes(E.VM_SPECIAL_VARS.capturedArguments)) && (t = !0), e && t) break;
            const r = [];
            if (e) {
              const e = d.constantPool.add(E.VM_SPECIAL_VARS.capturedThis);
              r.push({ op: O.VMOpCode.THIS }, { op: O.VMOpCode.STORE_TO_ENV, arg: e }, { op: O.VMOpCode.POP })
            }
            if (t) {
              const e = d.constantPool.add(E.VM_SPECIAL_VARS.capturedArguments);
              r.push({ op: O.VMOpCode.ARGUMENTS, arg: 0 }, {
                op: O.VMOpCode.STORE_TO_ENV,
                arg: e
              }, { op: O.VMOpCode.POP })
            }
            r.length > 0 && (d.instructions.splice(u, 0, ...r), this.vmCompilerUtils.adjustJumpTargetsAfterInsertion(u, r.length, d))
          }
          if (p) {
            const e = this.vmCompilerUtils.createInstructionBuilder(d);
            this.scopeManager.exitEnv(d, e, p)
          }
          const f = d.instructions[d.instructions.length - 1];
          let m;
          f && f.op === O.VMOpCode.RETURN || this.vmCompilerUtils.createInstructionBuilder(d).pushUndefined().return(), (C.NodeGuards.isFunctionExpressionNode(e) && (null === (a = e.id) || void 0 === a ? void 0 : a.name) || C.NodeGuards.isFunctionDeclarationNode(e) && (null === (s = e.id) || void 0 === s ? void 0 : s.name)) && (m = d.constantPool.add(e.id.name));
          const g = {
            id: d.nextBytecodeId++,
            constants: d.constantPool.getAll(),
            instructions: d.instructions,
            params: d.parameters.size,
            locals: Math.max(d.localVariables.size, d.maxLocals),
            functionRefIndices: d.functionRefIndices,
            isArrow: d.isArrowFunction,
            isAsync: null !== (c = e.async) && void 0 !== c && c,
            isGenerator: null !== (l = e.generator) && void 0 !== l && l,
            functionNameIndex: m
          }, h = Array.from(d.nestedFunctions.values());
          return h.forEach((e, t) => {
          }), { bytecode: g, nestedFunctions: h }
        }

        compileBlock(e, t) {
          const r = this.vmCompilerUtils.createContext();
          return this.compileStatement(e, r), {
            id: r.nextBytecodeId++,
            constants: r.constantPool.getAll(),
            instructions: r.instructions,
            params: t,
            locals: Math.max(r.localVariables.size, r.maxLocals)
          }
        }

        hoistVarDeclarations(e, t) {
          for (const r of e.body) this.vmCompilerUtils.traverseBlocksSkipScopes(r, e => {
            if (C.NodeGuards.isVariableDeclarationNode(e) && "var" === e.kind) for (const r of e.declarations) {
              const e = this.vmCompilerUtils.extractIdentifiersFromPattern(r.id);
              for (const r of e) {
                if (t.localVariables.has(r)) continue;
                const e = t.localVariables.size;
                t.localVariables.set(r, e)
              }
            }
          })
        }

        preRegisterFunctionDeclarations(e, t) {
          for (const r of e.body) if (C.NodeGuards.isFunctionDeclarationNode(r) && r.id) {
            const e = r.id.name;
            if (!t.localVariables.has(e)) {
              const r = t.localVariables.size;
              t.localVariables.set(e, r)
            }
          }
        }

        hoistFunctionDeclarations(e, t) {
          for (const r of e.body) if (C.NodeGuards.isFunctionDeclarationNode(r) && r.id) {
            const e = r.id.name;
            this.compileStatement(r, t), t.hoistedFunctionDeclarations.add(e)
          }
        }

        scanVariableDeclarations(e, t) {
          if (t.declaredVariables) for (const r of e.body) if (C.NodeGuards.isFunctionDeclarationNode(r) && r.id) t.declaredVariables.add(r.id.name); else if (C.NodeGuards.isVariableDeclarationNode(r)) for (const e of r.declarations) C.NodeGuards.isIdentifierNode(e.id) ? t.declaredVariables.add(e.id.name) : (C.NodeGuards.isObjectPatternNode(e.id) || C.NodeGuards.isArrayPatternNode(e.id)) && this.extractIdentifiersFromPattern(e.id, t.declaredVariables)
        }

        extractIdentifiersFromPattern(e, t) {
          if (C.NodeGuards.isIdentifierNode(e)) t.add(e.name); else if (C.NodeGuards.isObjectPatternNode(e)) for (const r of e.properties) C.NodeGuards.isPropertyNode(r) ? this.extractIdentifiersFromPattern(r.value, t) : C.NodeGuards.isRestElementNode(r) && this.extractIdentifiersFromPattern(r.argument, t); else if (C.NodeGuards.isArrayPatternNode(e)) for (const r of e.elements) r && this.extractIdentifiersFromPattern(r, t); else C.NodeGuards.isAssignmentPatternNode(e) ? this.extractIdentifiersFromPattern(e.left, t) : C.NodeGuards.isRestElementNode(e) && this.extractIdentifiersFromPattern(e.argument, t)
        }

        compileStatement(e, t) {
          switch (e.type) {
            case"BlockStatement":
              this.statementCompiler.compileBlockStatement(e, t);
              break;
            case"ExpressionStatement":
              this.compileExpression(e.expression, t), this.vmCompilerUtils.createInstructionBuilder(t).pop();
              break;
            case"ReturnStatement":
              this.statementCompiler.compileReturnStatement(e, t);
              break;
            case"IfStatement":
              this.statementCompiler.compileIfStatement(e, t);
              break;
            case"WhileStatement":
              this.statementCompiler.compileWhileStatement(e, t);
              break;
            case"DoWhileStatement":
              this.statementCompiler.compileDoWhileStatement(e, t);
              break;
            case"ForStatement":
              this.statementCompiler.compileForStatement(e, t);
              break;
            case"ForOfStatement":
              this.statementCompiler.compileForOfStatement(e, t);
              break;
            case"ForInStatement":
              this.statementCompiler.compileForInStatement(e, t);
              break;
            case"BreakStatement":
              this.statementCompiler.compileBreakStatement(e, t);
              break;
            case"ContinueStatement":
              this.statementCompiler.compileContinueStatement(e, t);
              break;
            case"ThrowStatement":
              this.statementCompiler.compileThrowStatement(e, t);
              break;
            case"TryStatement":
              this.statementCompiler.compileTryStatement(e, t);
              break;
            case"VariableDeclaration":
              this.statementCompiler.compileVariableDeclaration(e, t);
              break;
            case"FunctionDeclaration":
              this.statementCompiler.compileFunctionDeclaration(e, t);
              break;
            case"ClassDeclaration":
              this.statementCompiler.compileClassDeclaration(e, t);
              break;
            case"SwitchStatement":
              this.statementCompiler.compileSwitchStatement(e, t);
              break;
            case"LabeledStatement":
              this.statementCompiler.compileLabeledStatement(e, t);
              break;
            default:
              this.vmCompilerUtils.createInstructionBuilder(t).emitRaw({ op: O.VMOpCode.NOP })
          }
        }

        compileExpression(e, t) {
          this.expressionCompiler.compileExpression(e, t)
        }

        compileFunctionExpression(e, t) {
          this.functionCompiler.compileFunctionExpression(e, t)
        }

        compileCompoundOperator(e, t) {
          this.functionCompiler.compileCompoundOperator(e, t)
        }

        compileDestructuringPattern(e, t, r = !1, o = !1) {
          this.destructuringCompiler.compileDestructuringPattern(e, t, r, o)
        }

        scanForLexicalDeclarations(e) {
          const t = new Set;
          for (const r of e) if (C.NodeGuards.isVariableDeclarationNode(r) && ("let" === r.kind || "const" === r.kind)) for (const e of r.declarations) C.NodeGuards.isIdentifierNode(e.id) ? t.add(e.id.name) : (C.NodeGuards.isArrayPatternNode(e.id) || C.NodeGuards.isObjectPatternNode(e.id)) && this.extractIdentifiersFromPattern(e.id, t);
          return t
        }
      };
      t.VMBytecodeCompiler = T, t.VMBytecodeCompiler = T = p([(0, m.injectable)(), f(0, (0, m.inject)(I.ServiceIdentifiers.IVMDestructuringBytecodeCompiler)), f(1, (0, m.inject)(I.ServiceIdentifiers.IVMExpressionBytecodeCompiler)), f(2, (0, m.inject)(I.ServiceIdentifiers.IVMFunctionBytecodeCompiler)), f(3, (0, m.inject)(I.ServiceIdentifiers.IVMParameterBytecodeCompiler)), f(4, (0, m.inject)(I.ServiceIdentifiers.IVMStatementBytecodeCompiler)), f(5, (0, m.inject)(I.ServiceIdentifiers.IVMCompilerUtils)), f(6, (0, m.inject)(I.ServiceIdentifiers.IVMClosureAnalyzer)), f(7, (0, m.inject)(I.ServiceIdentifiers.IVMScopeManager)), u("design:paramtypes", ["function" == typeof (o = void 0 !== g.IVMDestructuringBytecodeCompiler && g.IVMDestructuringBytecodeCompiler) ? o : Object, "function" == typeof (n = void 0 !== h.IVMExpressionBytecodeCompiler && h.IVMExpressionBytecodeCompiler) ? n : Object, "function" == typeof (i = void 0 !== y.IVMFunctionBytecodeCompiler && y.IVMFunctionBytecodeCompiler) ? i : Object, "function" == typeof (a = void 0 !== S.IVMParameterBytecodeCompiler && S.IVMParameterBytecodeCompiler) ? a : Object, "function" == typeof (s = void 0 !== N.IVMStatementBytecodeCompiler && N.IVMStatementBytecodeCompiler) ? s : Object, "function" == typeof (c = void 0 !== b.IVMCompilerUtils && b.IVMCompilerUtils) ? c : Object, "function" == typeof (l = void 0 !== v.IVMClosureAnalyzer && v.IVMClosureAnalyzer) ? l : Object, "function" == typeof (d = void 0 !== _.IVMScopeManager && _.IVMScopeManager) ? d : Object])], T)
    }
  }, t = {}, r = function r(o) {
    var n = t[o];
    if (void 0 !== n) return n.exports;
    var i = t[o] = { exports: {} };
    return e[o].call(i.exports, i, i.exports, r), i.exports
  }(51981);
  module.exports = r
})();
//# sourceMappingURL=index_debug.js.map